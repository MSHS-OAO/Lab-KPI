---
title: "MSHS Laboratory KPI Dashboard (Final)"
knit: (function(input, ...) {
      rmarkdown::render(input,
            output_file = paste0("/Pathology/Final Dashboard Output/",
            "Lab KPI Final Dashboard ",
                    Sys.Date()),
      envir = globalenv()
    )
  })
output:
  html_document
    # toc: true
    # toc_depth: 2
    # toc_float: true
---
  
<!-- <h4><span style = "color:red">Draft - Not For Distribution</h4></span style = "color:red"> -->


```{r global_options, echo = FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
rm(list = ls())
```

```{r package_ref file, warning = FALSE, message = FALSE, echo = FALSE}
#######
# Source code for importing the needed packages, constants, reference files, and
# data templates for the lab KPI dashboard pre-processing -----
#######
#source(here::here("Automated Daily Dashboard/Packages_Ref_Info.R"))

#######
# Code for importing the needed packages, constants, reference files, and
# data templates for the lab KPI dashboard pre-processing -----
#######

#Install packages only the first time you run the code
# install.packages("timeDate")
# install.packages("lubridate")
# install.packages("readxl")
# install.packages("dplyr")
# install.packages("reshape2")
# install.packages("knitr")
# install.packages("gdtools")
# install.packages("kableExtra")
# install.packages("formattable")
# install.packages("bizdays")
# install.packages("rmarkdown")
# install.packages("stringr")
# install.packages("writexl")
# install.packages("gsubfn")
# install.packages("tidyr")
#-------------------------------Required packages------------------------------#

#Required packages: run these every time you run the code
library(timeDate)
library(readxl)
library(bizdays)
library(dplyr)
library(lubridate)
library(reshape2)
library(knitr)
# library(gdtools)
# library(kableExtra)
library(kableExtra, "~/R/x86_64-pc-linux-gnu-library/4.2")
library(formattable)
library(rmarkdown)
library(stringr)
library(writexl)
library(gsubfn)
library(tidyr)

#-------------------------------holiday/weekend-------------------------------#
# Get today and yesterday's date
today <- Sys.Date()
# today <- as.Date("9/21/2023", format = "%m/%d/%Y")

#Determine if yesterday was a holiday/weekend
#get yesterday's DOW
yesterday <- today - 1

#Get yesterday's DOW
yesterday_day <- wday(yesterday, label = TRUE, abbr = TRUE)

#Remove Good Friday from MSHS Holidays
nyse_holidays <- as.Date(holidayNYSE(year = 1990:2100))
good_friday <- as.Date(GoodFriday())
mshs_holiday <- nyse_holidays[good_friday != nyse_holidays]

#Determine whether yesterday was a holiday/weekend
holiday_det <- isHoliday(as.timeDate(yesterday), holidays = mshs_holiday)

#Set up a calendar for collect to received TAT calculations for Path & Cyto
create.calendar("MSHS_working_days", mshs_holiday,
                weekdays = c("saturday", "sunday"))
bizdays.options$set(default.calendar = "MSHS_working_days")


user_directory <- paste0("/Pathology/")

# Import analysis reference data
reference_file <- paste0(user_directory,
                         "/Code Reference/",
                         "Analysis Reference 2023-09-15.xlsx")

# CP and Micro --------------------------------
cp_scc_test_codes <- read_excel(reference_file, sheet = "SCC_TestCodes")
cp_sun_test_codes <- read_excel(reference_file, sheet = "SUN_TestCodes")

# Create data frame of CP tests and divisions
cp_test_divisions <- 
  unique(
    rbind(unique(cp_scc_test_codes[, c("TEST", "DIVISION")]),
          unique(cp_sun_test_codes[, c("TEST", "DIVISION")])))

test_names <- cp_test_divisions$TEST

cp_tat_targets <- read_excel(reference_file, sheet = "Turnaround Targets")
#
# Add a column concatenating test, priority, and setting for matching later
cp_tat_targets <- cp_tat_targets %>%
  mutate(Concate = ifelse(
    PRIORITY == "All" & PT_SETTING == "All", paste(TEST, DIVISION),
    ifelse(PRIORITY != "All" & PT_SETTING == "All",
           paste(TEST, DIVISION, PRIORITY),
           paste(TEST, DIVISION, PRIORITY, PT_SETTING))))

cp_scc_icu <- read_excel(reference_file, sheet = "SCC_ICU")
cp_sun_icu <- read_excel(reference_file, sheet = "SUN_ICU")

cp_scc_icu <- cp_scc_icu %>%
  mutate(SiteCodeName = paste(SITE, WARD, WARD_NAME))

cp_sun_icu <- cp_sun_icu %>%
  mutate(SiteCodeName = paste(SITE, LOC_CODE, LOC_NAME))

cp_scc_setting <- read_excel(reference_file, sheet = "SCC_ClinicType")
cp_sun_setting <- read_excel(reference_file, sheet = "SUN_LocType")

cp_mshs_sites <- read_excel(reference_file, sheet = "SiteNames")

cp_mshs_sites <- cp_mshs_sites %>%
  rename(Site = SITE)

cp_micro_lab_order <- c("Troponin",
                        "Lactate WB",
                        "BUN",
                        "HGB",
                        "PT",
                        "Rapid Flu",
                        "C. diff")

all_sites <- c("MSH", "MSQ", "MSBI", "MSB", "MSW", "MSM", "MSSN", "RTC")
hosp_sites <- c("MSH", "MSQ", "MSBI", "MSB", "MSW", "MSM", "MSSN")
infusion_sites <- c("RTC")

pt_setting_order <- c("ED", "ICU", "IP Non-ICU", "Amb", "Other")
pt_setting_order2 <- c("ED & ICU", "IP Non-ICU", "Amb", "Other")
dashboard_pt_setting <- c("ED & ICU", "IP Non-ICU", "Amb")

dashboard_priority_order <- c("All", "Stat", "Routine")

cp_division_order <- c("Chemistry", "Hematology", "Microbiology RRL", "Infusion")

# Create template dataframes for combinations of tests, priority, and settings
# that will be used in TAT and volume look back tables. These templates ensure
# all relevant combinations are included in the tables regardless of resulted
# volume
# Create template data frames for combinations of tests, priority and settings
# that will be used in TAT tables and volume lookback tables
tat_base_template <-
  expand.grid(
    "Test" = test_names,
    "Site" = all_sites,
    "DashboardPriority" = dashboard_priority_order,
    "DashboardSetting" = dashboard_pt_setting,
    KEEP.OUT.ATTRS = FALSE,
    stringsAsFactors = FALSE
  ) %>%
  arrange(Test, Site) %>%
  left_join(cp_test_divisions, by = c("Test" = "TEST"))

vol_base_template <- 
  expand.grid(
    "Test" = test_names,
    "Site" = all_sites,
    "DashboardPriority" = dashboard_priority_order,
    "PtSetting" = pt_setting_order,
    KEEP.OUT.ATTRS = FALSE,
    stringsAsFactors = FALSE
  ) %>%
  arrange(Test, Site) %>%
  left_join(cp_test_divisions, by = c("Test" = "TEST")) %>%
  arrange(Test, Site, DashboardPriority, PtSetting)

# Select applicable test, priority, setting combinations based on lab operations
tat_dashboard_templ <- tat_base_template %>%
  rename(Division = DIVISION) %>%
  mutate(
    # Update Division for RTC to Infusion
    Division = ifelse(Site %in% c("RTC"), "Infusion", Division),
    # Create column for applicable combinations
    Incl = ifelse(
      # Remove ED & ICU labs with Routine priority since all labs in these
      # these settings are treated as stat
      (DashboardPriority %in% c("Routine") &
         DashboardSetting %in% c("ED & ICU")) |
        # Remove ambulatory troponin and lactate since these labs are collected
        # in ambulatory settings. Remove stat and routine stratification for
        # these labs since all are treated as stat
        (Test %in% c("Troponin", "Lactate WB") &
           (DashboardPriority %in% c("Stat", "Routine") |
              DashboardSetting %in% c("Amb"))) |
        # Remove "all" priority for BUN, PT, and HGB labs for non-infusion
        # settings
        (Test %in% c("BUN", "PT", "HGB") & DashboardPriority %in% c("All") &
           !(Division %in% c("Infusion"))) |
        # Remove priority stratification for rapid flu and c. diff since all
        # are treated as stat
        (Test %in% c("Rapid Flu", "C. diff") &
           !(DashboardPriority %in% c("All"))) |
        # Remove any labs other than BUN and HGB for infusion since those are
        # the only labs processed there. Remove stat and routine stratification
        # for infusion labs since all labs treated the same
        (Division %in% c("Infusion") & (!(Test %in% c("BUN", "HGB")) |
                                          !(DashboardSetting %in% c("Amb")) |
                                          !(DashboardPriority %in% c("All")))), "Excl", "Incl")) %>%
  filter(Incl == "Incl")

vol_dashboard_templ <- vol_base_template %>%
  rename(Division = DIVISION) %>%
  mutate(
    # Update Division for RTC to Infusion
    Division = ifelse(Site %in% c("RTC"), "Infusion", Division),
    # Create column for applicable combinations
    Incl = ifelse(
      # Remove ED & ICU labs with Routine priority since all labs in these
      # these settings are treated as stat
      (DashboardPriority %in% c("Routine") &
         PtSetting %in% c("ED", "ICU")) |
        # Remove stat and routine stratification for troponin and lactate labs
        # these labs since all are treated as stat
        (Test %in% c("Troponin", "Lactate WB") &
           (DashboardPriority %in% c("Stat", "Routine"))) |
        # Remove "all" priority for BUN, PT, and HGB labs
        (Test %in% c("BUN", "PT", "HGB") & DashboardPriority %in% c("All") &
           !(Division %in% c("Infusion"))) |
        # Remove Microbiology RRL since resulted volume is included already in
        # TAT tables
        (Division %in% c("Microbiology RRL")) |
        # Remove any labs other than BUN and HGB from RTC since those are the
        # only labs processed there. Also remove non-amb setting
        (Division %in% c("Infusion") & (!(Test %in% c("BUN", "HGB")) |
                                          !(PtSetting %in% c("Amb")) |
                                          !(DashboardPriority %in% c("All")))),
      "Excl", "Incl")) %>%
  filter(Incl == "Incl")

#-----------Patient Setting Excel File-----------#
#Using Rev Center to determine patient setting
patient_setting <- data.frame(read_excel(reference_file,
                                         sheet = "AP_Patient Setting"),
                              stringsAsFactors = FALSE)

#-----------Anatomic Pathology Targets Excel File-----------#
tat_targets_ap <- data.frame(read_excel(reference_file,
                                        sheet = "AP_TAT Targets"),
                             stringsAsFactors = FALSE)

#-----------GI Codes Excel File-----------#
#Upload the exclusion vs inclusion criteria associated with the GI codes
gi_codes <- data.frame(read_excel(reference_file, sheet = "GI_Codes"),
                       stringsAsFactors = FALSE)

SPEC_GROUP <- c("Breast", "GI","CYTO GYN", "CYTO NONGYN")
PATIENT_SETTING <- c("IP", "Amb")
SITES <- c("MSB","MSBI","PACC","MSW","MSH","MSM","MSSN","MSQ","NYEE")
TAB <- c("Efficiency Indicators","24 Hour Volume")
METRIC <- c("received_to_signed_out_within_target",
            "avg_collection_to_signed_out",
            "no_cases_signed")

table_ap_template <- expand.grid(SPEC_GROUP, PATIENT_SETTING,SITES,TAB,METRIC)

colnames(table_ap_template) <- c("SPECIMEN_GROUP", "PATIENT_SETTING","SITE","TAB","METRIC")

table_ap_template <- table_ap_template %>%
  mutate(DIVISION = case_when(SPECIMEN_GROUP %in% c("Breast", "GI") ~ "SURGICAL PATHOLOGY",
                              SPECIMEN_GROUP %in% c("CYTO GYN", "CYTO NONGYN") ~ "CYTOLOGY"))


table_ap_template <- table_ap_template %>%
  filter(!((DIVISION == "SURGICAL PATHOLOGY") & 
             (SPECIMEN_GROUP %in% c("CYTO GYN", "CYTO NONGYN"))))

table_ap_template <- table_ap_template %>%
  filter(!((DIVISION == "CYTOLOGY") & 
             (SPECIMEN_GROUP %in% c("Breast", "GI"))))



table_ap_template <- table_ap_template %>%
  filter(!((DIVISION == "CYTOLOGY") & 
             (TAB == "Efficiency Indicators") & 
             (METRIC %in% c("received_to_signed_out_within_target",
                            "no_cases_signed"))))

table_ap_template <- table_ap_template %>%
  filter(!((DIVISION == "SURGICAL PATHOLOGY") & 
             (TAB == "Efficiency Indicators") & 
             (METRIC == "no_cases_signed")))


table_ap_template <- table_ap_template %>%
  filter(!((DIVISION %in% c("SURGICAL PATHOLOGY","CYTOLOGY")) & 
             (TAB == "24 Hour Volume") & 
             (METRIC %in% c("received_to_signed_out_within_target",
                            "avg_collection_to_signed_out"))))

# Efficiency Indicators template Pathology ----
table_ap_template_surgical_pathology <- table_ap_template %>%
  filter(DIVISION == "SURGICAL PATHOLOGY" &
           !SITE %in% c("NYEE","MSSN")) %>%
  filter(TAB == "Efficiency Indicators") %>%
  select(-DIVISION,-TAB)

# Efficiency Indicators template Cytology ----
table_ap_template_cytology <- table_ap_template %>%
  filter(DIVISION == "CYTOLOGY" &
           !SITE %in% c("MSSN")) %>%
  filter(TAB == "Efficiency Indicators") %>%
  select(-DIVISION,-TAB)


# 24 Hour Volume template Pathology ----
table_ap_template_surgical_pathology_24 <- table_ap_template %>%
  filter(DIVISION == "SURGICAL PATHOLOGY" &
           !SITE %in% c("NYEE","MSSN")) %>%
  filter(TAB == "24 Hour Volume") %>%
  select(-DIVISION,-TAB)

# 24 Hour Volume template Cytology ----
table_ap_template_cytology_24 <- table_ap_template %>%
  filter(DIVISION == "CYTOLOGY" &
           !SITE %in% c("MSSN")) %>%
  filter(TAB == "24 Hour Volume") %>%
  select(-DIVISION,-TAB)


# Creating Mapping Template for AP Display Backlog ----
SPEC_GROUP <- c("CYTO GYN", "CYTO NONGYN")
METRIC <- c("total_accessioned_volume",
            "cyto_backlog",
            "percentile_25th",
            "percentile_50th",
            "maximum")

table_backlog_template <- expand.grid(SPEC_GROUP,METRIC)


colnames(table_backlog_template) <- c("Spec_group",
                                      "METRIC")
sp_vol_column_names <- c("Case Type",
                         "Setting",
                         "MSH",
                         "MSQ",
                         "MSBI",
                         "PACC",
                         "MSB",
                         "MSW",
                         "MSM")

cyto_vol_column_names <- c("Case Type",
                           "Setting",
                           "MSH",
                           "MSQ",
                           "MSBI",
                           "PACC",
                           "MSB",
                           "MSW",
                           "MSM",
                           "NYEE")
```

```{r raw_data_import file, warning = FALSE, message = FALSE, echo = FALSE}
#######
# Source Code for importing the raw data needed for the first run of the 
# daily dashboard.
# Imported data includes:
# 1. SCC data for clinical pathology
# 2. SunQuest data for clinical pathology
# 3. PowerPath data for anatomic pathology (surgical pathology & cytology)
# 4. Epic data for anatomic pathology including cytology
# 5. Backlog data for anatomic pathology including cytology-----
#######

#source(here::here("Automated Daily Dashboard/Daily_Run_Raw_Data_Import.R"))

# Determine date of resulted labs/specimens
resulted_date <- yesterday

# Format yesterday's date for dashboard visualization
result_date_text <- format(resulted_date,
                           format = "%a %m/%d/%y")

# Create regular expressions for beginning each file type
scc_pattern_start <- "^(Doc){1}.+"
sq_pattern_start <- "^(KPI_Daily_TAT_Report){1}.*"
pp_pattern_start <- "^(KPI REPORT - RAW DATA V4_V2){1}.*"
epic_pattern_start <- "^(MSHS Pathology Orders Epic){1}.*"
cyto_backlog_pattern_start <- "^(KPI REPORT - CYTOLOGY PENDING CASES){1}.*"

# Format resulted date as it would appear in saved files
# This will always be yesterday since this is run on weekdays, weekends, and holidays
report_date_file_format <- format(today, "%Y-%m-%d")

# Find SCC file for labs resulted yesterday
scc_data_file <- list.files(
  path = paste0(user_directory, "/SCC CP Reports"),
  pattern = paste0(scc_pattern_start,
                   "(",
                   report_date_file_format,
                   ".xlsx)$"),
  ignore.case = TRUE)

# Import SCC file for labs resulted yesterday, if file exists
if (length(scc_data_file) != 0) {
  scc_data_raw <- read_excel(path =
                               paste0(user_directory,
                                      "/SCC CP Reports/",
                                      scc_data_file),
                             sheet = 1, col_names = TRUE)
} else {
  scc_data_raw <- NULL
}

# Find Sunquest file for labs resulted yesterday
sq_data_file <- list.files(
  path = paste0(user_directory, "/SUN CP Reports"),
  pattern = paste0(sq_pattern_start,
                   "(",
                   report_date_file_format,
                   ".xls)$"),
  ignore.case = TRUE)

# Import Sunquest file for labs resulted yesterday, if file exists
if (length(sq_data_file) != 0) {
  sq_data_raw <- suppressWarnings(read_excel(path =
                                               paste0(user_directory,
                                                      "/SUN CP Reports/",
                                                      sq_data_file),
                                             sheet = 1, col_names = TRUE))
} else {
  sq_data_raw <- NULL
}


# Find Powerpath file for cases signed out yesterday
pp_data_file <- list.files(
  path = paste0(user_directory, "/AP & Cytology Signed Cases Reports"),
  pattern = paste0(pp_pattern_start,
                   "(",
                   report_date_file_format,
                   ".xls)$"),
  ignore.case = TRUE)

# Import Powerpath file for cases signed out yesterday, if any exists
if (length(pp_data_file) != 0) {
  pp_data_raw <- read_excel(path =
                              paste0(user_directory,
                                     "/AP & Cytology Signed Cases Reports/",
                                     pp_data_file),
                            skip = 1, 1)
  
  pp_data_raw <- data.frame(pp_data_raw[-nrow(pp_data_raw), ],
                            stringsAsFactors = FALSE)
} else {
  pp_data_raw <- NULL
}


# Find Epic Cytology file for cases signed out yesterday
epic_data_file <- list.files(
  path = paste0(user_directory, "/EPIC Cytology"),
  pattern = paste0(epic_pattern_start,
                   "(",
                   report_date_file_format,
                   ".xlsx)$"),
  ignore.case = TRUE)

# Import Epic Cytology file for cases signed out yesterday, if any exists
if (length(epic_data_file) != 0) {
  epic_data_raw <- read_excel(path =
                                paste0(user_directory,
                                       "/EPIC Cytology/",
                                       epic_data_file),1)
} else {
  epic_data_raw <- NULL
}


# Find Cytology backlog file for backlog as of yesterday
cyto_backlog_data_file <- list.files(
  path = paste0(user_directory, "/Cytology Backlog Reports"),
  pattern = paste0(cyto_backlog_pattern_start,
                   "(",
                   report_date_file_format,
                   ".xls)$"),
  ignore.case = TRUE)

# Import Cytology backlog file for backlog as of yesterday, if any exists
if (length(cyto_backlog_data_file) != 0) {
  cyto_backlog_data_raw <- read_excel(path =
                                        paste0(user_directory,
                                               "/Cytology Backlog Reports/",
                                               cyto_backlog_data_file),
                                      skip = 1, 1)
  
  cyto_backlog_data_raw <- data.frame(
    cyto_backlog_data_raw[-nrow(cyto_backlog_data_raw), ],
    stringsAsFactors = FALSE)
} else {
  cyto_backlog_data_raw <- NULL
}

cp_eval <- !(is.null(scc_data_raw) | is.null(sq_data_raw))

ap_eval <- !(is.null(pp_data_file) | is.null(cyto_backlog_data_raw) | is.null(epic_data_raw))
             
```

```{r Import CP custom functions, warning = FALSE, message = FALSE, echo = FALSE}
# Code with custom functions for preprocessing, analyzing, and displaying
# Clinical Pathology KPI -----
# CP includes Chemistry, Hematology, and Microbiology RRL divisions
# source(here::here("Automation Standard Files/SCC_Sunquest_Preprocessing_Functions.R"))
# 
# source(here::here("Automated Daily Dashboard/CP_Summary_Kable_Functions.R"))


# Custom functions for processing raw SCC and Sunquest reports

# SCC Processing ----------------
preprocess_scc <- function(raw_scc)  {
  # Preprocess SCC data -------------------------------
  # Remove any duplicates
  raw_scc <- unique(raw_scc)
  # Correct and format any columns that were not imported correctly; usually have a message saying "*failed to decode... *"
  raw_scc[c("ORDERING_DATE",
            "COLLECTION_DATE",
            "RECEIVE_DATE",
            "VERIFIED_DATE")] <-
    lapply(raw_scc[c("ORDERING_DATE",
                     "COLLECTION_DATE",
                     "RECEIVE_DATE",
                     "VERIFIED_DATE")],
           function(x)
             ifelse(!is.na(x) & str_detect(x, "\\*.*\\*"),
                    str_replace(x, "\\*.*\\*", ""), x))
  
  raw_scc <- raw_scc %>%
    mutate(across(where(is.character), gsub,
                  pattern = "\\*.*\\*",
                  replacement = ""))
  
  raw_scc[c("ORDERING_DATE",
            "COLLECTION_DATE",
            "RECEIVE_DATE",
            "VERIFIED_DATE")] <-
    lapply(raw_scc[c("ORDERING_DATE",
                     "COLLECTION_DATE",
                     "RECEIVE_DATE",
                     "VERIFIED_DATE")],
           as.POSIXct, tz = "UTC",
           format = "%Y-%m-%d %H:%M:%OS",
           options(digits.sec = 1))
  
  # SCC lookup references ----------------------------------------------
  # Crosswalk in scope labs
  raw_scc <- left_join(raw_scc,
                       cp_scc_test_codes,
                       by = c("TEST_ID" = "SCC_TEST_ID"))
  
  # Determine if test is included based on crosswalk results
  raw_scc <- raw_scc %>%
    mutate(TestIncl = !is.na(TEST)) %>%
    filter(TestIncl)
  
  # Crosswalk unit type
  raw_scc <- left_join(raw_scc, cp_scc_setting,
                       by = c("CLINIC_TYPE" = "CLINIC_TYPE"))
  # Crosswalk site name
  raw_scc <- left_join(raw_scc, cp_mshs_sites,
                       by = c("SITE" = "DATA_SITE"))
  
  # Preprocess SCC data and add any necessary columns
  raw_scc <- raw_scc %>%
    mutate(
      # Subset HGB and BUN tests completed at RTC as a separate site since they
      # are processed at RTC
      Site = ifelse(TEST %in% c("HGB", "BUN") &
                      str_detect(replace_na(WARD_NAME, ""),
                                 "Ruttenberg Treatment Center"),
                    "RTC", Site),
      # Update division to Infusion for RTC
      DIVISION = ifelse(Site %in% c("RTC"), "Infusion", DIVISION),
      # Determine if unit is an ICU based on site mappings
      ICU = paste(Site, Ward, WARD_NAME) %in% cp_scc_icu$SiteCodeName,
      # Create a column for resulted date
      RESULT_DATE = date(VERIFIED_DATE),
      # Create master setting column to identify ICU and IP Non-ICU units
      DETAILED_SETTING = ifelse(SETTING_ROLL_UP == "IP" & ICU, "ICU",
                                ifelse(SETTING_ROLL_UP == "IP" & !ICU,
                                       "IP Non-ICU", SETTING_ROLL_UP)),
      # Create dashboard setting column to roll up master settings based on
      # desired dashboard grouping (ie, group ED and ICU together)
      DASHBOARD_SETTING = ifelse(DETAILED_SETTING %in% c("ED", "ICU"),
                                 "ED & ICU", DETAILED_SETTING),
      # Create column with adjusted priority based on assumption that all ED and
      # ICU labs are treated as stat per operational leadership
      ADJ_PRIORITY = ifelse(DETAILED_SETTING %in% c("ED", "ICU") |
                              PRIORITY %in% "S", "Stat", "Routine"),
      # Calculate turnaround times
      COLLECT_TO_RECEIVE_TAT =
        as.numeric(RECEIVE_DATE - COLLECTION_DATE, units = "mins"),
      RECEIVE_TO_RESULT_TAT =
        as.numeric(VERIFIED_DATE - RECEIVE_DATE, units = "mins"),
      COLLECT_TO_RESULT_TAT =
        as.numeric(VERIFIED_DATE - COLLECTION_DATE, units = "mins"),
      #
      # Determine if order was an add on or original order based on time between
      # order and receive times
      ADD_ON_FINAL = ifelse(as.numeric(ORDERING_DATE - RECEIVE_DATE,
                                       units = "mins")
                            > 5, "AddOn", "Original"),
      # Determine if collection time is missing
      MISSING_COLLECT = COLLECT_TO_RECEIVE_TAT %in% 0, #COLLECTION_DATE %in% RECEIVE_DATE,
      #
      # Determine TAT based on test, division, priority, and patient setting
      # Create column concatenating test and division to determine TAT targets
      Concate1 = paste(TEST, DIVISION),
      #
      # Create dashboard priority column
      DASHBOARD_PRIORITY = ifelse(
        cp_tat_targets$PRIORITY[match(
          Concate1, 
          paste(cp_tat_targets$TEST, cp_tat_targets$DIVISION))] == "All",
        "All", ADJ_PRIORITY),
      # Create column concatenating test, division, and priority to determine
      # TAT targets
      Concate2 = paste(TEST, DIVISION, DASHBOARD_PRIORITY),
      # Create column concatenating test, division, priority, and setting to
      # determine TAT targets
      Concate3 = paste(TEST, DIVISION, DASHBOARD_PRIORITY, DETAILED_SETTING),
      #
      # Determine Receive to Result TAT target using this logic:
      # 1. Try to match test, division, priority, and setting (applicable for
      # labs with different TAT targets based on patient setting and order priority)
      # 2. Try to match test, division, and priority (applicable for labs with
      # different TAT targets based on order priority)
      # 3. Try to match test and division - (applicable for labs with
      # TAT targets that are independent of patient setting or priority)
      #
      # Determine Receive to Result TAT target based on above logic/scenarios
      RECEIVE_RESULT_TARGET =
        # Match on scenario 1
        ifelse(!is.na(match(Concate3, cp_tat_targets$Concate)),
               cp_tat_targets$RECEIVE_TO_RESULT_TARGET[
                 match(Concate3, cp_tat_targets$Concate)],
               # Match on scenario 2
               ifelse(!is.na(match(Concate2, cp_tat_targets$Concate)),
                      cp_tat_targets$RECEIVE_TO_RESULT_TARGET[
                        match(Concate2, cp_tat_targets$Concate)],
                      # Match on scenario 3
                      cp_tat_targets$RECEIVE_TO_RESULT_TARGET[
                        match(Concate1, cp_tat_targets$Concate)])),
      #
      # Determine Collect to Result TAT target based on above logic/scenarios
      COLLECT_RESULT_TARGET =
        # Match on scenario 1
        ifelse(!is.na(match(Concate3, cp_tat_targets$Concate)),
               cp_tat_targets$COLLECT_TO_RESULT_TARGET[
                 match(Concate3, cp_tat_targets$Concate)],
               # Match on scenario 2
               ifelse(!is.na(match(Concate2, cp_tat_targets$Concate)),
                      cp_tat_targets$COLLECT_TO_RESULT_TARGET[
                        match(Concate2, cp_tat_targets$Concate)],
                      # Match on scenario 3
                      cp_tat_targets$COLLECT_TO_RESULT_TARGET[
                        match(Concate1, cp_tat_targets$Concate)])),
      #
      # Determine if Receive to Result and Collect to Result TAT meet targets
      RECEIVE_RESULT_IN_TARGET = ifelse(is.na(RECEIVE_TO_RESULT_TAT), FALSE,
                                        RECEIVE_TO_RESULT_TAT <= RECEIVE_RESULT_TARGET),
      COLLECT_RESULT_IN_TARGET = ifelse(is.na(COLLECT_TO_RESULT_TAT), FALSE,
                                        COLLECT_TO_RESULT_TAT <= COLLECT_RESULT_TARGET),
      # Create column with patient name, order ID, test, collect, receive, and
      # result date and determine if there is a duplicate; order time excluded
      Concate4 = paste(LAST_NAME, FIRST_NAME,
                       ORDER_ID, TEST_NAME,
                       COLLECTION_DATE, RECEIVE_DATE, VERIFIED_DATE),
      DuplTest = duplicated(Concate4),
      # Determine whether or not to include this particular lab in TAT analysis
      # Exclusion criteria:
      # 1. Add on orders
      # 2. Orders from "Other" settings
      # 3. Orders with collect or receive times after result time
      # 4. Orders with missing collect, receive, or result timestamps
      # 5. Orders with missing collection times are excluded from
      # collect-to-result and collect-to-receive turnaround time analyis
      RECEIVE_TIME_TAT_INCL = ifelse(ADD_ON_FINAL == "AddOn" |
                                       DETAILED_SETTING == "Other" |
                                       COLLECT_TO_RECEIVE_TAT < 0 |
                                       COLLECT_TO_RESULT_TAT < 0 |
                                       RECEIVE_TO_RESULT_TAT < 0 |
                                       is.na(COLLECT_TO_RESULT_TAT) |
                                       is.na(RECEIVE_TO_RESULT_TAT), FALSE, TRUE),
      COLLECT_TIME_TAT_INCL = ifelse(MISSING_COLLECT |
                                       ADD_ON_FINAL == "AddOn" |
                                       DETAILED_SETTING == "Other" |
                                       COLLECT_TO_RECEIVE_TAT < 0 |
                                       COLLECT_TO_RESULT_TAT < 0 |
                                       RECEIVE_TO_RESULT_TAT < 0 |
                                       is.na(COLLECT_TO_RESULT_TAT) |
                                       is.na(RECEIVE_TO_RESULT_TAT), FALSE, TRUE))
  
  # Remove duplicate tests
  raw_scc <- raw_scc %>%
    filter(!DuplTest)
  
  # Determine volume of labs associated with each date and identify correct date
  scc_resulted_dates_vol <- raw_scc %>%
    group_by(RESULT_DATE) %>%
    summarize(VolLabs = n()) %>%
    arrange(desc(VolLabs)) %>%
    ungroup()
  
  scc_correct_date <- scc_resulted_dates_vol$RESULT_DATE[1]
  
  raw_scc <- raw_scc %>%
    filter(RESULT_DATE %in% scc_correct_date)
  
  # Select columns
  scc_processed <- raw_scc %>%
    select(Ward, WARD_NAME, ORDER_ID, `REQUESTING_DOC NAME`, MPI, `WORK SHIFT`,
           TEST_NAME, TEST, DIVISION, PRIORITY,
           Site, ICU, CLINIC_TYPE,
           SETTING, SETTING_ROLL_UP, DETAILED_SETTING, DASHBOARD_SETTING,
           ADJ_PRIORITY, DASHBOARD_PRIORITY,
           ORDERING_DATE, COLLECTION_DATE, RECEIVE_DATE, VERIFIED_DATE,
           RESULT_DATE,
           COLLECT_TO_RECEIVE_TAT, RECEIVE_TO_RESULT_TAT, COLLECT_TO_RESULT_TAT,
           ADD_ON_FINAL, MISSING_COLLECT,
           RECEIVE_RESULT_TARGET, COLLECT_RESULT_TARGET,
           RECEIVE_RESULT_IN_TARGET, COLLECT_RESULT_IN_TARGET,
           RECEIVE_TIME_TAT_INCL, COLLECT_TIME_TAT_INCL
    ) %>%
    rename(LOC_CODE = Ward,
           LOC_NAME = WARD_NAME,
           REQUEST_MD = `REQUESTING_DOC NAME`,
           MSMRN = MPI,
           WORK_SHIFT = `WORK SHIFT`,
           ORDER_PRIORITY = PRIORITY,
           SITE = Site,
           LOC_TYPE = CLINIC_TYPE,
           ORDER_TIME = ORDERING_DATE,
           COLLECT_TIME = COLLECTION_DATE,
           RECEIVE_TIME = RECEIVE_DATE,
           RESULT_TIME = VERIFIED_DATE)
  
  return(scc_processed)
  
}

# Sunquest Processing -------------
preprocess_sun <- function(raw_sun) {
  
  # Preprocess Sunquest data --------------------------------
  # Remove any duplicates
  raw_sun <- unique(raw_sun)
  # Correct and format any columns that were not imported correctly; usually have a message saying "*failed to decode... *"  
  raw_sun[c("OrderDateTime",
            "CollectDateTime",
            "ReceiveDateTime",
            "ResultDateTime")] <-
    lapply(raw_sun[c("OrderDateTime",
                     "CollectDateTime",
                     "ReceiveDateTime",
                     "ResultDateTime")],
           function(x) ifelse(!is.na(x) & str_detect(x, "\\*.*\\*")  == TRUE,
                              str_replace(x, "\\*.*\\*", ""), x))
  
  raw_sun <- raw_sun %>%
    mutate(across(where(is.character), gsub,
                  pattern = "\\*.*\\*",
                  replacement = ""))
  
  raw_sun[c("OrderDateTime",
            "CollectDateTime",
            "ReceiveDateTime",
            "ResultDateTime")] <-
    lapply(raw_sun[c("OrderDateTime",
                     "CollectDateTime",
                     "ReceiveDateTime",
                     "ResultDateTime")],
           as.POSIXct, tz = "UTC", format = "%m/%d/%Y %H:%M:%S")
  
  # Sunquest lookup references
  # Crosswalk labs included and remove out of scope labs
  raw_sun <- left_join(raw_sun, cp_sun_test_codes,
                       by = c("TestCode" = "SUN_TEST_CODE"))
  
  # Determine if test is included based on crosswalk results
  raw_sun <- raw_sun %>%
    mutate(TestIncl = !is.na(TEST)) %>%
    filter(TestIncl)
  
  
  # Crosswalk unit type
  raw_sun <- left_join(raw_sun, cp_sun_setting,
                       by = c("LocType" = "LOC_TYPE"))
  
  # Crosswalk site name
  raw_sun <- left_join(raw_sun, cp_mshs_sites,
                       by = c("HospCode" = "DATA_SITE"))
  
  # # Sunquest data formatting-----------------------------
  # Preprocess Sunquest data and add any necessary columns
  raw_sun <- raw_sun %>%
    mutate(
      # Determine if unit is an ICU based on site mappings
      ICU = paste(Site, LocCode, LocName) %in% cp_sun_icu$SiteCodeName,
      # Create a column for resulted date
      RESULT_DATE = as.Date(ResultDateTime, format = "%m/%d/%Y"),
      # Create master setting column to identify ICU and IP Non-ICU units
      DETAILED_SETTING = ifelse(SETTING_ROLL_UP == "IP" & ICU, "ICU",
                                ifelse(SETTING_ROLL_UP == "IP" & !ICU,
                                       "IP Non-ICU", SETTING_ROLL_UP)),
      # Create dashboard setting column to roll up master settings based on
      # desired dashboard grouping(ie, group ED and ICU together)
      DASHBOARD_SETTING = ifelse(DETAILED_SETTING %in% c("ED", "ICU"),
                                 "ED & ICU", DETAILED_SETTING),
      #
      # Create column with adjusted priority based on operational assumption
      # that all ED and ICU labs are treated as stat
      ADJ_PRIORITY = ifelse(DETAILED_SETTING %in% c("ED", "ICU") |
                              SpecimenPriority %in% "S", "Stat", "Routine"),
      #
      # Calculate turnaround times
      COLLECT_TO_RECEIVE_TAT =
        round(as.numeric(ReceiveDateTime - CollectDateTime, units = "mins"),
              digits = 3),
      RECEIVE_TO_RESULT_TAT =
        round(as.numeric(ResultDateTime - ReceiveDateTime, units = "mins"),
              digits = 3),
      COLLECT_TO_RESULT_TAT =
        round(as.numeric(ResultDateTime - CollectDateTime, units = "mins"),
              digits = 3),
      #
      # Determine if order was an add on or original order based on time between
      # order and receive times
      ADD_ON_FINAL = ifelse(as.numeric(OrderDateTime - ReceiveDateTime,
                                       units = "mins") > 5, "AddOn", "Original"),
      #
      # Determine if collection time is missing
      MISSING_COLLECT = (CollectDateTime - OrderDateTime) %in% 0,
        # CollectDateTime %in% OrderDateTime,
      #
      # Determine TAT target based on test, priority, and patient setting
      # Create column concatenating test and division to determine TAT targets
      Concate1 = paste(TEST, DIVISION),
      #
      # Create dashboard priority column
      DASHBOARD_PRIORITY = ifelse(
        cp_tat_targets$PRIORITY[match(
          Concate1,
          paste(cp_tat_targets$TEST, cp_tat_targets$DIVISION))] == "All",
        "All", ADJ_PRIORITY),
      # Create column concatenating test, division, and priority to determine
      # TAT targets
      Concate2 = paste(TEST, DIVISION, DASHBOARD_PRIORITY),
      # Create column concatenating test, division, priority, and setting to
      # determine TAT targets
      Concate3 = paste(TEST, DIVISION, DASHBOARD_PRIORITY, DETAILED_SETTING),
      #
      # Determine Receive to Result TAT target using this logic:
      # 1. Try to match test, priority, and setting (applicable for labs with
      # different TAT targets based on patient setting and order priority)
      # 2. Try to match test and priority (applicable for labs with different
      # TAT targets based on order priority)
      # 3. Try to match test - this is for tests with (applicable for labs with
      # TAT targets that are independent of patient setting or priority)
      #
      # Determine Receive to Result TAT target based on above logic/scenarios
      RECEIVE_RESULT_TARGET =
        # Match on scenario 1
        ifelse(!is.na(match(Concate3, cp_tat_targets$Concate)),
               cp_tat_targets$RECEIVE_TO_RESULT_TARGET[
                 match(Concate3, cp_tat_targets$Concate)],
               # Match on scenario 2
               ifelse(!is.na(match(Concate2, cp_tat_targets$Concate)),
                      cp_tat_targets$RECEIVE_TO_RESULT_TARGET[
                        match(Concate2, cp_tat_targets$Concate)],
                      # Match on scenario 3
                      cp_tat_targets$RECEIVE_TO_RESULT_TARGET[
                        match(Concate1, cp_tat_targets$Concate)])),
      #
      # Determine Collect to Result TAT target based on above logic/scenarios
      COLLECT_RESULT_TARGET =
        # Match on scenario 1
        ifelse(!is.na(match(Concate3, cp_tat_targets$Concate)),
               cp_tat_targets$COLLECT_TO_RESULT_TARGET[
                 match(Concate3, cp_tat_targets$Concate)],
               # Match on scenario 2
               ifelse(!is.na(match(Concate2, cp_tat_targets$Concate)),
                      cp_tat_targets$COLLECT_TO_RESULT_TARGET[
                        match(Concate2, cp_tat_targets$Concate)],
                      # Match on scenario 3
                      cp_tat_targets$COLLECT_TO_RESULT_TARGET[
                        match(Concate1, cp_tat_targets$Concate)])),
      #
      # Determine if Receive to Result and Collect to Result TAT meet targets
      RECEIVE_RESULT_IN_TARGET = ifelse(is.na(RECEIVE_TO_RESULT_TAT), FALSE,
                                        RECEIVE_TO_RESULT_TAT <= RECEIVE_RESULT_TARGET),
      COLLECT_RESULT_IN_TARGET = ifelse(is.na(COLLECT_TO_RESULT_TAT), FALSE,
                                        COLLECT_TO_RESULT_TAT <= COLLECT_RESULT_TARGET),
      #
      # Create column with patient name, order ID, test, collect, receive, and
      # result date and determine if there is a duplicate; order time excluded
      Concate4 = paste(PtNumber, HISOrderNumber, TSTName,
                       CollectDateTime, ReceiveDateTime, ResultDateTime),
      DuplTest = duplicated(Concate4),
      #
      # Determine whether or not to include this particular lab in TAT analysis
      # Exclusion criteria:
      # 1. Add on orders
      # 2. Orders from "Other" settings
      # 3. Orders with collect or receive times after result time
      # 4. Orders with missing collect, receive, or result timestamps
      # 5. Orders with missing collection times are excluded from
      # collect-to-result and collect-to-receive turnaround time analyis
      RECEIVE_TIME_TAT_INCL = ifelse(ADD_ON_FINAL == "AddOn" |
                                       DETAILED_SETTING == "Other" |
                                       COLLECT_TO_RECEIVE_TAT < 0 |
                                       COLLECT_TO_RESULT_TAT < 0 |
                                       RECEIVE_TO_RESULT_TAT < 0 |
                                       is.na(COLLECT_TO_RESULT_TAT) |
                                       is.na(RECEIVE_TO_RESULT_TAT), FALSE, TRUE),
      COLLECT_TIME_TAT_INCL = ifelse(MISSING_COLLECT |
                                       ADD_ON_FINAL == "AddOn" |
                                       DETAILED_SETTING == "Other" |
                                       COLLECT_TO_RECEIVE_TAT < 0 |
                                       COLLECT_TO_RESULT_TAT < 0 |
                                       RECEIVE_TO_RESULT_TAT < 0 |
                                       is.na(COLLECT_TO_RESULT_TAT) |
                                       is.na(RECEIVE_TO_RESULT_TAT), FALSE, TRUE))
  
  # Remove duplicate tests
  raw_sun <- raw_sun %>%
    filter(!DuplTest)
  
  # Determine volume of labs associated with each date and identify correct date
  sun_resulted_dates_vol <- raw_sun %>%
    group_by(RESULT_DATE) %>%
    summarize(VolLabs = n()) %>%
    arrange(desc(VolLabs)) %>%
    ungroup()
  
  sun_correct_date <- sun_resulted_dates_vol$RESULT_DATE[1]
  
  raw_sun <- raw_sun %>%
    filter(RESULT_DATE %in% sun_correct_date)
  
  # Select columns
  sun_processed <- raw_sun %>%
    select(LocCode, LocName,
           HISOrderNumber, PhysName,
           PtNumber, SHIFT,
           TSTName, TEST, DIVISION, SpecimenPriority,
           Site, ICU, LocType,
           SETTING, SETTING_ROLL_UP,
           DETAILED_SETTING, DASHBOARD_SETTING,
           ADJ_PRIORITY, DASHBOARD_PRIORITY,
           OrderDateTime, CollectDateTime,
           ReceiveDateTime, ResultDateTime,
           RESULT_DATE,
           COLLECT_TO_RECEIVE_TAT, RECEIVE_TO_RESULT_TAT,
           COLLECT_TO_RESULT_TAT,
           ADD_ON_FINAL, MISSING_COLLECT,
           RECEIVE_RESULT_TARGET, COLLECT_RESULT_TARGET,
           RECEIVE_RESULT_IN_TARGET, COLLECT_RESULT_IN_TARGET,
           RECEIVE_TIME_TAT_INCL, COLLECT_TIME_TAT_INCL
    ) %>%
    rename(LOC_CODE = LocCode,
           LOC_NAME = LocName,
           ORDER_ID = HISOrderNumber,
           REQUEST_MD = PhysName,
           MSMRN = PtNumber,
           WORK_SHIFT = SHIFT,
           TEST_NAME = TSTName,
           ORDER_PRIORITY = SpecimenPriority,
           SITE = Site,
           LOC_TYPE = LocType,
           ORDER_TIME = OrderDateTime,
           COLLECT_TIME = CollectDateTime,
           RECEIVE_TIME = ReceiveDateTime,
           RESULT_TIME = ResultDateTime
    )
  
  return(sun_processed)
}

# Code for preprocessing, analyzing, and displaying Clinical Pathology KPI -----
# CP includes Chemistry, Hematology, and Microbiology RRL divisions

# Custom function to subset and summarize data for each lab division ----------
summarize_cp_tat <- function(x, lab_division) {
  if (is.null(x) || nrow(x) == 0) {
    lab_summary <- NULL
    lab_dashboard_cast <- NULL
  } else {
    # Subset data to be included based on lab division, whether or not TAT
    # meets inclusion criteria, and site location
    lab_summary <- x %>%
      # filter(DIVISION == lab_division) %>%
      
      
      
      group_by(TEST,
               SITE,
               DASHBOARD_PRIORITY,
               DASHBOARD_SETTING,
               RECEIVE_RESULT_TARGET,
               COLLECT_RESULT_TARGET) %>%
      summarize(ResultedVolume = sum(TOTAL_RESULTED),
                ResultedVol_ReceiveTAT = sum(RECEIVE_TIME_VOL_INCL),
                ResultedVol_CollectTAT = sum(COLLECT_TIME_VOL_INCL),
                ReceiveResultInTarget = sum(TOTAL_RECEIVE_RESULT_IN_TARGET),
                CollectResultInTarget = sum(TOTAL_COLLECT_RESULT_IN_TARGET),
                ReceiveResultPercent = round(
                  ReceiveResultInTarget / ResultedVol_ReceiveTAT, digits = 3),
                CollectResultPercent = round(
                  CollectResultInTarget / ResultedVol_CollectTAT, digits = 3),
                .groups = "keep") %>%
      rename(Test = TEST,
             Site = SITE,
             DashboardPriority = DASHBOARD_PRIORITY,
             DashboardSetting = DASHBOARD_SETTING,
             ReceiveResultTarget = RECEIVE_RESULT_TARGET,
             CollectResultTarget = COLLECT_RESULT_TARGET) %>%
      ungroup()
    #
    # Subset template data frame for this division
    lab_div_df_templ <- tat_dashboard_templ %>%
      mutate(Incl = NULL) %>%
      filter(Division == lab_division)
    #
    # Combine lab summary with template data frame for this division for
    # dashboard visualization
    lab_summary <- left_join(lab_div_df_templ, lab_summary,
                             by = c("Test" = "Test",
                                    "Site" = "Site",
                                    "DashboardPriority" = "DashboardPriority",
                                    "DashboardSetting" = "DashboardSetting"))
    #
    # Format relevant columns as factors, look up target TAT for labs with 0
    # resulted volume, add formatting for percent within targets
    lab_summary <- lab_summary %>%
      mutate(
        #
        # Set test, site, priority, and setting as factors
        Test = droplevels(factor(Test, levels = test_names, ordered = TRUE)),
        Site = droplevels(factor(Site, levels = all_sites, ordered = TRUE)),
        DashboardPriority = droplevels(factor(DashboardPriority,
                                              levels = dashboard_priority_order,
                                              ordered = TRUE)),
        DashboardSetting = droplevels(factor(DashboardSetting,
                                             levels = dashboard_pt_setting,
                                             ordered = TRUE)),
        #
        # Determine TAT target for sites with 0 resulted labs
        # Create column concatenating test and division to determine TAT targets
        Concate1 = paste(Test, Division),
        # Create column concatenating test, division, and priority to determine
        # TAT targets
        Concate2 = paste(Test, Division, DashboardPriority),
        # Create column concatenating test, division, priority, and setting to
        # determine TAT targets
        Concate3 = paste(Test, Division, DashboardPriority, DashboardSetting),
        # Determine Receive to Result TAT target using this logic:
        # 1. Try to match test, priority, and setting (applicable for labs with
        # different TAT targets based on patient setting and order priority)
        # 2. Try to match test and priority (applicable for labs with different
        # TAT targets based on order priority)
        # 3. Try to match test - this is for tests with (applicable for labs with
        # TAT targets that are independent of patient setting or priority)
        #
        # Determine Receive to Result TAT target based on above logic/scenarios
        ReceiveResultTarget =
          # If TAT target is known, keep TAT target
          ifelse(!is.na(ReceiveResultTarget), ReceiveResultTarget,
                 # Try to match on scenario 1
                 ifelse(
                   !is.na(match(Concate3, cp_tat_targets$Concate)),
                   cp_tat_targets$RECEIVE_TO_RESULT_TARGET[
                     match(Concate3, cp_tat_targets$Concate)],
                   # Try to match on scenario 2
                   ifelse(
                     !is.na(match(Concate2, cp_tat_targets$Concate)),
                     cp_tat_targets$RECEIVE_TO_RESULT_TARGET[
                       match(Concate2, cp_tat_targets$Concate)],
                     # Try to match on scenario 3
                     cp_tat_targets$RECEIVE_TO_RESULT_TARGET[
                       match(Concate1, cp_tat_targets$Concate)]))),
        #
        # Determine Collect to Result TAT target based on above logic/scenarios
        # Determine Receive to Result TAT target based on above logic/scenarios
        CollectResultTarget =
          # If TAT target is known, keep TAT target
          ifelse(!is.na(CollectResultTarget), CollectResultTarget,
                 # Try to match on scenario 1
                 ifelse(
                   !is.na(match(Concate3, cp_tat_targets$Concate)),
                   cp_tat_targets$COLLECT_TO_RESULT_TARGET[
                     match(Concate3, cp_tat_targets$Concate)],
                   # Try to match on scenario 2
                   ifelse(
                     !is.na(match(Concate2, cp_tat_targets$Concate)),
                     cp_tat_targets$COLLECT_TO_RESULT_TARGET[
                       match(Concate2, cp_tat_targets$Concate)],
                     # Try to match on scenario 3
                     cp_tat_targets$COLLECT_TO_RESULT_TARGET[
                       match(Concate1, cp_tat_targets$Concate)]))),
        #
        # Format target TAT for tables from numbers to "<=X min"
        ReceiveResultTarget = paste0("<=", ReceiveResultTarget, " min"),
        CollectResultTarget = paste0("<=", CollectResultTarget, " min"),
        #
        # Format percentage of labs in target
        ReceiveResultPercent = formattable::percent(ReceiveResultPercent, digits = 0),
        CollectResultPercent = formattable::percent(CollectResultPercent, digits = 0),
        #
        # Apply conditional color formatting to TAT percentages based on status
        # definitions for each lab division
        #
        # Chemistry & Hematology:
        # Green: >= 95%, Yellow: >= 80% & < 95%, Red: < 80%
        # Microbiology:
        # Green: 100%, Yellow: >= 90% & < 100%, Red: < 90%
        #
        ReceiveResultPercent = cell_spec(
          ReceiveResultPercent, "html",
          color = ifelse(is.na(ReceiveResultPercent), "lightgray",
                         ifelse(
                           (ReceiveResultPercent >= 0.95 &
                              lab_division %in% c("Chemistry", "Hematology")) |
                             (ReceiveResultPercent == 1.00 &
                                lab_division %in% c("Microbiology RRL")) |
                             (ReceiveResultPercent >= 0.90 &
                                lab_division %in% c("Infusion")),
                           "green",
                           ifelse(
                             (ReceiveResultPercent >= 0.8 &
                                lab_division %in%
                                c("Chemistry", "Hematology", "Infusion")) |
                               (ReceiveResultPercent >= 0.9 &
                                  lab_division %in% c("Microbiology RRL")),
                             "orange", "red")))),
        CollectResultPercent = cell_spec(
          CollectResultPercent, "html",
          color = ifelse(is.na(CollectResultPercent), "lightgray",
                         ifelse(
                           (CollectResultPercent >= 0.95 &
                              lab_division %in% c("Chemistry", "Hematology")) |
                             (CollectResultPercent == 1.00 &
                                lab_division %in% c("Microbiology RRL")) |
                             (CollectResultPercent >= 0.90 &
                                lab_division %in% c("Infusion")),
                           "green",
                           ifelse(
                             (CollectResultPercent >= 0.8 &
                                lab_division %in%
                                c("Chemistry", "Hematology", "Infusion")) |
                               (CollectResultPercent >= 0.9 &
                                  lab_division %in% c("Microbiology RRL")),
                             "orange", "red")))),
        #
        # Create a new column with test and priority to be used in tables later
        TestAndPriority = paste(Test, "-", DashboardPriority, "Labs"),
        #
        # Remove concatenated columns used for matching
        Concate1 = NULL,
        Concate2 = NULL,
        Concate3 = NULL) %>%
      arrange(Test, Site, DashboardPriority, DashboardSetting)
    #
    # Melt summarized data into a long dataframe
    lab_dashboard_melt <- melt(lab_summary,
                               id.var = c("Test",
                                          "Site",
                                          "DashboardPriority",
                                          "TestAndPriority",
                                          "DashboardSetting",
                                          "ReceiveResultTarget",
                                          "CollectResultTarget"),
                               measure.vars = c("ReceiveResultPercent",
                                                "CollectResultPercent"))
    #
    # Cast dataframe into wide format for use in tables later
    lab_dashboard_cast <- dcast(lab_dashboard_melt,
                                Test +
                                  DashboardPriority +
                                  TestAndPriority +
                                  DashboardSetting +
                                  ReceiveResultTarget +
                                  CollectResultTarget ~
                                  variable +
                                  Site,
                                value.var = "value")
    #
    # Rearrange columns based on desired dashboard aesthetics
    col_order <- c("Test", "DashboardPriority", "TestAndPriority",
                   "ReceiveResultTarget", "DashboardSetting",
                   "ReceiveResultPercent_MSH", "ReceiveResultPercent_MSQ",
                   "ReceiveResultPercent_MSBI", "ReceiveResultPercent_MSB",
                   "ReceiveResultPercent_MSW", "ReceiveResultPercent_MSM",
                   "ReceiveResultPercent_MSSN", "ReceiveResultPercent_RTC",
                   "CollectResultTarget", "DashboardSetting2",
                   "CollectResultPercent_MSH", "CollectResultPercent_MSQ",
                   "CollectResultPercent_MSBI", "CollectResultPercent_MSB",
                   "CollectResultPercent_MSW", "CollectResultPercent_MSM",
                   "CollectResultPercent_MSSN", "CollectResultPercent_RTC")
    
    lab_dashboard_cast <- lab_dashboard_cast %>%
      mutate(DashboardSetting2 = DashboardSetting) %>%
      select(intersect(col_order, names(.)))
    
    # Microbiology RRL: Manually remove C. diff ambulatory TAT since only volume
    # is monitored for this lab/setting combination
    if (lab_division == "Microbiology RRL") {
      lab_dashboard_cast <- lab_dashboard_cast %>%
        filter(!(Test == "C. diff" & DashboardSetting == "Amb"))
      row.names(lab_dashboard_cast) <- seq_len(nrow(lab_dashboard_cast))
    }
  }
  #
  # # Save outputs in a list
  lab_sub_output <- list(lab_summary,
                         lab_dashboard_cast)
  # #
  return(lab_sub_output)
  # return(lab_dashboard_cast)
}

# Custom function for creating kables for each CP lab division ----------------
kable_cp_tat <- function(x) {
  if (is.null(x) || nrow(x) == 0) {
    asis_output(
      paste("<i>",
            "No data available to determine turnaround times.",
            "</i>")
    )
  } else {
    #
    # Select columns 3 and on
    data <- x[, c(3:ncol(x))]
    
    if (any(str_detect(colnames(data), "_RTC"))) {
      kable_col_names <- c("Test & Priority",
                           "Target", "Setting",
                           "RTC",
                           "Target", "Setting",
                           "RTC")
    } else {
      kable_col_names <- c("Test & Priority",
                           "Target", "Setting",
                           "MSH", "MSQ", "MSBI", "MSB", "MSW", "MSM", "MSSN",
                           "Target", "Setting",
                           "MSH", "MSQ", "MSBI", "MSB", "MSW", "MSM", "MSSN")
    }
    
    num_col <- length(kable_col_names)
    #
    # Format kable
    kable(data, format = "html", escape = FALSE, align = "c",
          col.names = kable_col_names) %>%
      kable_styling(bootstrap_options = "hover", position = "center",
                    font_size = 11,
                    full_width = FALSE) %>%
      column_spec(column = c(1, (num_col - 1) / 2 + 1, num_col),
                  border_right = "thin solid lightgray") %>%
      add_header_above(c(" " = 1,
                         "Receive to Result Within Target" =
                           (num_col - 1) / 2,
                         "Collect to Result Within Target" =
                           (num_col - 1) / 2),
                       background = c("white", "#00AEEF", "#221f72"),
                       color = "white", line = FALSE, font_size = 13) %>%
      column_spec(column = 2:((num_col - 1) / 2 + 1), background = "#E6F8FF", color = "black") %>%
      column_spec(column = ((num_col - 1) / 2 + 2):num_col, background = "#EBEBF9", color = "black") %>%
      #column_spec(column = 2:17, background = "inherit", color = "inherit") %>%
      column_spec(column = 1, width_min = "125px") %>%
      column_spec(column = c(3, (num_col - 1) / 2 + 3), width_min = "100px") %>%
      row_spec(row = 0, font_size = 13) %>%
      collapse_rows(columns = c(1, 2, ((num_col - 1) / 2 + 2)))
  }
}

# Custom function for summarizing resulted lab volume from prior day(s) --------
summarize_cp_vol <- function(x, lab_division) {
  if (is.null(x) || nrow(x) == 0) {
    lab_div_vol_cast <- NULL
  } else {
    # Subset data to be included based on lab division and site location
    lab_div_vol_df <- x %>%
      # filter(Division == lab_division) %>%
      group_by(SITE,
               TEST,
               DASHBOARD_PRIORITY,
               DETAILED_SETTING) %>%
      summarize(ResultedLabs = sum(TOTAL_RESULTED),
                .groups = "keep") %>%
      rename(Site = SITE,
             Test = TEST,
             DashboardPriority = DASHBOARD_PRIORITY,
             DetailedSetting = DETAILED_SETTING)
    #
    # Subset volume dataframe template for this division
    lab_div_vol_templ <- vol_dashboard_templ %>%
      filter(Division == lab_division) %>%
      select(-Incl)
    #
    # Combine two dataframes to ensure all combinations are accounts for
    lab_div_vol_df <- left_join(lab_div_vol_templ, lab_div_vol_df,
                                by = c("Test" = "Test",
                                       "Site" = "Site",
                                       "DashboardPriority" = "DashboardPriority",
                                       "PtSetting" = "DetailedSetting"))
    #
    lab_div_vol_df <- lab_div_vol_df %>%
      mutate(
        # Set test, site, priority, and setting as factors
        Test = droplevels(factor(Test, levels = test_names, ordered = TRUE)),
        Site = droplevels(factor(Site, levels = all_sites, ordered = TRUE)),
        DashboardPriority = droplevels(factor(DashboardPriority,
                                              levels = dashboard_priority_order,
                                              ordered = TRUE)),
        PtSetting = droplevels(factor(PtSetting,
                                      levels = pt_setting_order,
                                      ordered = TRUE)),
        #
        # Replace NA with 0
        ResultedLabs = ifelse(is.na(ResultedLabs), 0, ResultedLabs),
        #
        # Create column with test name and priority
        TestAndPriority = paste(Test, "-", DashboardPriority, "Labs"))
    #
    # Cast dataframe
    lab_div_vol_cast <- dcast(lab_div_vol_df,
                              Test +
                                DashboardPriority +
                                TestAndPriority +
                                PtSetting ~
                                Site,
                              value.var = "ResultedLabs")
    # Remove test and priority columns
    lab_div_vol_cast <- lab_div_vol_cast[, c(3:ncol(lab_div_vol_cast))]
  }
  #
  return(lab_div_vol_cast)
}

# Custom function for creating a kable of lab volume from prior day(s)----------
kable_cp_vol <- function(x) {
  if (is.null(x) || nrow(x) == 0) {
    asis_output(
      paste("<i>",
            "No data available.",
            "</i>")
    )
  } else {
    if (any(str_detect(colnames(x), "RTC"))) {
      kable_cp_vol_cols <- c("Test & Priority", "Setting", "RTC")
    } else {
      kable_cp_vol_cols <- c("Test & Priority", "Setting",
                             "MSH", "MSQ", "MSBI", "MSB", "MSW", "MSM", "MSSN")
    }
    
    
    kable(x, format = "html", escape = FALSE, align = "c",
          col.names = kable_cp_vol_cols) %>%
      kable_styling(bootstrap_options = "hover",
                    position = "center",
                    font_size = 11,
                    full_width = FALSE) %>%
      column_spec(column = c(1, length(kable_cp_vol_cols)),
                  border_right = "thin solid lightgray") %>%
      add_header_above(c(" " = 1,
                         "Resulted Lab Volume" = (ncol(x) - 1)),
                       background = c("white", "#00AEEF"),
                       color = "white",
                       line = FALSE,
                       font_size = 13) %>%
      column_spec(column = 2:length(kable_cp_vol_cols), background = "#E6F8FF", color = "black") %>%
      # column_spec(column = 2:8,
      #             background = "inherit",
      #             color = "inherit") %>%
      # column_spec(column = 1,
      #             width_min = "125px",
      #             include_thead = TRUE) %>%
      # column_spec(column = c(3, 11),
      #             width_min = "100px",
      #             include_thead = TRUE) %>%
      row_spec(row = 0, font_size = 13) %>%
      collapse_rows(columns = c(1, 2))
  }
}

# Custom function for creating a kable of labs with missing collections --------
kable_missing_collections <- function(x) {
  if (is.null(x) || nrow(x) == 0) {
    asis_output(
      paste("<i>",
            "No data available to determine missing collections.",
            "</i>")
    )
  } else {
    # Filter data for city sites and summarize
    missing_collect <- x %>%
      group_by(SITE) %>%
      summarize(ResultedVolume = sum(TOTAL_RESULTED),
                MissingCollection = sum(TOTAL_MISSING_COLLECTIONS, na.rm = TRUE),
                Percent = formattable::percent(MissingCollection / ResultedVolume,
                                               digits = 0),
                .groups = "keep") %>%
      ungroup() %>%
      rename(Site = SITE) %>%
      mutate(
        # Apply conditional formatting based on percentage of labs with missing
        # collections
        Percent = cell_spec(
          Percent, "html",
          color = ifelse(is.na(Percent), "grey",
                         ifelse(Percent <= 0.05, "green",
                                ifelse(Percent <= 0.15, "orange", "red")))),
        # Format site as factors
        Site = factor(Site, levels = all_sites, ordered = TRUE))
    #
    # Create template to ensure all sites are included
    missing_collect <- left_join(data.frame("Site" = factor(all_sites,
                                                            levels = all_sites,
                                                            ordered = TRUE)),
                                 missing_collect,
                                 by = c("Site" = "Site"))
    #
    # Cast missing collections into table format
    missing_collect_table <- dcast(missing_collect,
                                   "Percentage of Specimens" ~ Site,
                                   value.var = "Percent")
    # Create kable with summarized data
    missing_collect_table %>%
      kable(format = "html", escape = FALSE, align = "c",
            col.names = c("Site",
                          "MSH", "MSQ", "MSBI", "MSB", "MSW",
                          "MSM", "MSSN", "RTC")) %>%
      kable_styling(
        bootstrap = "hover",
        position = "center",
        font_size = 11,
        full_width = FALSE) %>%
      add_header_above(
        c(" " = 1,
          "Percentage of Labs Missing Collect Times" =
            ncol(missing_collect_table) - 1),
        background = c("white", "#00AEEF"),
        color = "white",
        line = FALSE,
        font_size = 13) %>%
      column_spec(column = c(1, ncol(missing_collect_table)),
                  border_right = "thin solid lightgray") %>%
      column_spec(column = c(2:ncol(missing_collect_table)),
                  background = "#E6F8FF",
                  color = "black") %>%
      # column_spec(column = c(2:ncol(missing_collect_table)),
      #             background = "inherit",
      #             color = "inherit",
      #             width_max = 0.15) %>%
      row_spec(row = 0, font_size = 13)
  }
}

# Custom function for creating a kable of add-on order volume
kable_add_on_volume <- function(x) {
  if (is.null(x) || nrow(x) == 0) {
    asis_output(
      paste("<i>",
            "No data available to determine add on order volume.",
            "</i>")
    )
  } else {
    # Filter data for city sites and summarize
    add_on_volume <- x %>%
      group_by(TEST, SITE) %>%
      summarize(AddOnVolume = sum(TOTAL_ADD_ON_ORDER, na.rm = TRUE),
                .groups = "keep") %>%
      ungroup() %>%
      rename(Test = TEST,
             Site = SITE)
    
    test_site_templ <- tat_dashboard_templ %>%
      select(Test, Site) %>%
      distinct()
    
    add_on_volume <- left_join(test_site_templ, add_on_volume,
                               by = c("Site" = "Site",
                                      "Test" = "Test"))
    
    add_on_volume <- add_on_volume %>%
      mutate(
        # Set test and site as factors
        Test = droplevels(factor(Test, levels = test_names, ordered = TRUE)),
        Site = factor(Site, levels = all_sites, ordered = TRUE),
        AddOnVolume = ifelse(is.na(AddOnVolume), 0, AddOnVolume))
    
    add_on_table <- dcast(add_on_volume, Test ~ Site, value.var = "AddOnVolume")
    
    # Create kable of add on orders
    add_on_table %>%
      kable(format = "html", escape = FALSE, align = "c",
            col.names = c("Test",
                          "MSH", "MSQ", "MSBI", "MSB", "MSW",
                          "MSM", "MSSN", "RTC"),
            color = "gray") %>%
      kable_styling(
        bootstrap = "hover",
        position = "center",
        font_size = 11,
        full_width = FALSE) %>%
      add_header_above(
        c(" " = 1,
          "Volume of Add On Labs" = ncol(add_on_table) - 1),
        background = c("white", "#00AEEF"),
        color = "white",
        line = FALSE,
        font_size = 13) %>%
      column_spec(
        column = c(1, ncol(add_on_table)),
        border_right = "thin solid lightgray") %>%
      column_spec(
        column = c(2:ncol(add_on_table)),
        background = "#E6F8FF", color = "black") %>%
      # column_spec(column = c(2:ncol(add_on_table)),
      #             background = "inherit",
      #             color = "inherit") %>%
      row_spec(row = 0, font_size = 13)
  }
}

```

```{r Preprocess CP data, warning = FALSE, message = FALSE, echo = FALSE, eval = cp_eval}
# Code for calling custom functions to preprocess and summarize CP data 
# source(here::here("Automated Daily Dashboard/CP_Preprocessing_Analysis.R"))

# Code for preprocessing CP data prior to receipt of Ops &
# Quality Indicators Form

# Preprocess raw data using pre-defined custom functions ------------
if (is.null(scc_data_raw) | nrow(scc_data_raw) == 0){
  scc_processed <- NULL
} else {
  scc_processed <- preprocess_scc(raw_scc = scc_data_raw)
}

if (is.null(sq_data_raw) | nrow(sq_data_raw) == 0){
  sun_processed <- NULL
} else {
  sun_processed <- preprocess_sun(raw_sun = sq_data_raw)
}

cp_processed <- rbind(scc_processed, sun_processed)


#
# Summarize  data by site, date, test, setting, priority, etc.-------
if (is.null(cp_processed)) {
  cp_summary <- NULL
} else {
  cp_summary <- cp_processed %>%
    group_by(SITE,
             RESULT_DATE,
             TEST,
             DIVISION,
             SETTING_ROLL_UP,
             DETAILED_SETTING,
             DASHBOARD_SETTING,
             ADJ_PRIORITY,
             DASHBOARD_PRIORITY,
             RECEIVE_RESULT_TARGET,
             COLLECT_RESULT_TARGET) %>%
    summarize(
      # Calculate total number of labs resulted
      TOTAL_RESULTED = n(),
      # Calculate number of labs with valid receive times and collection times
      RECEIVE_TIME_VOL_INCL = sum(RECEIVE_TIME_TAT_INCL, na.rm = TRUE),
      COLLECT_TIME_VOL_INCL = sum(COLLECT_TIME_TAT_INCL, na.rm = TRUE),
      # Calculate number of labs within target TAT
      TOTAL_RECEIVE_RESULT_IN_TARGET =
        sum(RECEIVE_RESULT_IN_TARGET[RECEIVE_TIME_TAT_INCL], na.rm = TRUE),
      TOTAL_COLLECT_RESULT_IN_TARGET =
        sum(COLLECT_RESULT_IN_TARGET[COLLECT_TIME_TAT_INCL], na.rm = TRUE),
      TOTAL_ADD_ON_ORDER = sum(ADD_ON_FINAL %in% c("AddOn"), na.rm = TRUE),
      TOTAL_MISSING_COLLECTIONS = sum(MISSING_COLLECT),
      .groups = "keep") %>%
    arrange(SITE, RESULT_DATE) %>%
    ungroup()
}
```

```{r Subset and format CP data for each lab division for daily dashboard, warning = FALSE, message = FALSE, echo = FALSE, eval = cp_eval}
# Custom function to subset and summarize data for each lab division ----------
# Chemistry
chem_tat_output <- summarize_cp_tat(x = cp_summary,
                                    lab_division = "Chemistry")

# Hematology
hematology_tat_output <- summarize_cp_tat(x = cp_summary,
                                          lab_division = "Hematology")

# Microbiology RRL
micro_tat_output <- summarize_cp_tat(x = cp_summary,
                                     lab_division = "Microbiology RRL")
    
micro_summary <- micro_tat_output[[1]]
micro_dashboard_cast <- micro_tat_output[[2]]

# # Microbiology RRL: Manually remove C. diff ambulatory TAT since only volume
# # is monitored for this lab/setting combination
# micro_dashboard_cast <- micro_dashboard_cast %>%
#   filter(!(Test == "C. diff" & DashboardSetting == "Amb"))
# row.names(micro_dashboard_cast) <- seq_len(nrow(micro_dashboard_cast))

# Infusion
infusion_tat_output <- summarize_cp_tat(x = cp_summary,
                                        lab_division = "Infusion")

```

```{r Import AP custom functions, warning = FALSE, message = FALSE, echo = FALSE}
# #######
# # Source Code for preprocessing, analyzing, and displaying Anatomic Pathology
# # Anatomic Pathology (AP) includes Cytology and Surgical Pathology divisions
# #######
# #import source code
# source(here::here("Automated Daily Dashboard/AP_functions_data_preprocessing.R"))
# source(here::here("Automated Daily Dashboard/AP_processing_functions_for_output.R"))
# source(here::here("Automated Daily Dashboard/AP_kable_outputs.R"))

# Copied from Automated Daily Dashboard/AP_functions_data_preprocessing.R
site_mapping <- function(data){
  
  
  data <- data %>%
    mutate(Facility = case_when(Facility == "KH" ~ "MSB",
                                Facility == "R" ~ "MSW",
                                Facility == "STL" ~ "MSM",
                                Facility == "BIMC" ~ "MSBI",
                                Facility == "SNCH" ~ "MSSN",
                                Facility == "MSS" ~ "MSH",
                                Facility == "SL" ~ "MSM",
                                #Facility == "PACC" ~ "MS USQ",
                                TRUE ~ Facility ))
  
  
  
}


format_dates <- function(data){
  
  data[c("Case_created_date",
                 "Collection_Date",
                 "Received_Date",
                 "signed_out_date")] <-
    lapply(data[c("Case_created_date",
                          "Collection_Date",
                          "Received_Date",
                          "signed_out_date")],
           as.POSIXct, tz = "", format = "%m/%d/%y %I:%M %p" ,origin = "1970-01-01")
  
  data
  
}


# Function to preprate prepare cytology data for pre-processing by crosswalking
# Epic and PowerPath data
# combines orginal cyto_prep, pre_processing_pp in Daily_Run_AP_Custom_Functions

cyto_prep <- function(epic_data, pp_data,resulted_date) {
  if (is.null(epic_data) || is.null(pp_data) || 
      nrow(epic_data) == 0 || nrow(pp_data) == 0) {
    summarized_table <- NULL
    return(summarized_table)
  } else {
    
    # Preprocess Epic data
    # Select specimens that were finalized in Epic based on Lab Status
    epic_data_finalized_results <- epic_data %>%
      filter(LAB_STATUS %in% c("Final result", "Edited Result - FINAL"))
    
    # Create dataframe of unique specimen ID for crosswalking with PowerPath data
    # cross-walking with PowerPath data
    epic_data_specimens <- epic_data_finalized_results %>%
      distinct(SPECIMEN_ID)
    
    # Update names for MSH and MSM
    # pp_data <- pp_data %>%
    #   mutate(Facility = case_when(Facility == "MSS" ~ "MSH",
    #                               Facility == "STL"~ "SL",
    #                               TRUE ~ Facility))
    
    # Subset PowerPath data to keep Cyto Gyn and Cyto NonGyn and primary
    # specimens only
    cyto_data <- pp_data %>%
      filter(spec_sort_order == "A" &
               spec_group %in% c("CYTO NONGYN", "CYTO GYN"))
    
    cyto_data <- merge(x = cyto_data, y = epic_data_specimens,
                        by.x = "Case_no",
                        by.y = "SPECIMEN_ID")
    
    
    
    # Crosswalk Rev_ctr and patient setting for PowerPath data
    cyto_data <- merge(x = cyto_data, y = patient_setting, all.x = TRUE)
    
    # update sites/facilities
    cyto_data <- site_mapping(cyto_data)
    
    # Update MSB patient setting based on patient type column
    cyto_data <- cyto_data %>%
      mutate(Patient.Setting = case_when(Rev_ctr == "MSBK" & (patient_type == "A" | patient_type == "O") ~ "Amb",
                                         Rev_ctr == "MSBK" &  patient_type == "IN" ~ "IP",
                                         TRUE ~ Patient.Setting))
    
    # Crosswalk TAT targets based on spec_group and patient setting
    cyto_data <- merge(x = cyto_data, y = tat_targets_ap,
                          all.x = TRUE, by = c("spec_group", "Patient.Setting"))
    

    #Change all Dates into POSIXct format to start the calculations
    cyto_data <- format_dates(cyto_data)
    
    # Add columns for turnaround time calculations:
    # Collection to signed out (in calendar days) and
    # received to signed out (in business days)
    cyto_data <- cyto_data %>%
      mutate(
        # Add column for collected to signed out turnaround time in calendar days
        Collection_to_signed_out =
          as.numeric(difftime(signed_out_date,Collection_Date,units="days")),
        # Add column for received to signed out turnaround time in business days
        Received_to_signed_out = bizdays(Received_Date, signed_out_date),
        # Prepare data for accessioned volume analysis
        # First find the date of the last weekday and add 1 for report date
        report_date_only = as.Date(signed_out_date) + 1,
        #  Find the accessioned date and use this for determining accessioned volume
        acc_date_only = as.Date(Received_Date)) %>%
      # Filter out anything with a sign out date other than result date of interest
      filter(date(signed_out_date) %in% resulted_date)
    

    #summarize the data to be used for analysis and to be stored as historical
    #repo
    summarized_table <- cyto_data %>%
      group_by(Spec_code,
               spec_group,
               Facility,
               Patient.Setting,
               Rev_ctr,
               as.Date(signed_out_date),
               weekdays(as.Date(signed_out_date)),
               Received.to.signed.out.target..Days.,
               Collected.to.signed.out.target..Days.,
               acc_date_only,
               weekdays(acc_date_only),
               report_date_only,
               weekdays(report_date_only)) %>%
      summarise(no_cases_signed = n(),
                lab_metric_tat_avg = round(mean(Received_to_signed_out,
                                                na.rm = TRUE), 0),
                lab_metric_tat_med = round(median(Received_to_signed_out,
                                                  na.rm = TRUE), 0),
                lab_metric_tat_sd = round(sd(Received_to_signed_out, na.rm = TRUE), 1),
                lab_metric_within_target = as.numeric(format(
                  round(
                    sum(Received_to_signed_out <= Received.to.signed.out.target..Days.,
                        na.rm = TRUE) / sum(
                          Received_to_signed_out >= 0, na.rm = TRUE), 2))),
                patient_metric_tat_avg = as.numeric(format(
                  ceiling(mean(Collection_to_signed_out, na.rm = TRUE)))),
                patient_metric_tat_med = round(median(Collection_to_signed_out,
                                                      na.rm = TRUE), 0),
                patient_metric_tat_sd = round(sd(Collection_to_signed_out,
                                                 na.rm = TRUE), 1),
                cyto_acc_vol = as.numeric(sum((report_date_only - 1) == acc_date_only,
                                              na.rm = TRUE)))
    
    
    
    colnames(summarized_table) <-
      c("Spec_code", "Spec_group", "Facility", "Patient_setting", "Rev_ctr",
        "Signed_out_date_only", "Signed_out_day_only", "Lab_metric_target",
        "Patient_metric_target", "acc_date_only", "acc_day_only",
        "report_date_only", "report_day_only", "No_cases_signed_out",
        "Lab_metric_avg", "Lab_metric_med", "Lab_metric_std",
        "Lab_metric_within_target", "Patient_metric_avg", "Patient_metric_med",
        "Patient_metric_std", "cyto_acc_vol")
    
    summarized_table <- summarized_table %>%
      rename(SPECIMEN_CODE = Spec_code,
             SPECIMEN_GROUP = Spec_group,
             SITE = Facility,
             PATIENT_SETTING = Patient_setting,
             REVENUE_CENTER = Rev_ctr,
             SIGNED_OUT_DATE = Signed_out_date_only,
             SIGNED_OUT_DAY = Signed_out_day_only,
             REC_TO_SIGNED_OUT_TARGET = Lab_metric_target,
             COL_TO_SIGNED_OUT_TARGET = Patient_metric_target,
             ACCESSION_DATE = acc_date_only,
             ACCESION_DAY = acc_day_only,
             REPORT_DATE = report_date_only,
             REPORT_DAY = report_day_only,
             NO_CASES_SIGNED_OUT = No_cases_signed_out,
             REC_TO_SIGNED_OUT_AVG = Lab_metric_avg,
             REC_TO_SIGNED_OUT_MEDIAN = Lab_metric_med,
             REC_TO_SIGNED_OUT_STDDEV = Lab_metric_std,
             REC_TO_SIGNED_OUT_WITHIN_TARGET = Lab_metric_within_target,
             COL_TO_SIGNED_OUT_AVG = Patient_metric_avg,
             COL_TO_SIGNED_OUT_MEDIAN = Patient_metric_med,
             COL_TO_SIGNED_OUT_STDDEV = Patient_metric_std,
             CYTO_ACCESSION_VOLUME = cyto_acc_vol) #%>%
      #mutate(TAB = "CYTOLOGY") 
    # # Filter out any specimens signed out on other dates
    # summarize_table <- summarized_table %>%
    #   filter(Signed_out_date_only %in% dates)
    return(summarized_table)
  }
}




#create a function to prepare pathology data for pre-processing
# combines orginal patho_prep, pre_processing_pp in Daily_Run_AP_Custom_Functions

patho_prep <- function(raw_data,resulted_date) {
  if (is.null(raw_data) || nrow(raw_data) == 0) {
    summarized_table <- NULL
    return(summarized_table)
  } else {
    
    # resulted_date <- as.Date(max(raw_data$signed_out_date), format("%m/%d/%y"))
    #------------Extract the All Breast and GI specs Data Only--------------#
    # Merge the inclusion/exclusion criteria with PowerPath data to determine
    # which GI cases to include in the analysis
    
    pp_data_gi_codes <- merge(x = raw_data, y = gi_codes, all.x = TRUE)
    
    pp_data_gi_codes <- pp_data_gi_codes %>%
      mutate(spec_group = case_when(spec_group == "BREAST" ~ "Breast", 
                                    TRUE ~ spec_group))
    
    pp_data_gi_codes <- site_mapping(pp_data_gi_codes)
    
    
    #Create dataframe with cases that should be excluded based on GI code
    exclude_gi_codes <- pp_data_gi_codes %>%
      filter(spec_group %in% c("GI") &
               !(GI_Code_InclExcl %in% c("Include")))
    
    # Create vector of case numbers to exclude
    exclude_case_numbers <- unique(exclude_gi_codes$Case_no)
    
    # Subset surgical pathology data based on inclusion criteria
    sp_data <- pp_data_gi_codes %>%
      filter(# Select primary specimens only
        spec_sort_order == "A" &
          # Select GI specimens with codes that are included and any breast specimens
          ((spec_group == "GI" & !(Case_no %in% exclude_case_numbers)) |
             (spec_group == "Breast" )) &
          # Exclude NYEE
          Facility != "NYEE")
    # Crosswalk Rev_ctr and patient setting for PowerPath data
    sp_data_patient_setting <- merge(x = sp_data, y = patient_setting, all.x = TRUE)
    
    
    # Update MSB patient setting based on patient type column
    sp_data_patient_setting <- sp_data_patient_setting %>%
      mutate(Patient.Setting = case_when(Rev_ctr == "MSBK" & (patient_type == "A" | patient_type == "O") ~ "Amb",
                                         Rev_ctr == "MSBK" &  patient_type == "IN" ~ "IP",
                                         TRUE ~ Patient.Setting))
    
    # Crosswalk TAT targets based on spec_group and patient setting
    patient_setting_with_targets <- merge(x = sp_data_patient_setting, y = tat_targets_ap,
                                          all.x = TRUE, by = c("spec_group", "Patient.Setting"))
    
    #Change all Dates into POSIXct format to start the calculations
    patient_setting_with_targets <- format_dates(patient_setting_with_targets)
    
    
    # Add columns for turnaround time calculations:
    # Collection to signed out (in calendar days) and
    # received to signed out (in business days)
    patient_setting_with_targets <- patient_setting_with_targets %>%
      mutate(
        # Add column for collected to signed out turnaround time in calendar days
        Collection_to_signed_out =
          as.numeric(difftime(signed_out_date,Collection_Date,units="days")),
        # Add column for received to signed out turnaround time in business days
        Received_to_signed_out = bizdays(Received_Date, signed_out_date),
        # Prepare data for accessioned volume analysis
        # First find the date of the last weekday and add 1 for report date
        report_date_only = as.Date(signed_out_date) + 1,
        #  Find the accessioned date and use this for determining accessioned volume
        acc_date_only = as.Date(Received_Date)) %>%
      # Filter out anything with a sign out date other than result date of interest
      filter(date(signed_out_date) %in% resulted_date)
    

    #summarize the data to be used for analysis and to be stored as historical
    #repo
    summarized_table <- patient_setting_with_targets %>%
      group_by(Spec_code,
               spec_group,
               Facility,
               Patient.Setting,
               Rev_ctr,
               as.Date(signed_out_date),
               weekdays(as.Date(signed_out_date)),
               Received.to.signed.out.target..Days.,
               Collected.to.signed.out.target..Days.,
               acc_date_only,
               weekdays(acc_date_only),
               report_date_only,
               weekdays(report_date_only)) %>%
      summarise(no_cases_signed = n(),
                lab_metric_tat_avg = round(mean(Received_to_signed_out,
                                                na.rm = TRUE), 0),
                lab_metric_tat_med = round(median(Received_to_signed_out,
                                                  na.rm = TRUE), 0),
                lab_metric_tat_sd = round(sd(Received_to_signed_out, na.rm = TRUE), 1),
                lab_metric_within_target = as.numeric(format(
                  round(
                    sum(Received_to_signed_out <= Received.to.signed.out.target..Days.,
                        na.rm = TRUE) / sum(
                          Received_to_signed_out >= 0, na.rm = TRUE), 2))),
                patient_metric_tat_avg = as.numeric(format(
                  ceiling(mean(Collection_to_signed_out, na.rm = TRUE)))),
                patient_metric_tat_med = round(median(Collection_to_signed_out,
                                                      na.rm = TRUE), 0),
                patient_metric_tat_sd = round(sd(Collection_to_signed_out,
                                                 na.rm = TRUE), 1),
                cyto_acc_vol = as.numeric(sum((report_date_only - 1) == acc_date_only,
                                              na.rm = TRUE)))
    
    
    
    colnames(summarized_table) <-
      c("Spec_code", "Spec_group", "Facility", "Patient_setting", "Rev_ctr",
        "Signed_out_date_only", "Signed_out_day_only", "Lab_metric_target",
        "Patient_metric_target", "acc_date_only", "acc_day_only",
        "report_date_only", "report_day_only", "No_cases_signed_out",
        "Lab_metric_avg", "Lab_metric_med", "Lab_metric_std",
        "Lab_metric_within_target", "Patient_metric_avg", "Patient_metric_med",
        "Patient_metric_std", "cyto_acc_vol")
    
    summarized_table <- summarized_table %>%
      rename(SPECIMEN_CODE = Spec_code,
             SPECIMEN_GROUP = Spec_group,
             SITE = Facility,
             PATIENT_SETTING = Patient_setting,
             REVENUE_CENTER = Rev_ctr,
             SIGNED_OUT_DATE = Signed_out_date_only,
             SIGNED_OUT_DAY = Signed_out_day_only,
             REC_TO_SIGNED_OUT_TARGET = Lab_metric_target,
             COL_TO_SIGNED_OUT_TARGET = Patient_metric_target,
             ACCESSION_DATE = acc_date_only,
             ACCESION_DAY = acc_day_only,
             REPORT_DATE = report_date_only,
             REPORT_DAY = report_day_only,
             NO_CASES_SIGNED_OUT = No_cases_signed_out,
             REC_TO_SIGNED_OUT_AVG = Lab_metric_avg,
             REC_TO_SIGNED_OUT_MEDIAN = Lab_metric_med,
             REC_TO_SIGNED_OUT_STDDEV = Lab_metric_std,
             REC_TO_SIGNED_OUT_WITHIN_TARGET = Lab_metric_within_target,
             COL_TO_SIGNED_OUT_AVG = Patient_metric_avg,
             COL_TO_SIGNED_OUT_MEDIAN = Patient_metric_med,
             COL_TO_SIGNED_OUT_STDDEV = Patient_metric_std,
             CYTO_ACCESSION_VOLUME = cyto_acc_vol) #%>%
      #mutate(TAB = "SURGICAL PATHOLOGY")
    
    # # Filter out any specimens signed out on other dates
    # summarize_table <- summarized_table %>%
    #   filter(Signed_out_date_only %in% dates)
    return(summarized_table)
  }
  
}



##### This function helps in preprocessing the raw backlog data.
# Will be used in first run
pre_processing_backlog <- function(cyto_backlog_raw,resulted_date) {
  #cyto backlog Calculation
  if (is.null(cyto_backlog_raw) || nrow(cyto_backlog_raw) == 0) {
    summarized_table <- NULL
  } else {
    #vlookup the Rev_Center and its corresponding patient setting for the
    #PowerPath Data
    
    cyto_backlog_ps <- merge(x = cyto_backlog_raw, y = patient_setting,
                             all.x = TRUE)
    
    #vlookup targets based on spec_group and patient setting
    cyto_backlog_ps_target <- merge(x = cyto_backlog_ps, y = tat_targets_ap,
                                    all.x = TRUE,
                                    by = c("spec_group", "Patient.Setting"))
    
    cyto_backlog_ps_target <- site_mapping(cyto_backlog_ps_target)
    
    #Keep the cyto gyn and cyto non-gyn
    cyto_backlog <- cyto_backlog_ps_target %>%
      filter(spec_group %in% c("CYTO NONGYN","CYTO GYN"))
    
    #Change all Dates into POSIXct format to start the calculations
    cyto_backlog <- format_dates(cyto_backlog)
    
    #Backlog Calculations: Date now - case created date
    #without weekends and holidays, subtract one so we don't include today's date

    cyto_backlog <- cyto_backlog %>%
      mutate(backlog = bizdays(cyto_backlog$Case_created_date, today) - 1,
             acc_date_only = as.Date(cyto_backlog$Received_Date),
             Report_Date = resulted_date + 1 )
    
    #summarize the data to be used for analysis and to be stored as historical
    #repo
    summarized_table <- cyto_backlog %>%
      group_by(Spec_code,
               spec_group,
               Facility,
               Patient.Setting,
               Rev_ctr,
               acc_date_only,
               weekdays(acc_date_only),
               Report_Date) %>%
      summarise(cyto_backlog = format(
        round(
          sum(
            backlog > Received.to.signed.out.target..Days.,
            na.rm = TRUE), 0)),
        
        percentile_25th =
          format(
            ceiling(
              quantile(
                backlog[backlog > Received.to.signed.out.target..Days.],
                prob = 0.25, na.rm = TRUE))),
        
        percentile_50th =
          format(
            ceiling(
              quantile(
                backlog[backlog > Received.to.signed.out.target..Days.],
                prob = 0.5, na.rm = TRUE))),
        
        percentile_75th =
          format(
            ceiling(
              quantile(
                backlog[backlog > Received.to.signed.out.target..Days.],
                prob = 0.75, na.rm = TRUE))),
        
        maximum = format(
          ceiling(
            max(
              backlog[backlog > Received.to.signed.out.target..Days.],
              na.rm = TRUE))),
        
        average = format(
          ceiling(
            mean(
              backlog[backlog > Received.to.signed.out.target..Days.],
              na.rm = TRUE))),
        
        minimum = format(
          ceiling(
            min(
              backlog[backlog > Received.to.signed.out.target..Days.],
              na.rm = TRUE))),
        
        cyto_acc_vol = as.numeric(sum(resulted_date == acc_date_only,
                                      na.rm = TRUE))) %>%
      mutate(maximum = if_else(maximum %in% c("-Inf" ,"Inf") ,"0",
                               maximum),
             maximum = as.numeric(maximum))
    
    #standardize the name for the current summary to match the historical repo
    colnames(summarized_table) <-
      c("Spec_code", "Spec_group", "Facility", "Patient_setting", "Rev_ctr",
        "acc_date_only", "acc_day_only", "Report_Date", "cyto_backlog",
        "percentile_25th", "percentile_50th", "percentile_75th","minimum","average","maximum", "cyto_acc_vol")
  }
  return(summarized_table)
  
}

# Copied from Automated Daily Dashboard/AP_processing_functions_for_output.R
# For 24 Hour Volume Look Back Surgical Pathology/Cytology Tab ----
get_stratified_volume <- function(summarized_data, division){
  
  vol_cases_signed_strat <- summarized_data %>%
    group_by(SPECIMEN_GROUP,
             SITE,
             PATIENT_SETTING) %>%
    summarise(no_cases_signed =
                sum(NO_CASES_SIGNED_OUT,
                    na.rm = TRUE))%>%
    pivot_longer(cols = c(no_cases_signed),
                 names_to  = "METRIC",
                 values_to = "VALUE")
  
  if(division == "SURGICAL PATHOLOGY"){
    volume_24_template <- table_ap_template_surgical_pathology_24 
  }else{
    volume_24_template <- table_ap_template_cytology_24
  }
  
  vol_cases_signed_strat <- left_join(volume_24_template,vol_cases_signed_strat) %>%
    mutate(VALUE = cell_spec(VALUE, "html",
                             color = ifelse(is.na(VALUE), 
                                            "lightgray",
                                            "black"))) %>%
    pivot_wider(id_cols = c(SPECIMEN_GROUP,PATIENT_SETTING),
                names_from = c(SITE),
                values_from = VALUE)
  
  return(vol_cases_signed_strat)
}



# For Efficiency Indicators Cytology Data ---- 
get_efficiency_indicators_cytology <- function(summarized_data){
  
  # Volume
  vol_cases_signed <- summarized_data %>%
    group_by(SPECIMEN_GROUP,
             PATIENT_SETTING) %>%
    summarise(no_cases_signed = sum(NO_CASES_SIGNED_OUT,
                                    na.rm = TRUE))
  
  # Received to Signed
  received_to_signed <- summarized_data %>%
    group_by(SPECIMEN_GROUP,
             PATIENT_SETTING) %>%
    summarise(received_to_signed_out_within_target =
                format(
                  round(
                    sum(
                      (REC_TO_SIGNED_OUT_WITHIN_TARGET *
                         NO_CASES_SIGNED_OUT) /
                        sum(NO_CASES_SIGNED_OUT),
                      na.rm = TRUE), 2)))
  
  #Calculate average collection to signed out
  efficiency_indicator_cytology_tab <- summarized_data %>%
    group_by(SPECIMEN_GROUP,
             SITE,
             PATIENT_SETTING) %>%
    summarise(avg_collection_to_signed_out =
                format(
                  round(
                    sum(
                      (COL_TO_SIGNED_OUT_AVG *
                         NO_CASES_SIGNED_OUT) /
                        sum(NO_CASES_SIGNED_OUT),
                      na.rm = TRUE), 0))) %>%
    pivot_longer(cols = c(avg_collection_to_signed_out),
                 names_to  = "METRIC",
                 values_to = "VALUE") %>%
    mutate(VALUE = as.numeric(VALUE))
  
  
  
  efficiency_indicator_cytology_tab <- left_join(table_ap_template_cytology,
                                                 efficiency_indicator_cytology_tab) %>%
    mutate(VALUE = cell_spec(VALUE, "html",
                             color = ifelse(is.na(VALUE), 
                                            "lightgray",
                                            "black"))) %>%
    pivot_wider(id_cols = c(SPECIMEN_GROUP,PATIENT_SETTING),
                names_from = c(METRIC,SITE),
                values_from = VALUE)
  
  
  efficiency_indicator_cytology_tab <- left_join(efficiency_indicator_cytology_tab,
                                                 tat_targets_ap %>%
                                                   select(1,2,3),
                                                 by = c("SPECIMEN_GROUP" = "spec_group",
                                                        "PATIENT_SETTING" = "Patient.Setting"))
  # set the order
  efficiency_indicator_cytology_tab <- left_join(left_join(efficiency_indicator_cytology_tab,
                                                           vol_cases_signed),
                                                 received_to_signed) %>%
    mutate(Target = paste0("<= ",as.character(Received.to.signed.out.target..Days.)," Days")) %>%
    arrange(SPECIMEN_GROUP,PATIENT_SETTING) %>%
    select(SPECIMEN_GROUP,
           Target,
           PATIENT_SETTING,
           no_cases_signed,
           received_to_signed_out_within_target,
           avg_collection_to_signed_out_MSH,
           avg_collection_to_signed_out_MSQ,
           avg_collection_to_signed_out_MSBI,
           avg_collection_to_signed_out_PACC,
           avg_collection_to_signed_out_MSB,
           avg_collection_to_signed_out_MSW,
           avg_collection_to_signed_out_MSM,
           avg_collection_to_signed_out_NYEE) %>%
    mutate(received_to_signed_out_within_target = percent(received_to_signed_out_within_target, digits = 0),
           no_cases_signed = cell_spec(no_cases_signed, "html",
                                       color = ifelse(is.na(no_cases_signed), 
                                                      "lightgray",
                                                      "black")),
           received_to_signed_out_within_target = cell_spec(
             received_to_signed_out_within_target, "html",
             color = ifelse(is.na(received_to_signed_out_within_target), "lightgray",
                            ifelse((received_to_signed_out_within_target >= 0.90),
                                   "green",
                                   ifelse(
                                     (received_to_signed_out_within_target >= 0.8) |
                                       (received_to_signed_out_within_target > 0.9),
                                     "orange", "red")))))
  
  
  return(efficiency_indicator_cytology_tab)
  
}

#Tests Surgical Cytology Efficiency Data ----
#cytology_eff_data <- get_efficiency_indicators_cytology(tab_data_cytology)



# For Efficiency Indicators Surgical Pathology Tab ----
get_efficiency_indicators_surgical_pathology <- function(summarized_data){
  # get the volume by patient setting
  vol_cases_signed <- summarized_data %>%
    group_by(SPECIMEN_GROUP,
             PATIENT_SETTING) %>%
    summarise(no_cases_signed = sum(NO_CASES_SIGNED_OUT,
                                    na.rm = TRUE))
  
  #Calculate average collection to signed out
  #Calculate % Receive to result TAT within target
  #this part of the code creates the table for the received to result TAT
  #within target with an assumption that the receive to result is not
  #centralized which means it is stratified by facility
  
  efficiency_indicator_pathology_tab <- summarized_data %>%
    group_by(SPECIMEN_GROUP,
             SITE,
             PATIENT_SETTING) %>%
    summarise(avg_collection_to_signed_out =
                format(
                  round(
                    sum(
                      (COL_TO_SIGNED_OUT_AVG *
                         NO_CASES_SIGNED_OUT) /
                        sum(NO_CASES_SIGNED_OUT),
                      na.rm = TRUE), 0)),
              received_to_signed_out_within_target =
                format(
                  round(
                    sum(
                      (REC_TO_SIGNED_OUT_WITHIN_TARGET *
                         NO_CASES_SIGNED_OUT) /
                        sum(NO_CASES_SIGNED_OUT),
                      na.rm = TRUE), 2))) %>%
    pivot_longer(cols = c(avg_collection_to_signed_out,received_to_signed_out_within_target),
                 names_to  = "METRIC",
                 values_to = "VALUE") %>%
    mutate(VALUE = as.numeric(VALUE))
  
  
  
  efficiency_indicator_pathology_tab <- left_join(table_ap_template_surgical_pathology,
                                                  efficiency_indicator_pathology_tab) %>%
    pivot_wider(id_cols = c(SPECIMEN_GROUP,PATIENT_SETTING,SITE),
                names_from = c(METRIC),
                values_from = VALUE) %>%
    mutate(received_to_signed_out_within_target = percent(received_to_signed_out_within_target, digits = 0),
           received_to_signed_out_within_target = cell_spec(
             received_to_signed_out_within_target, "html",
             color = ifelse(is.na(received_to_signed_out_within_target), "lightgray",
                            ifelse((received_to_signed_out_within_target >= 0.90),
                                   "green",
                                   ifelse(
                                     (received_to_signed_out_within_target >= 0.8) |
                                       (received_to_signed_out_within_target > 0.9),
                                     "orange", "red")))),
           avg_collection_to_signed_out = cell_spec(
             avg_collection_to_signed_out, "html",
             color = ifelse(is.na(avg_collection_to_signed_out), "lightgray","black")),
           avg_collection_to_signed_out = as.character(avg_collection_to_signed_out)) %>%
    pivot_longer(cols = c(avg_collection_to_signed_out,received_to_signed_out_within_target),
                 names_to  = "METRIC",
                 values_to = "VALUE") %>%
    pivot_wider(id_cols = c(SPECIMEN_GROUP,PATIENT_SETTING),
                names_from = c(METRIC,SITE),
                values_from = VALUE)
  
  
  efficiency_indicator_pathology_tab <- left_join(efficiency_indicator_pathology_tab,
                                                  tat_targets_ap %>%
                                                    select(1,2,3),
                                                  by = c("SPECIMEN_GROUP" = "spec_group",
                                                         "PATIENT_SETTING" = "Patient.Setting"))
  # set the order
  efficiency_indicator_pathology_tab <- left_join(efficiency_indicator_pathology_tab,vol_cases_signed) %>%
    mutate(Target = paste0("<= ",as.character(Received.to.signed.out.target..Days.)," Days"),
           no_cases_signed = cell_spec(no_cases_signed, "html",
                                       color = ifelse(is.na(no_cases_signed), 
                                                      "lightgray",
                                                      "black"))) %>%
    arrange(SPECIMEN_GROUP,PATIENT_SETTING) %>%
    select(SPECIMEN_GROUP,
           Target,
           PATIENT_SETTING,
           no_cases_signed,
           received_to_signed_out_within_target_MSH,
           received_to_signed_out_within_target_MSQ,
           received_to_signed_out_within_target_MSBI,
           received_to_signed_out_within_target_PACC,
           received_to_signed_out_within_target_MSB,
           received_to_signed_out_within_target_MSW,
           received_to_signed_out_within_target_MSM,
           avg_collection_to_signed_out_MSH,
           avg_collection_to_signed_out_MSQ,
           avg_collection_to_signed_out_MSBI,
           avg_collection_to_signed_out_PACC,
           avg_collection_to_signed_out_MSB,
           avg_collection_to_signed_out_MSW,
           avg_collection_to_signed_out_MSM) %>%
    mutate(SPECIMEN_GROUP = case_when(SPECIMEN_GROUP == "Breast" ~ paste0("All ",
                                                                          SPECIMEN_GROUP,
                                                                          " Specimens"),
                                      SPECIMEN_GROUP == "GI" ~ paste0(SPECIMEN_GROUP,
                                                                      " Biopsies")))
  
  return(efficiency_indicator_pathology_tab)
  
}


##### This function helps in creating the analysis and tables from the
# summarized table. Will be used in first run and second run as well.
##### This function helps in creating the analysis and tables from the
# summarized table. Will be used in first run and second run as well.
analyze_backlog <- function(summarized_table_backlog, summarized_table_cytology) {
  if (is.null(summarized_table_backlog)) {
    backlog_acc_table <- NULL
  } else {
    
    cyto_backlog_volume <- summarized_table_backlog %>%
      group_by(Spec_group) %>%
      summarise(cyto_backlog = sum(as.numeric(cyto_backlog),
                                   na.rm = TRUE),
                percentile_25th =
                  ceiling(quantile(as.numeric(percentile_25th),
                                   prob = 0.25,
                                   na.rm = TRUE)),
                percentile_50th =
                  ceiling(quantile(as.numeric(percentile_50th),
                                   prob = 0.5,
                                   na.rm = TRUE)),
                maximum =
                  ceiling(max(as.numeric(maximum),
                              na.rm = TRUE)))
    
    cyto_backlog_volume  <- cyto_backlog_volume  %>%
      mutate(maximum = ifelse(maximum %in% c("-Inf","Inf"), 
                              0,
                              maximum))
    #Days of work
    cyto_case_vol_dow <- as.numeric(cyto_backlog_volume$cyto_backlog[1]) / 80
    
    
    cyto_cases_accesioned <- summarized_table_cytology %>%
      group_by(SPECIMEN_GROUP) %>%
      summarise(cyto_acc_recieved = as.numeric(sum(CYTO_ACCESSION_VOLUME,
                                                   na.rm = TRUE))) %>%
      rename(Spec_group = SPECIMEN_GROUP )
    
    #count the accessioned volume that was accessioned on that date
    #from the backlog report
    cyto_acc_spec_group <- summarized_table_backlog %>%
      group_by(Spec_group) %>%
      summarise(cyto_acc_spec_group_vol = as.numeric(sum(cyto_acc_vol,
                                                         na.rm = TRUE)))
    #sum the two counts
    cyto_acc_totals <- merge(x = cyto_cases_accesioned, y = cyto_acc_spec_group)
    
    cyto_acc_totals  <- cyto_acc_totals%>%
      mutate(total_accessioned_volume = cyto_acc_recieved + cyto_acc_spec_group_vol,
             cyto_acc_recieved = NULL,
             cyto_acc_spec_group_vol = NULL)
    
    
    backlog_acc_table <- merge(x = cyto_acc_totals,
                               y = cyto_backlog_volume,
                               all = TRUE,
    ) %>%
      pivot_longer(cols = c("total_accessioned_volume",
                            "cyto_backlog",
                            "percentile_25th",
                            "percentile_50th",
                            "maximum"),
                   names_to = "METRIC",
                   values_to = "VALUE") %>%
      drop_na(VALUE)
    
    
    backlog_acc_table <- merge(x = table_backlog_template,
                               y = backlog_acc_table,
                               all.x = TRUE, by = c("Spec_group","METRIC")) %>%
      mutate(VALUE = cell_spec(VALUE, "html",
                               color = ifelse(is.na(VALUE), 
                                              "lightgray",
                                              "black"))) %>%
      pivot_wider(names_from = "METRIC", 
                  values_from = "VALUE")
    
    # backlog_acc_table <- backlog_acc_table %>% 
    #   mutate(across(everything(), ~replace_na(.x, 0)))
    
    #added this line to delete the cyto gyn from the table until we get
    #correct data. Currently not in use
    #backlog_acc_table <- backlog_acc_table[-c(1), ]
  }
  return(backlog_acc_table)
}

# Copied from Automated Daily Dashboard/AP_kable_outputs.R
# Surgical Pathology - Efficiency Indicators ----
ap_ei_kable_surgical_pathology <- function(surgical_pathology_ei_data){
  
  if(is.null(surgical_pathology_ei_data)){
    surgical_pathology_ei_data <- NULL
    asis_output(
      paste("<i>",
            "No data available for efficiency indicator reporting.",
            "</i>"))
  }else{
    colnames <- c("Case Type",
                  "Target",
                  "Setting",
                  "No. Cases Signed Out",
                  "MSH",
                  "MSQ",
                  "MSBI",
                  "PACC",
                  "MSB",
                  "MSW",
                  "MSM",
                  "MSH",
                  "MSQ",
                  "MSBI",
                  "PACC",
                  "MSB",
                  "MSW",
                  "MSM")
    
    num_col <- length(colnames)
    # Format kable
    kable(surgical_pathology_ei_data, format = "html", escape = FALSE, align = "c",
          col.names = colnames) %>%
      kable_styling(bootstrap_options = "hover", position = "center",
                    font_size = 11,
                    full_width = FALSE) %>%
      column_spec(column = c(1, 11, 18),
                  border_right = "thin solid lightgray") %>%
      add_header_above(c(" " = 1,
                         "Receive to Result Within Target (Business Days)" =
                           10,
                         "Average Collect to Result TAT (Calendar Days)" =
                           7),
                       background = c("white", "#00AEEF", "#221f72"),
                       color = "white", line = FALSE, font_size = 13) %>%
      column_spec(column = 2:11, background = "#E6F8FF",color = "black") %>%
      column_spec(column = 12:num_col, background = "#EBEBF9",color = "black") %>%
      row_spec(row = 0, font_size = 13) %>%
      collapse_rows(columns = c(1, 2))
    
  }
}


# Cytology - Efficiency Indicators ----
ap_ei_kable_cytology <- function(cytology_ei_data){
  
  if(is.null(cytology_ei_data)){
    cytology_ei_data <- NULL
    asis_output(
      paste("<i>",
            "No data available for efficiency indicator reporting.",
            "</i>"))
  }else{
    colnames <- c("Case Type",
                  "Target",
                  "Setting",
                  "No. Cases Signed Out",
                  "Centralized Lab",
                  "MSH",
                  "MSQ",
                  "MSBI",
                  "PACC",
                  "MSB",
                  "MSW",
                  "MSM",
                  "NYEE")
    
    num_col <- length(colnames)
    # Format kable
    kable(cytology_ei_data, format = "html", escape = FALSE, align = "c",
          col.names = colnames) %>%
      kable_styling(bootstrap_options = "hover", position = "center",
                    font_size = 11,
                    full_width = FALSE) %>%
      column_spec(column = c(1, 5, num_col),
                  border_right = "thin solid lightgray") %>%
      add_header_above(c(" " = 1,
                         "Receive to Result Within Target (Business Days)" =
                           4,
                         "Average Collect to Result TAT (Calendar Days)" =
                           8),
                       background = c("white", "#00AEEF", "#221f72"),
                       color = "white", line = FALSE, font_size = 13) %>%
      column_spec(column = 2:5, background = "#E6F8FF",color = "black") %>%
      column_spec(column = 6:num_col, background = "#EBEBF9",color = "black") %>%
      row_spec(row = 0, font_size = 13) %>%
      collapse_rows(columns = c(1, 2))
    
  }
}


# 24 Hours Volume Backlog ----
table_formatting_volume_backlog <- function(backlog_table) {
  if (holiday_det) {
    asis_output(
      paste("<i>",
            "No cases accessioned on weekends and holidays.",
            "</i>")
    )
  } else if (is.null(backlog_table)) {
    asis_output(
      paste("<i>",
            "No data available for backlog and accessioned volume reporting.",
            "</i>")
    )
  } else {
    backlog_table %>%
      kable(escape = F, align = "c",
            col.names = c("Case Type", "Cases Accessioned", "Backlog Volume",
                          "25th Percentile", "50th Percentile", "Maximum")) %>%
      kable_styling(bootstrap_options = "hover", full_width = TRUE,
                    position = "center", row_label_position = "c",
                    font_size = 11) %>%
      column_spec(2, background = "#E6F8FF", color = "black") %>%
      column_spec(3:6, background = "#EBEBF9", color = "black") %>%
      row_spec(row = 0, font_size = 13) %>%
      add_header_above(c(
        " " = 2,
        "Elapsed Turn Around Time for Backlogged Cases From the Received Time" = 4),
        background = c("white", "#221F72"), color = "white", font_size = 13) %>%
      collapse_rows(columns = 1)
  }
}


# 24 Hours Volume SP and Cytology ----

table_formatting_volume <- function(vol_table, tab) {
  if (is.null(vol_table)) {
    vol_table <- NULL
    asis_output(
      paste("<i>",
            "No data available for volume reporting.",
            "</i>")
    )
  } else {
    
    column_names <- NA
    
    if(tab == "CYTOLOGY"){
      column_names <- cyto_vol_column_names
    }else{
      column_names <- sp_vol_column_names
    }
    
    vol_table %>%
      select(everything()) %>%
      kable(escape = F, align = "c", col.names = column_names) %>%
      kable_styling(bootstrap_options = "hover", full_width = FALSE,
                    position = "center", row_label_position = "c",
                    font_size = 11) %>%
      add_header_above(c(" " = 2,
                         "Resulted Lab Volume" = length(column_names) - 2),
                       background = c("white", "#00B9F2"), color = "white",
                       font_size = 13) %>%
      column_spec(3:length(column_names), background = "#E6F8FF",
                  color = "black") %>%
      row_spec(row = 0, font_size = 13) %>%
      collapse_rows(columns = 1)
    
  }
}


```

```{r Preprocess AP data, warning = FALSE, message = FALSE, echo = FALSE,eval = ap_eval}
processed_cytology_data <-  cyto_prep(epic_data_raw ,pp_data_raw,yesterday)

processed_surgical_pathology_data <- patho_prep(pp_data_raw,yesterday)

processed_backlog_data <- pre_processing_backlog(cyto_backlog_data_raw,yesterday)


```

```{r Calling the Custom functions for processing to output formats data, warning = FALSE, message = FALSE, echo = FALSE, eval = ap_eval}
stratified_volume_cytology_24 <- get_stratified_volume(processed_cytology_data, "CYTOLOGY")
stratified_volume_surgical_pathology_24 <- get_stratified_volume(processed_surgical_pathology_data, "SURGICAL PATHOLOGY")

backlog_cytlogy <- analyze_backlog(processed_backlog_data,processed_cytology_data)

ei_cytlogy <- get_efficiency_indicators_cytology(processed_cytology_data)
ei_surgical_pathology <- get_efficiency_indicators_surgical_pathology(processed_surgical_pathology_data)

```


# {.tabset .tabset-fade .tabset-pills}

## **Efficiency Indicators** {.tabset .tabset-fade .tabset-pills}

<br>

### Chemistry       
#### *Chemistry KPI (Labs Resulted on `r result_date_text`)*
<h5>Status Definitions: <span style = "color:red">Red:</span> <80%, 
<span style = "color:orange">Yellow:</span> >=80% & <95%,
<span style = "color:green">Green:</span> >=95%</h5>
```{r Chemistry dashboard table, warning = FALSE, message = FALSE, echo = FALSE}

if (cp_eval){
  kable_cp_tat(x = chem_tat_output[[2]])
} else {
  asis_output(
    paste("<i><b><span style='color:red'>",
          "Missing Sunquest and/or SCC data. Please check that file is saved properly.",
          "</span style='color:red'></b></i>"))
}

```
<h6>*TAT Analysis excludes add on orders, labs with missing timestamps, labs with negative TAT, and labs not from above settings. Labs with missing collection times excluded from collect-to-result analysis. MSH BUN excludes labs collected and processed at RTC; see "Infusion" tab.*</h6>
  
  
### Hematology
#### *Hematology KPI (Labs Resulted on `r result_date_text`)*
<h5>Status Definitions: <span style = "color:red">Red:</span> <80%, 
<span style = "color:orange">Yellow:</span> >=80% & <95%,
<span style = "color:green">Green:</span> >=95%</h5>
```{r Hematology dashboard table, warning = FALSE, message = FALSE, echo = FALSE}
if (cp_eval){
  kable_cp_tat(x = hematology_tat_output[[2]])
} else {
  asis_output(
    paste("<i><b><span style='color:red'>",
          "Missing Sunquest and/or SCC data. Please check that file is saved properly.",
          "</span style='color:red'></b></i>"))
}
```
<h6>*TAT Analysis excludes add on orders, labs with missing timestamps, labs with negative TAT, and labs not from above settings. Labs with missing collection times excluded from collect-to-result analysis. MSH HGB excludes labs collected and processed at RTC; see "Infusion" tab.*</h6>
  

### Microbiology RRL
#### *Microbiology RRL KPI (Labs Resulted on `r result_date_text`)*
<h5>Status Definitions: <span style = "color:red">Red:</span> <90%, 
<span style = "color:orange">Yellow:</span> >=90% & <100%,
<span style = "color:green">Green:</span> =100%</h5>
```{r Create Micro RRL TAT and Volume Table, warning = FALSE, message = FALSE, echo = FALSE}
# Create volume table for Microbiology RRL that mimics TAT table layout
if (cp_eval) {
  if (is.null(micro_summary)) {
    micro_tat_vol_cast <- NULL
    } else {
      # Ensure all Microbiology RRL test, site, and priority combinations are included
      micro_vol_templ <- tat_dashboard_templ %>%
        filter(Division == "Microbiology RRL") %>%
        mutate(Incl = NULL,
               Division = NULL)
      
      micro_vol_df <- micro_summary %>%
        mutate(Metric = "ResultedVolume") %>%
        rename(Value = ResultedVolume) %>%
        select(-Division, -ResultedVol_ReceiveTAT, -ResultedVol_CollectTAT,
               -ReceiveResultInTarget, -CollectResultInTarget,
               -ReceiveResultPercent, -CollectResultPercent) %>%
        left_join(micro_vol_templ,
                  by = c("Test" = "Test",
                         "Site" = "Site",
                         "DashboardPriority" = "DashboardPriority",
                         "DashboardSetting" = "DashboardSetting")) %>%
        mutate(Value = replace_na(Value, 0),
               ReceiveResultTarget = "ResultedVolume",
               CollectResultTarget = "",
               #
               # Set test, site, priority, and setting as factors
               Test = droplevels(factor(Test, levels = test_names,
                                        ordered = TRUE)),
               Site = droplevels(factor(Site, levels = all_sites,
                                        ordered = TRUE)),
               DashboardPriority = droplevels(
                 factor(DashboardPriority,
                        levels = dashboard_priority_order,
                        ordered = TRUE)),
               DashboardSetting = droplevels(
                 factor(DashboardSetting,
                        levels = dashboard_pt_setting,
                        ordered = TRUE))) %>%
        arrange(Test, DashboardPriority, DashboardSetting, Site) %>%
        pivot_wider(names_from = c(Metric, Site),
                    names_sep = "_",
                    values_from = Value) %>%
        relocate(TestAndPriority, .after = DashboardPriority) %>%
        relocate(ReceiveResultTarget, .after = TestAndPriority) %>%
        relocate(CollectResultTarget, .after = last_col())
      
      original_length <- ncol(micro_vol_df)
      
      missing_cols <- colnames(micro_dashboard_cast)[
        seq(original_length + 1, ncol(micro_dashboard_cast))]
      
      micro_vol_df[missing_cols] <- ""
      
      colnames(micro_vol_df) <- colnames(micro_dashboard_cast)
      
      micro_tat_vol_cast <- rbind(micro_dashboard_cast, micro_vol_df)
      
      micro_tat_vol_cast <- micro_tat_vol_cast %>%
        arrange(Test, ReceiveResultTarget)
      }
  
  kable_cp_tat(x = micro_tat_vol_cast)
} else {
  asis_output(
    paste("<i><b><span style='color:red'>",
          "Missing Sunquest and/or SCC data. Please check that file is saved properly.",
          "</span style='color:red'></b></i>"))
}

```
<h6>*TAT Analysis excludes add on orders, labs with missing timestamps, labs with negative TAT, and labs not from above settings. Labs with missing collection times excluded from collect-to-result analysis.*</h6>
  
### Infusion       
#### *Infusion KPI (Labs Resulted on `r result_date_text`)*
<h5>Status Definitions: <span style = "color:red">Red:</span> <80%, 
<span style = "color:orange">Yellow:</span> >=80% & <90%,
<span style = "color:green">Green:</span> >=90%</h5>
```{r Create Infusion TAT and Volume Table, warning = FALSE, message = FALSE, echo = FALSE}
if (cp_eval){
  kable_cp_tat(x = infusion_tat_output[[2]])
} else {
  asis_output(
    paste("<i><b><span style='color:red'>",
          "Missing Sunquest and/or SCC data. Please check that file is saved properly.",
          "</span style='color:red'></b></i>"))
}
```
<h6>*TAT Analysis excludes add on orders, labs with missing timestamps, labs with negative TAT, and labs not from above settings. Labs with missing collection times excluded from collect-to-result analysis.*</h6>
  
### Missing Collections & Add Ons
#### *Missing Collection Times and Add On Order Volume (Labs Resulted on `r result_date_text`)*
<h5>Status Definitions: <span style = "color:red">Red:</span> >15%, 
<span style = "color:orange">Yellow:</span> <=15% & >5%,
<span style = "color:green">Green:</span> <=5%</h5>
```{r Missing Collection Times Tables, warning = FALSE, message = FALSE, echo = FALSE}
# # Labs with missing collection times -----------------------
# Custom function for percentage of labs with missing collection times
# Call custom functions for missing collections and add-on order volume --------
if (cp_eval){
  kable_missing_collections(x = cp_summary)
  
  kable_add_on_volume(x = cp_summary)
} else {
  asis_output(
    paste("<i><b><span style='color:red'>",
          "Missing Sunquest and/or SCC data. Please check that file is saved properly.",
          "</span style='color:red'></b></i>"))
}

```
<h6>*Missing collection time analysis includes analytes represented in Chemistry, Hematology, and Microbiology RRL dashboard TAT analysis from ED, ICU, IP Non-ICU, and ambulatory settings.*</h6>
  
### Surgical Pathology
#### *Surgical Pathology KPI (Specimens Signed Out on `r result_date_text`)*
<h5>Status Definitions: <span style = "color:red">Red:</span> <80%, 
<span style = "color:orange">Yellow:</span> >=80% & <90%,
<span style = "color:green">Green:</span> >=90%</h5>
```{r Surgical Pathology Efficiency Indicators, echo=FALSE, warning=FALSE, message=FALSE}

if (ap_eval){
  ei_surgical_pathology <- ap_ei_kable_surgical_pathology(ei_surgical_pathology)
  ei_surgical_pathology
} else {
  asis_output(
    paste("<i><b><span style='color:red'>",
          "Missing Powerpath/EPIC/Backlog Data. Please check that files are saved properly.",
          "</span style='color:red'></b></i>"))
}


```
<h6>*TAT analysis includes all breast specimens and GI biopsies and excludes those with missing timestamps, negative TAT, and not from above settings.*</h6>
  
  
### Cytology
#### *Cytology KPI (Specimens Signed Out on `r result_date_text`)*
<h5>Status Definitions: <span style = "color:red">Red:</span> <80%, 
<span style = "color:orange">Yellow:</span> >=80% & <90%,
<span style = "color:green">Green:</span> >=90%</h5>
```{r Cytology Efficiency Indicators, echo=FALSE, warning=FALSE, message=FALSE}
if (ap_eval){
  ei_cytlogy <- ap_ei_kable_cytology(ei_cytlogy)
  ei_cytlogy
} else {
  asis_output(
    paste("<i><b><span style='color:red'>",
          "Missing Powerpath/EPIC/Backlog Data. Please check that files are saved properly.",
          "</span style='color:red'></b></i>"))
}

```

<br />

```{r Lab_KPI_Form file, warning = FALSE, message = FALSE, echo = FALSE}
# Code for calling the sources code for preprocessing and analyzing the
# lab KPI form for the second run -----
#######
# source(here::here("Automated Daily Dashboard/Ops_Qlty_Indicators_Form.R"))

# copied over Automated Daily Dashboard/Ops_Qlty_Indicators_Form.R

#######
# Code for preprocessing and analyzing the lab KPI form for the second run -----
#######

# Create regular expression for Lab KPI Form file
kpi_form_pattern <- "^(Lab KPI Quality Indicator Form){1}.*"

kpi_form_date <- format(today, "%Y-%m-%d")

kpi_data_file <- list.files(
  path = paste0(user_directory, "/Lab KPI Form"),
  pattern = paste0(kpi_form_pattern,
                   "(",
                   kpi_form_date,
                   ".xlsx)$"))

#read the excel sheet that is generated from office form responses
form_eval <- FALSE

tryCatch(
  {kpi_form <- data.frame(read_excel(
  path = paste0(user_directory,
                "/Lab KPI Form/",
                kpi_data_file),
  sheet = 1),
  stringsAsFactors = FALSE)
  form_eval <- TRUE},
  error=function(e) {
            message('An Error Occurred')
            kpi_form <- NULL
        }
)


# read_excel(choose.files(default = paste0(user_directory, "/Lab KPI Form/*.*"),
#              caption = "Select the KPI form generated today"), 1),
# stringsAsFactors = FALSE)


#Determine the dates within the KPI excel sheet and report only the latest date
if(form_eval){

  kpi_form <- kpi_form %>%
    mutate(Completion_Date = as.Date(as.POSIXct(Completion.time, tz = "",
                                                format = "%m/%d/%y %I:%M %p")))
  
  kpi_form <- kpi_form %>%
    mutate(Completion_Hour = format(Completion.time, format = "%H:%M:%S"))
  
  #Rename the columns of the kpi form data
  colnames(kpi_form) <- c("ID", "Start_time", "Completion_time", "Email",
                          "Name", "Facility", "LabCorp", "Vendor_Services",
                          "Environment", "Equipment", "IT","Service_Changes",
                          "Volume", "Staffing", "Comments", "NEVER_EVENTS",
                          "NEVER_EVENTS_COMMENTS", "Good_Catch", "LIS_Staffing",
                          "LIS_Unplanned_Service", "LIS_Preplanned_Downtime",
                          "Completion_Date", "Completion_Hour")
  
  #keep only unique rows with the latest timestamp
  #order data by facility and time by descending order
  kpi_form <- kpi_form[with(kpi_form, order(Facility, -ID)), ]
  #add a column to include the dupliacted values
  kpi_form$duplicated_id <- duplicated(kpi_form[, c("Facility",
                                                    "Completion_Date")])
  #only keep the unique ids
  kpi_form <-
    kpi_form[which(kpi_form$duplicated_id == "FALSE"), ]
  
  kpi_form_today  <-
    kpi_form[which(kpi_form$Completion_Date == as.Date(today) |
                     (kpi_form$Completion_Date == as.Date(yesterday) &
                        kpi_form$Completion_Hour >= "17:00:00")), ]
  
  #split the data into 3 datasets
  # the first dataset representes the following: CP/AP/CPA/4LABS
  clinical_labs_ops_ind <-
    kpi_form_today[
      which(kpi_form_today$Facility !=
              "Laboratory Information System (LIS)"), c(6:15)]
  
  # the second dataset represents the LIS indicators
  lis_ops_ind <-
    kpi_form_today[
      which(kpi_form_today$Facility ==
              "Laboratory Information System (LIS)"), c(6, 19:21)]
  
  # the third and last dataset is the never events and good catches dataset
  never_events <-
    kpi_form_today[
      which(kpi_form_today$Facility !=
              "Laboratory Information System (LIS)"), c(6, 16:18)]
  
  ####### Start creating and formatting the tables
  
  #first melt the tables to get the values needed in one column:
  
  #1. Clinical labs table
  clinical_labs_melt <-
    melt(clinical_labs_ops_ind,
         id = c("Facility", "Comments"))
  
  #2. LIS table
  lis_melt <- melt(lis_ops_ind,
                   id = c("Facility",
                          "LIS_Unplanned_Service",
                          "LIS_Preplanned_Downtime"))
  
  ##### create a function to rename the status of the measures to a standard one
  #( Safe, Under Stress, and Not Safe)
  
  renaming <- function(melted_dataset) {
    if (is.null(melted_dataset) || nrow(melted_dataset) == 0) {
      melted_dataset <- NULL
    } else {
      melted_dataset[melted_dataset == "Green (No issues)"] <- "Safe"
      
      melted_dataset[
        melted_dataset == "Yellow (Safe/Under Stress)" |
          melted_dataset == "Yellow (Delays)" |
          melted_dataset == "Yellow (Delays in pickup/delivery)" |
          melted_dataset ==
          "Yellow (Shortage with no/minimal significant impact)" |
          melted_dataset ==
          "Yellow (Minor issues/Coordinating with Reference Labs)"] <-
        "Under Stress"
      
      melted_dataset[
        melted_dataset == "Yellow (Safe/Under Stress)" |
          melted_dataset == "Yellow (Delays)" |
          melted_dataset == "Yellow (Delays in pickup/delivery)" |
          melted_dataset ==
          "Yellow (Shortage with no/minimal significant impact)" |
          melted_dataset ==
          "Yellow (Minor issues/Coordinating with Reference Labs)"] <-
        "Under Stress"
      
      melted_dataset[
        melted_dataset == "Red (Severe shortage of consumables)" |
          melted_dataset == "Red (Missed pickups)" |
          melted_dataset == "Red (Not Safe/Risk)" |
          melted_dataset == "Red (Severe shortage that halts activity)" |
          melted_dataset == "Red (Major issues/Requires Immediate Attention)"] <-
        "Not Safe"
    }
    
    return(melted_dataset)
    
  }
  
  clinical_labs_melt_new <- renaming(clinical_labs_melt)
  lis_melt_new <- renaming(lis_melt)
  
  ### create a function to format the data table into the correct colors
  conditional_format_form <- function(melted_data_new) {
    if (is.null(melted_data_new) || nrow(melted_data_new) == 0) {
      melted_data_new <- NULL
    } else {
      melted_data_new <-
        melted_data_new %>%
        mutate(
          value =
            ifelse(is.na(value),
                   cell_spec(value, "html", color = "lightgray"),
                   ifelse((value == "Safe" | value == "None"),
                          cell_spec(value, "html", color  = "green"),
                          ifelse((value == "Not Safe" | value == "Present"),
                                 cell_spec(value, "html", color = "red"),
                                 cell_spec(value, "html", color = "orange")))))
      return(melted_data_new)
      
    }
    
  }
  
  formatted_clinical_labs <-
    conditional_format_form(clinical_labs_melt_new)
  
  formatted_lis_new <- conditional_format_form(lis_melt_new)
  
  ###### ------------- Now decast the melted clinical table ------------- ######
  formatted_clinical_labs1 <-
    dcast(formatted_clinical_labs,
          Facility + Comments ~ variable)
  
  #Change the order of the columns in the table
  columns_order_form_clinical <-
    c("Facility", "LabCorp", "Vendor_Services", "Environment", "Equipment", "IT",
      "Service_Changes", "Volume", "Staffing", "Comments")
  
  formatted_clinical_labs1 <-
    formatted_clinical_labs1[, columns_order_form_clinical]
  
  needed_rows <- data.frame(matrix(ncol = 1, nrow = 11))
  
  colnames(needed_rows) <- c("Facility")
  
  needed_rows[1] <-
    c("MSH (Clinical Pathology, Blood Bank, Anatomic Pathology Front End, etc.)",
      "MSQ (Clinical Pathology, Blood Bank, Anatomic Pathology Front End, etc.)",
      "MSBI (Clinical Pathology, Blood Bank, Anatomic Pathology Front End, etc.)",
      "MSB (Clinical Pathology, Blood Bank, Anatomic Pathology Front End, etc.)",
      "MSW (Clinical Pathology, Blood Bank, Anatomic Pathology Front End, etc.)",
      "MSSL (Clinical Pathology, Blood Bank, Anatomic Pathology Front End, etc.)",
      "NYEE (Clinical Pathology, Blood Bank, Anatomic Pathology Front End, etc.)",
      "MSSN (Clinical Pathology, Blood Bank, Anatomic Pathology Front End, etc.)",
      "MSH - Anatomic Pathology (Centralized)",
      "MSH - Central Processing & Accessioning",
      "4LABS - Client Services")
  
  #i need all the columns from x and all the rows from x and y
  trial <- right_join(formatted_clinical_labs1, needed_rows)
  #
  rownames(trial) <- trial$Facility
  
  #Change the order of the rows in the table
  
  formatted_clinical_labs2 <-
    trial[c(
      "MSH (Clinical Pathology, Blood Bank, Anatomic Pathology Front End, etc.)",
      "MSQ (Clinical Pathology, Blood Bank, Anatomic Pathology Front End, etc.)",
      "MSBI (Clinical Pathology, Blood Bank, Anatomic Pathology Front End, etc.)",
      "MSB (Clinical Pathology, Blood Bank, Anatomic Pathology Front End, etc.)",
      "MSW (Clinical Pathology, Blood Bank, Anatomic Pathology Front End, etc.)",
      "MSSL (Clinical Pathology, Blood Bank, Anatomic Pathology Front End, etc.)",
      "NYEE (Clinical Pathology, Blood Bank, Anatomic Pathology Front End, etc.)",
      "MSSN (Clinical Pathology, Blood Bank, Anatomic Pathology Front End, etc.)",
      "MSH - Anatomic Pathology (Centralized)",
      "MSH - Central Processing & Accessioning",
      "4LABS - Client Services"), ]
  
  rownames(formatted_clinical_labs2) <- NULL
  
  #Change the names in the Facility columns to be standardized
  
  rownames(formatted_clinical_labs2) <-
    c("MSH", "MSQ", "MSBI", "MSB", "MSW", "MSSL", "NYEE", "MSSN",
      "Anatomic Pathology (Centralized)",
      "Central Processiong & Accessioning (CPA)",
      "Client Services - 4LABS")
  
  formatted_clinical_labs2 <- formatted_clinical_labs2 %>%
    mutate(Facility = rownames(formatted_clinical_labs2))
  
  rownames(formatted_clinical_labs2) <- NULL
  
  formatted_clinical_labs3 <- formatted_clinical_labs2[, c(1:9)]
  
  comments_clinical_labs <- formatted_clinical_labs2[, c(1, 10)]
  comments_clinical_labs[is.na(comments_clinical_labs)] <-
    "No Issues Reported (Safe)"
  
  comments_clinical_labs[comments_clinical_labs == "None" |
                           comments_clinical_labs == "NONE" |
                           comments_clinical_labs == "none" |
                           comments_clinical_labs == "N/A" |
                           comments_clinical_labs == "n/a" |
                           comments_clinical_labs == "na" |
                           comments_clinical_labs == "NA"] <-
    "No Issues Reported (Safe)"
  
  ###### --------------- now decast the LIS  table --------------- ######
  if (is.null(formatted_lis_new) || nrow(formatted_lis_new) == 0) {
    formatted_lis_new2 <- NULL
  } else{
    formatted_lis_new2 <-
      dcast(formatted_lis_new,
            Facility +
              LIS_Unplanned_Service +
              LIS_Preplanned_Downtime ~ variable)
    
    columns_order_form_lis <-
      c("Facility",
        "LIS_Staffing",
        "LIS_Unplanned_Service",
        "LIS_Preplanned_Downtime")
    
    formatted_lis_new2 <- formatted_lis_new2[, columns_order_form_lis]
    rownames(formatted_lis_new2) <- NULL
    formatted_lis_new2[is.na(formatted_lis_new2)] <- "None"
  }
  ###### --------------- Formatting Never Events Table --------------- ######
  
  # added 4 extra columns each one for different never event
  never_events["Specimen(s) Lost"] <- NA
  never_events["QNS - specimen that cannot be recollected"] <- NA
  never_events["Treatment based on mislabeled/misidentified specimen"] <- NA
  never_events["Treatment based on false positive/false negative results"] <- NA
  
  #because we have multiple never events in one cell i created a
  #list with these by:
  split_text <- sapply(never_events$NEVER_EVENTS, strsplit, "[;]")
  
  #created a nested for loop with nested if to determine which of these
  #never events are listed
  for (i in 1:nrow(never_events)) {
    for (j in 1:length(split_text[[i]])) {
      if (split_text[[i]][j] == colnames(never_events)[5]) {
        never_events$`Specimen(s) Lost`[i] <- 1
      }
      else if (split_text[[i]][j] == colnames(never_events)[6]) {
        never_events$`QNS - specimen that cannot be recollected`[i] <- 1
      }
      else if (split_text[[i]][j] == colnames(never_events)[7]) {
        never_events$`Treatment based on mislabeled/misidentified specimen`[i] <-
          1
      }
      else if (split_text[[i]][j] == colnames(never_events)[8]) {
        never_events$`Treatment based on false positive/false negative results`[i] <- 1
      }
    }
  }
  
  never_events <- never_events %>%
    mutate(NEVER_EVENTS = NULL)
  
  never_events_melt <-
    melt(never_events,
         id = c(
           "Facility",
           "NEVER_EVENTS_COMMENTS",
           "Good_Catch"))
  
  never_events_melt$value[is.na(never_events_melt$value)] <- "None"
  never_events_melt$value[never_events_melt$value == 1] <- "Present"
  
  never_events_melt[never_events_melt == "None" |
                      never_events_melt == "NONE" |
                      never_events_melt == "none" |
                      never_events_melt == "N/A" |
                      never_events_melt == "n/a" |
                      never_events_melt == "na" |
                      never_events_melt == "NA"] <- "None"
  
  formatted_never_event_melt <- conditional_format_form(never_events_melt)
  
  formatted_never_event_ <-
    dcast(formatted_never_event_melt,
          Facility +
            NEVER_EVENTS_COMMENTS +
            Good_Catch ~ variable)
  
  never_events_column_order_1 <-
    c("Facility",
      "Specimen(s) Lost",
      "QNS - specimen that cannot be recollected",
      "Treatment based on mislabeled/misidentified specimen",
      "Treatment based on false positive/false negative results",
      "NEVER_EVENTS_COMMENTS", "Good_Catch")
  
  formatted_never_event_ <- formatted_never_event_[, never_events_column_order_1]
  
  #Change the order of the rows in the table
  trial_neverevent <- right_join(formatted_never_event_, needed_rows)
  rownames(trial_neverevent) <- trial_neverevent$Facility
  
  #Change the order of the rows in the table
  
  formatted_never_event <-
    trial_neverevent[c(
      "MSH (Clinical Pathology, Blood Bank, Anatomic Pathology Front End, etc.)",
      "MSQ (Clinical Pathology, Blood Bank, Anatomic Pathology Front End, etc.)",
      "MSBI (Clinical Pathology, Blood Bank, Anatomic Pathology Front End, etc.)",
      "MSB (Clinical Pathology, Blood Bank, Anatomic Pathology Front End, etc.)",
      "MSW (Clinical Pathology, Blood Bank, Anatomic Pathology Front End, etc.)",
      "MSSL (Clinical Pathology, Blood Bank, Anatomic Pathology Front End, etc.)",
      "NYEE (Clinical Pathology, Blood Bank, Anatomic Pathology Front End, etc.)",
      "MSSN (Clinical Pathology, Blood Bank, Anatomic Pathology Front End, etc.)",
      "MSH - Anatomic Pathology (Centralized)",
      "MSH - Central Processing & Accessioning",
      "4LABS - Client Services"), ]
  
  rownames(formatted_never_event) <- NULL
  
  #Change the names in the Facility columns to be standardized
  
  rownames(formatted_never_event) <-
    c("MSH", "MSQ", "MSBI", "MSB", "MSW", "MSSL", "NYEE", "MSSN",
      "Anatomic Pathology (Centralized)",
      "Central Processiong & Accessioning (CPA)",
      "Client Services - 4LABS")
  
  formatted_never_event <- formatted_never_event %>%
    mutate(Facility = rownames(formatted_never_event))
  
  rownames(formatted_never_event) <- NULL
  
  #Split the table into three
  #table one is the comments only while table two is the details
  
  good_catch <- formatted_never_event[, c(1, 7)]
  good_catch[is.na(good_catch)] <- "No Issues Reported"
  
  good_catch[good_catch == "None" |
               good_catch == "NONE" |
               good_catch == "none" |
               good_catch == "N/A" |
               good_catch == "n/a" |
               good_catch == "na" |
               good_catch == "NA" |
               good_catch == 0] <- "No Issues Reported"
  
  
  never_events_comments <- formatted_never_event[, c(1, 6)]
  never_events_comments[is.na(never_events_comments)] <- "No Issues Reported"
  
  never_events_comments[never_events_comments == "None" |
                          never_events_comments == "NONE" |
                          never_events_comments == "none" |
                          never_events_comments == "N/A" |
                          never_events_comments == "n/a" |
                          never_events_comments == "na" |
                          never_events_comments == "NA" |
                          never_events_comments == 0] <- "No Issues Reported"
  
  never_events_only <- formatted_never_event[, c(1:5)]
}else{
  formatted_clinical_labs3 <- NULL
  formatted_lis_new2 <- NULL
  never_events_only <- NULL
  good_catch <- NULL
}



```

<br />

## **Operational and Quality Indicators**  {.tabset .tabset-fade .tabset-pills}
### Operational Indicators
#### *Operational Indicators for Labs at each Site & Centralized Anatomic Pathology (Submitted on `r format(today, "%m/%d/%y")`)*
```{r Qualitative Indicators for Clinical Labs, echo=FALSE, message=FALSE, warning=FALSE, eval = TRUE}

if(form_eval){
  formatted_clinical_labs3 %>%
    select(everything()) %>%
    kable(escape = F, align = "c",
          col.names = c("Facility", "Lab Corp Consumable", "Vendor Services",
                        "Enviroment", "Equipment", "IT", "Service Change",
                        "Acute Volume Increase", "Staffing")) %>%
    kable_styling(bootstrap_options = "hover", full_width = FALSE,
                  position = "center", row_label_position = "c",
                  font_size = 11) %>%
    row_spec(row = 0, font_size = 13)

comments_clinical_labs %>%
    select(everything()) %>%
    kable(escape = F, align = "c",
          col.names = c("Facility", "Comments if At Risk or Not Safe")) %>%
    kable_styling(bootstrap_options = "hover", full_width = TRUE,
                  position = "center", row_label_position = "c",
                  font_size = 11) %>%
    row_spec(row = 0, font_size = 13)

}else{
    asis_output(
    paste("<i><b><span style='color:red'>",
          "Missing Form Responses Data. Please check that files are saved properly.",
          "</span style='color:red'></b></i>"))
}

```

### Laboratory Information System
#### *Operational Indicators for LIS (Submitted on `r format(today, "%m/%d/%y")`)*

```{r Qualitative Indicators for LIS, echo=FALSE, message=FALSE, warning=FALSE, eval = TRUE}


if(form_eval){
  formatted_lis_new2 %>%
      select(everything()) %>%
      kable(escape = F, align = "c",
            col.names = c("", "Staffing", "Service Change",
                          "Preplanned Downtime")) %>%
      kable_styling(bootstrap_options = "hover", full_width = FALSE,
                    position = "center", row_label_position = "c",
                    font_size = 11) %>%
      row_spec(row = 0, font_size = 13)
  
}else{
    asis_output(
    paste("<i><b><span style='color:red'>",
          "Missing Form Responses Data. Please check that files are saved properly.",
          "</span style='color:red'></b></i>"))
}



```

### Quality Indicators
#### Never Events 
##### *Reported Never Events for Each Division/Facility (Submitted on `r format(today, "%m/%d/%y")`)*
```{r Lab KPI Form for Never Events, echo=FALSE, message=FALSE, warning=FALSE, eval = TRUE}

if(form_eval){
  never_events_only %>%
    select(everything()) %>%
    kable(escape = F, align = "c",
          col.names = c(
            "Facility", "Specimen(s) Lost",
            "QNS - specimen that cannot be recollected",
            "Treatment based on mislabeled/misidentified specimen",
            "Treatment based on false positive/false negative results")) %>%
    kable_styling(bootstrap_options = "hover", full_width = FALSE,
                  position = "center", row_label_position = "c",
                  font_size = 11) %>%
    row_spec(row = 0, font_size = 13)
  
  never_events_comments %>%
    select(everything()) %>%
    kable(escape = F, align = "c",
          col.names = c("Facility", "Comments if There is a Never Event")) %>%
    kable_styling(bootstrap_options = "hover", full_width = FALSE,
                  position = "center", row_label_position = "c",
                  font_size = 11) %>%
    row_spec(row = 0, font_size = 13)
  }else{
    asis_output(
    paste("<i><b><span style='color:red'>",
          "Missing Form Responses Data. Please check that files are saved properly.",
          "</span style='color:red'></b></i>"))
}

```

#### Good Catches
##### *Reported Good Catches for Each Division/Facility (Submitted on `r format(today, "%m/%d/%y")`)*
```{r Lab KPI Form for Good Catches, echo=FALSE, message=FALSE, warning=FALSE, eval = TRUE}


if(form_eval){
  good_catch %>%
    select(everything()) %>%
    kable(escape = F, align = "c",
          col.names = c("Facility", "Good Catch Comment")) %>%
    kable_styling(bootstrap_options = "hover", full_width = FALSE,
                  position = "center", row_label_position = "c",
                  font_size = 11) %>%
    row_spec(row = 0, font_size = 13)
  }else{
    asis_output(
    paste("<i><b><span style='color:red'>",
          "Missing Form Responses Data. Please check that files are saved properly.",
          "</span style='color:red'></b></i>"))
}

```

<br />
  
## **24-Hour Volume Lookback** {.tabset .tabset-fade .tabset-pills}

### Chemistry
#### *Chemistry Resulted Lab Volume (Labs Resulted on `r result_date_text`)*
```{r Chemistry: 24 hour volume lookback, echo = FALSE, warning = FALSE, message = FALSE}
if (cp_eval){
  chem_vol_table <- summarize_cp_vol(x = cp_summary,
                                     lab_division = "Chemistry")
  
  kable_cp_vol(chem_vol_table)

} else {
  asis_output(
    paste("<i><b><span style='color:red'>",
          "Missing Sunquest and/or SCC data. Please check that file is saved properly.",
          "</span style='color:red'></b></i>"))
}
```

### Hematology
#### *Hematology Resulted Lab Volume (Labs Resulted on `r result_date_text`)*
```{r Hematology: 24 hour volume lookback, echo = FALSE, warning = FALSE, message = FALSE}
if (cp_eval){
  hem_vol_table <- summarize_cp_vol(x = cp_summary,
                                    lab_division = "Hematology")
  
  kable_cp_vol(hem_vol_table)

} else {
  asis_output(
    paste("<i><b><span style='color:red'>",
          "Missing Sunquest and/or SCC data. Please check that file is saved properly.",
          "</span style='color:red'></b></i>"))
}
```

### Infusion
#### *Infusion Resulted Lab Volume (Labs Resulted on `r result_date_text`)*
```{r Infusion: 24 hour volume lookback, echo = FALSE, warning = FALSE, message = FALSE}
if (cp_eval){
  inf_vol_table <- summarize_cp_vol(x = cp_summary,
                                    lab_division = "Infusion")
  
  kable_cp_vol(inf_vol_table)

} else {
  asis_output(
    paste("<i><b><span style='color:red'>",
          "Missing Sunquest and/or SCC data. Please check that file is saved properly.",
          "</span style='color:red'></b></i>"))
}
```

### Surgical Pathology
#### *Surgical Pathology Signed Out Case Volume (Signed Out on `r result_date_text`)*
```{r Surgical Pathology: Volume of signed out cases, echo=FALSE, warning=FALSE, message=FALSE}

if (ap_eval){
  stratified_volume_surgical_pathology_24 <- table_formatting_volume(stratified_volume_surgical_pathology_24, "SURGICAL PATHOLOGY")

  stratified_volume_surgical_pathology_24
} else {
  asis_output(
    paste("<i><b><span style='color:red'>",
          "Missing Powerpath/EPIC/Backlog Data. Please check that files are saved properly.",
          "</span style='color:red'></b></i>"))
}
```

### Cytology
#### *Cytology Accessioned Cases and Backlog Volume (As of `r result_date_text`)*
```{r Cytology Backlog and Accessioned case volume, echo=FALSE, warning=FALSE, message=FALSE}
if (ap_eval){
  backlog_cytlogy <- table_formatting_volume_backlog(backlog_cytlogy)
  backlog_cytlogy
} else {
  asis_output(
    paste("<i><b><span style='color:red'>",
          "Missing Powerpath/EPIC/Backlog Data. Please check that files are saved properly.",
          "</span style='color:red'></b></i>"))
}
```

#### *Cytology Signed Out Cases Volume (As of `r result_date_text`)*
```{r Cytology Signed Out Cases, echo=FALSE, warning=FALSE, message=FALSE}

if (ap_eval){
  stratified_volume_cytology_24 <- table_formatting_volume(stratified_volume_cytology_24, "CYTOLOGY")
  stratified_volume_cytology_24

} else {
  asis_output(
    paste("<i><b><span style='color:red'>",
          "Missing Powerpath/EPIC/Backlog Data. Please check that files are saved properly.",
          "</span style='color:red'></b></i>"))
}

```

## **Assumptions and Methodology** {.tabset .tabset-fade .tabset-pills}
### Definitions
<h4><b>Definition table</b></h4>
The table below summarizes the definitions for some of the terminology used in this dashboard for clarification purposes. 

```{r format table for definitions}

definition_table <-
  data.frame(read_excel(reference_file, sheet = "Definitions"),
             stringsAsFactors = FALSE)

definition_table  %>%
  kable(format = "html", escape = FALSE, align = "c",
        col.names = c("Terminology Used", "Terminology Definition")) %>%
  kable_styling(bootstrap_options = "hover", position = "center",
                font_size = 11, full_width = FALSE) %>%
  column_spec(column = c(1, 2), border_right = "thin solid lightgray") %>%
  row_spec(row = 0, font_size = 13, background = "#221f72", color = "white")

```

### Clinical Pathology

<h4><b>Data Sources</b></h4>
MSH and MSQ: Based on daily SCC report. Report name changes daily but follows structure of "DocMM-DD_xxxxxx.xlsx"</br>
MSBI, MSB, MSW, MSM: Based on daily Sunquest report titled "KPI_Daily_TAT_Report_Updated.xls"</br>
The table below summarizes the test codes and IDs used from these daily reports.

```{r Create and format a table for test codes}

test_codes_kable <- full_join(cp_scc_test_codes, cp_sun_test_codes,
                              by = c("TEST" = "TEST",
                                     "DIVISION" = "DIVISION"))

test_codes_kable <- test_codes_kable %>%
  select(DIVISION, TEST, SCC_TEST_ID, SUN_TEST_CODE) %>%
  mutate(TEST = factor(TEST, levels = cp_micro_lab_order, ordered = TRUE)) %>%
  arrange(TEST)

test_codes_kable %>%
  kable(format = "html", escape = FALSE, align = "c",
        col.names = c("Lab Division", "Test", "SCC Test ID",
                      "Sunquest Test Code")) %>%
  kable_styling(bootstrap_options = "hover", position = "center",
                font_size = 11, full_width = FALSE) %>%
  column_spec(column = c(1, 2, 3, 4), border_right = "thin solid lightgray") %>%
  row_spec(row = 0, font_size = 13, background = "#221f72", color = "white") %>%
  collapse_rows()

```

<h4><b>Target Turnaround Times</b></h4>
The table below summarizes target turnaround times as agreed upon by clinical and operational leadership. 
```{r Create and format tables for TAT targets }

tat_targets_kable <- cp_tat_targets %>%
  select(DIVISION, TEST,
         PRIORITY, PT_SETTING,
         RECEIVE_TO_RESULT_TARGET, COLLECT_TO_RESULT_TARGET) %>%
  mutate(DIVISION = factor(DIVISION, levels = cp_division_order, ordered = TRUE),
         TEST = factor(TEST, levels = cp_micro_lab_order, ordered = TRUE),
         PRIORITY = factor(PRIORITY, levels = dashboard_priority_order,
                           ordered = TRUE)) %>%
  arrange(DIVISION, TEST, PRIORITY)

tat_targets_kable <- tat_targets_kable %>%
  mutate(Concate = NULL)

tat_targets_kable %>%
  kable(format = "html", escape = FALSE, align = "c",
        col.names = c("Division", "Test", "Priority", "Patient Setting",
                      "Receive to Result TAT Target (min)",
                      "Collect to Result TAT Target (min)"),
        caption = "Target Turnaround Times") %>%
  kable_styling(bootstrap_options = "hover", position = "center",
                font_size = 11, full_width = FALSE) %>%
  column_spec(column = c(1:ncol(tat_targets_kable)), border_right = "thin solid lightgray") %>%
  row_spec(row = 0, font_size = 13, background = "#221f72", color = "white")

```

<h4><b>Additional notes on target turnaround times:</b></h4>
  
* Troponin and Lactate WB:
    + All labs are treated as stat regardless of documented priority and patient setting.
    + Ambulatory labs excluded from turnaround time analysis
* Rapid Flu:
    + All labs are treated as stat regardless of documented priority and patient setting.
* C. diff:
    + All labs are treated as stat regardless of documented priority and patient setting.
    + Turnaround time for ambulatory C. diff tests are not tracked but rather volume of these labs is monitored.

<h4><b>Turnaround Time Exclusions</b></h4>
  
Turnaround time analysis excludes labs with out of order steps (ie, collect after receive), missing timestamps, add-on orders, and labs not originating in IP, ED, or ambulatory settings (ie, Outreach).

MSH turnaround times exclude BUN and HGB labs collected at RTC.

<br>
  
<h4><b>Add On Orders</b></h4>
Add on orders are defined as labs with an order time more than 5 minutes after receive time. These labs are excluded from turnaround time analysis but the volume of these labs is monitored.

<br>
  
<h4><b>Missing Collections</b></h4>
Labs are classified as missing collections based on the following criteria:
  
* SCC: Collection time equal to receive time
* Sunquest: Collection time equal to order time

### Anatomic Pathology
<h4><b>Target Turnaround Times</b></h4>
The table below summarizes target turnaround times for Anatomic Pathology as agreed upon by clinical and operational leadership. 

```{r Target Turnaround Times Table}

# tat_targets_ap  %>%
#   kable(format = "html", escape = FALSE, align = "c",
#         col.names = c("Test", "Patient Setting",
#                       "Receive to Result TAT Target (days)",
#                       "Collect to Result TAT Target (days)")) %>%
#   kable_styling(bootstrap_options = "hover", position = "center",
#                 font_size = 11, full_width = FALSE) %>%
#   column_spec(column = c(1, 2, 3, 4), border_right = "thin solid lightgray") %>%
#   row_spec(row = 0, font_size = 13, background = "#221f72", color = "white") %>%
#   collapse_rows(columns = 1)

```


<h4><b>Inclusion and Exclusion Criteria for GI Specimens</b></h4>
The table below summarizes the GI codes that were included vs. excluded during the TAT and volume calculations as agreed upon by clinical and operational leadership.
<br>
Only the codes for GI biopsies are included in the analysis.

```{r GI Codes Table}
# gi_codes_updated <-
#   gi_codes[, c("GI_Code_InclExcl",
#                "Spec_code")]
# 
# gi_codes_updated  %>%
#   kable(format = "html", escape = FALSE, align = "c",
#         col.names = c("Specimen Code", "Included vs. Excluded Codes")) %>%
#   kable_styling(bootstrap_options = "hover", position = "center",
#                 font_size = 11, full_width = FALSE) %>%
#   column_spec(column = c(1, 2), border_right = "thin solid lightgray") %>%
#   row_spec(row = 0, font_size = 13, background = "#221f72",
#            color = "white") %>%
#   collapse_rows(columns = 1)
```

<h4><b>Additional notes on target turnaround times:</b></h4>
  
* Receive to Result TAT: for anatomic pathology this metric only includes MSHS business days and is a measure of internal laboratory performance.

* Collect to Result TAT: for anatomic pathology this metric includes all calendar days and is a patient-centric measure of performance.

* At this phase, target turnaround times for collect to result have not been established. This metric will be tracked in order to understand current performance and establish future targets.

* Primary Specimens: When a specimen has multiple slides, only the first slide is included. The primary slide is identified as those with spec_sort_order = A.

* All Breast Specimens:
    + Included all the primary breast specimens only. 
    + Only labs from ambulatory and inpatient services with valid time stamps included in TAT calculations.
    + TAT analysis excludes labs with missing timestamps
    + All settings included in the resulted volume

* GI Biopsies:
    + Included only the samples that are consisted of GI biopsies
    + Only primary specimen GI biopsies included
    + Only labs from ambulatory and inpatient services with valid time stamps included in TAT calculations.
    + TAT analysis excludes labs with missing timestamps
    + All settings included in the resulted volume

* Cyto Gyn:
    + TAT and volume analysis were only calculated for Cyto Gyn specimens that were finalized and closed out in EPIC
    + Included all primary Cyto Gyn specimens
    + Only labs from ambulatory and inpatient services with valid time stamps included in TAT calculations.
    + TAT analysis excludes labs with missing timestamps
    + All settings included in the resulted volume

* Cyto Non-Gyn:
    + TAT and volume analysis were only calculated for Cyto non-Gyn specimens that were finalized and closed out in EPIC
    + Included all primary Cyto non-Gyn specimens
    + Only labs from ambulatory and inpatient services with valid time stamps included in TAT calculations.
    + TAT analysis excludes labs with missing timestamps
    + All settings included in the resulted volume

* Backlog Cases:
    + Backlog cases are defined as all the cases that are open by cytology and microbiology.

<h6> *End of report.* </h6>
  