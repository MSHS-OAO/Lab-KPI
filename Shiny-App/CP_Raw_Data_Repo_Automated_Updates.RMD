---
title: "Lab Dashboard - Raw Data Repository Updates"
output:
  html_document
---

## Load libraries
```{r Load libraries and clear environment}
# Code for identifying missing dates of data and updating repositories -----

# Load packages ---------------
library(timeDate)
library(readxl)
library(bizdays)
library(dplyr)
library(lubridate)
library(reshape2)
library(knitr)
# library(gdtools)
# library(kableExtra)
library(kableExtra,  "~/R/x86_64-pc-linux-gnu-library/4.2")
library(formattable)
library(rmarkdown)
library(stringr)
library(writexl)
library(gsubfn)
library(tidyr)
library(here)
library(odbc)
library(dbplyr)
library(DBI)
library(glue)
library(foreach)
library(doParallel)
library(parallel)

#Clear existing history
rm(list = ls())
```

## Root path
```{r Find root path}

# Define root path ---------------
# Function to determine path to share drive on R Workbench or R Studio
define_root_path <- function(){
  #Check if directory is from R Workbench; starts with '/home'
  if(grepl("^/home", dirname(getwd()))){
    #Check if mapped Sharedrvie starts at folder Presidents or deans
    ifelse(list.files("/SharedDrive/") == "Presidents",
           #Define prefix of path to share drive with R Workbench format
           output <- "/SharedDrive/Presidents/", 
           output <- "/SharedDrive/deans/Presidents/")
  }#Check if directory is from R Studio; starts with an uppercase letter than ':'
  else if(grepl("^[[:upper:]]+:", dirname(getwd()))){
    #Determine which drive is mapped to Sharedrive (x)
    for(i in LETTERS){
      if(any(grepl("deans|Presidents", list.files(paste0(i, "://"))))){x <- i}
    }
    #Check if mapped Sharedrvie starts at folder Presidents or deans
    ifelse(list.files(paste0(x, "://")) == "Presidents",
           #Define prefix of path to share drive with R Studio format
           output <- paste0(x, ":/Presidents/"),
           output <- paste0(x, ":/deans/Presidents/"))
    
  }
  return(output)
}

user_directory <- paste0(define_root_path(),
                         "HSPI-PM/",
                         "Operations Analytics and Optimization/Projects/",
                         "Service Lines/Lab Kpi/Data")


```

## Reference data
```{r Connect to OAO Cloud database and import reference data.}
# OAO Cloud Database schema
oao_cloud_db <- "OAO Cloud DB Kate"

# CP Reference Tables -------------------
## Begin connection -------
oao_personal_conn <- dbConnect(odbc(), oao_cloud_db)

## MSHS Sites -----------
cp_mshs_sites <- tbl(oao_personal_conn, "CP_SITE_NAMES") %>%
  collect() %>%
  rename(Site = SITE)

## Test Codes -----------

cp_scc_test_codes <- tbl(oao_personal_conn, "CP_SCC_TEST_CODES") %>%
  collect()

cp_sun_test_codes <- tbl(oao_personal_conn, "CP_SUN_TEST_CODES") %>%
  collect()

## TAT Targets ---------
cp_tat_targets <- tbl(oao_personal_conn, "CP_TAT_TARGETS") %>%
  collect() %>%
  mutate(Concate = ifelse(
    PRIORITY == "All" & PT_SETTING == "All", paste(TEST, DIVISION),
    ifelse(PRIORITY != "All" & PT_SETTING == "All",
           paste(TEST, DIVISION, PRIORITY),
           paste(TEST, DIVISION, PRIORITY, PT_SETTING))))

## Patient Setting and ICU -----------
cp_scc_setting <- tbl(oao_personal_conn, "CP_SCC_CLINIC_TYPE") %>%
  collect()

cp_sun_setting <- tbl(oao_personal_conn, "CP_SUN_LOC_TYPE") %>%
  collect()

cp_scc_icu <- tbl(oao_personal_conn, "CP_SCC_ICU") %>%
  collect() %>%
  mutate(SiteCodeName = paste(SITE, WARD, WARD_NAME))

cp_sun_icu <- tbl(oao_personal_conn, "CP_SUN_ICU") %>%
  collect() %>%
  mutate(SiteCodeName = paste(SITE, LOC_CODE, LOC_NAME))

## Disconnect -----------
dbDisconnect(oao_personal_conn)
```

## 60 days data
```{r Connect to database repository tables and find missing dates and files}
# Raw Data 60 Days ---------
## Query raw data repo -------

today <- Sys.Date()

last_60_days <- data.frame(DATE = 
                         seq.Date(from = today - 60, to = today - 1, by = 1)
)

## Table names -----------
raw_data_temp_table <- "CP_RAW_DATA_60DAYS_TEMP"
raw_data_repo_table <- "CP_RAW_DATA_60DAYS"
# raw_data_repo_table <- "TEST_OUTPUT_MESSAGES"

# Keep only last 60 days of data
remove_dates_query <- glue(
  "DELETE FROM {raw_data_repo_table} where
    (RESULT_DATE < TO_DATE('{min(last_60_days$DATE)}', 'YYYY-MM-DD'));")

# remove_dates_query <- glue(
#   "DELETE FROM {raw_data_repo_table} where
#   (RESULT_DATE > (TO_DATE('{today}', 'YYYY-MM-DD') - 4));")

oao_personal_conn <- dbConnect(odbc(), oao_cloud_db)

# Remove data more than 60 days ago from repository
dbBegin(oao_personal_conn)
dbExecute(oao_personal_conn, remove_dates_query)
dbCommit(oao_personal_conn)

scc_raw_data_repo_dates <-tbl(oao_personal_conn, raw_data_repo_table) %>%
  filter(SITE %in% c("MSQ", "MSH")) %>%
  select(RESULT_DATE) %>%
  distinct() %>%
  collect() %>%
  mutate(RESULT_DATE = as.Date(RESULT_DATE)) %>%
  arrange(RESULT_DATE)

sun_raw_data_repo_dates <-tbl(oao_personal_conn, raw_data_repo_table) %>%
  filter(!(SITE %in% c("MSQ", "MSH"))) %>%
  select(RESULT_DATE) %>%
  distinct() %>%
  collect() %>%
  mutate(RESULT_DATE = as.Date(RESULT_DATE)) %>%
  arrange(RESULT_DATE)

dbDisconnect(oao_personal_conn)

scc_folder <- paste0(user_directory,
                        "/SCC CP Reports")

scc_missing_data <- last_60_days %>%
  mutate(MissingInDB = !(DATE %in% scc_raw_data_repo_dates$RESULT_DATE)) %>%
  filter(MissingInDB) %>%
  select(DATE) %>%
  mutate(REPORT_DATE = DATE + 1)

if (nrow(scc_missing_data) > 0){
  missing_scc_files <- list.files(scc_folder,
                                  pattern = paste0(
                                    "^(Doc).+(",
                                    paste0(scc_missing_data$REPORT_DATE, collapse = "|"),
                                    ").xlsx$"))
} else {
  missing_scc_files <- NULL
}

sun_folder <- paste0(user_directory, "/SUN CP Reports")

sun_missing_data <- last_60_days %>%
  mutate(MissingInDB = !(DATE %in% sun_raw_data_repo_dates$RESULT_DATE)) %>%
  filter(MissingInDB) %>%
  select(DATE) %>%
  mutate(REPORT_DATE = DATE + 1)

if (nrow(sun_missing_data) > 0) {
  missing_sun_files <- list.files(sun_folder,
                                  pattern = paste0(
                                    "^(KPI_Daily_TAT_Report_Updated )",
                                    paste0(sun_missing_data$REPORT_DATE, collapse = "|"),
                                    ".xls$"))
} else {
  missing_sun_files <- NULL
}

if (length(missing_scc_files) > 0) {
  scc_raw_reports <- lapply(
    missing_scc_files, function(x) read_excel(
      path = paste0(scc_folder, "/", x)
    )
  )
} else {
  scc_raw_reports <- NULL
  # print("No new SCC reports found.")
}

if (length(missing_sun_files) > 0) {
  sun_raw_reports <- lapply(
    missing_sun_files, function(x) 
      read_excel(
        path = paste0(sun_folder, "/", x),
        col_types = c("text", "text", "text", "text", "text",
                      "text", "text", "text", "text",
                      "numeric", "numeric", "numeric", "numeric", "numeric",
                      "text", "text", "text", "text", "text",
                      "text", "text", "text", "text", "text",
                      "text", "text", "text", "text", "text",
                      "text", "text", "text", "text", "text", "text")
      )
  )
} else {
  sun_raw_reports <- NULL
  print("No new Sunquest reports found.")
}
```

## SCC preprocessing function
```{r Custom function for preprocessing SCC reports}

# Custom function for preprocessing SCC data ---------------------------------
preprocess_scc <- function(raw_scc)  {
  # Preprocess SCC data -------------------------------
  # Remove any duplicates
  raw_scc <- unique(raw_scc)
  # Correct and format any columns that were not imported correctly; usually have a message saying "*failed to decode... *"
  # raw_scc[c("ORDERING_DATE",
  #           "COLLECTION_DATE",
  #           "RECEIVE_DATE",
  #           "VERIFIED_DATE")] <-
  #   lapply(raw_scc[c("ORDERING_DATE",
  #                    "COLLECTION_DATE",
  #                    "RECEIVE_DATE",
  #                    "VERIFIED_DATE")],
  #          function(x)
  #            ifelse(!is.na(x) & str_detect(x, "\\*.*\\*"),
  #                   str_replace(x, "\\*.*\\*", ""), x))
  # 
  raw_scc <- raw_scc %>%
    mutate(across(where(is.character), gsub,
                  pattern = "\\*.*\\*",
                  replacement = ""))
  
  raw_scc[c("ORDERING_DATE",
            "COLLECTION_DATE",
            "RECEIVE_DATE",
            "VERIFIED_DATE")] <-
    lapply(raw_scc[c("ORDERING_DATE",
                     "COLLECTION_DATE",
                     "RECEIVE_DATE",
                     "VERIFIED_DATE")],
           as.POSIXct, tz = "UTC",
           format = "%Y-%m-%d %H:%M:%OS",
           options(digits.sec = 1))
  
  # SCC lookup references ----------------------------------------------
  # Crosswalk in scope labs
  raw_scc <- left_join(raw_scc,
                       cp_scc_test_codes,
                       by = c("TEST_ID" = "SCC_TEST_ID"))
  
  # Determine if test is included based on crosswalk results
  raw_scc <- raw_scc %>%
    mutate(TestIncl = !is.na(TEST)) %>%
    filter(TestIncl)
  
  # Crosswalk unit type
  raw_scc <- left_join(raw_scc, cp_scc_setting,
                       by = c("CLINIC_TYPE" = "CLINIC_TYPE"))
  # Crosswalk site name
  raw_scc <- left_join(raw_scc, cp_mshs_sites,
                       by = c("SITE" = "DATA_SITE"))
  
  # Preprocess SCC data and add any necessary columns
  raw_scc <- raw_scc %>%
    mutate(
      # Subset HGB and BUN tests completed at RTC as a separate site since they
      # are processed at RTC
      Site = ifelse(TEST %in% c("HGB", "BUN") &
                      str_detect(replace_na(WARD_NAME, ""),
                                 "Ruttenberg Treatment Center"),
                    "RTC", Site),
      # Update division to Infusion for RTC
      DIVISION = ifelse(Site %in% c("RTC"), "Infusion", DIVISION),
      # Determine if unit is an ICU based on site mappings
      ICU = paste(Site, Ward, WARD_NAME) %in% cp_scc_icu$SiteCodeName,
      # Create a column for resulted date
      RESULT_DATE = date(VERIFIED_DATE),
      # Create master setting column to identify ICU and IP Non-ICU units
      DETAILED_SETTING = ifelse(SETTING_ROLL_UP == "IP" & ICU, "ICU",
                             ifelse(SETTING_ROLL_UP == "IP" & !ICU,
                                    "IP Non-ICU", SETTING_ROLL_UP)),
      # Create dashboard setting column to roll up master settings based on
      # desired dashboard grouping (ie, group ED and ICU together)
      DASHBOARD_SETTING = ifelse(DETAILED_SETTING %in% c("ED", "ICU"),
                                "ED & ICU", DETAILED_SETTING),
      # Create column with adjusted priority based on assumption that all ED and
      # ICU labs are treated as stat per operational leadership
      ADJ_PRIORITY = ifelse(DETAILED_SETTING %in% c("ED", "ICU") |
                             PRIORITY %in% "S", "Stat", "Routine"),
      # Calculate turnaround times
      COLLECT_TO_RECEIVE_TAT =
        as.numeric(RECEIVE_DATE - COLLECTION_DATE, units = "mins"),
      RECEIVE_TO_RESULT_TAT =
        as.numeric(VERIFIED_DATE - RECEIVE_DATE, units = "mins"),
      COLLECT_TO_RESULT_TAT =
        as.numeric(VERIFIED_DATE - COLLECTION_DATE, units = "mins"),
      #
      # Determine if order was an add on or original order based on time between
      # order and receive times
      ADD_ON_FINAL = ifelse(as.numeric(ORDERING_DATE - RECEIVE_DATE,
                                      units = "mins")
                           > 5, "AddOn", "Original"),
      # Determine if collection time is missing
      MISSING_COLLECT = COLLECTION_DATE %in% RECEIVE_DATE, # COLLECT_TO_RECEIVE_TAT %in% 0,
      #
      # Determine TAT based on test, division, priority, and patient setting
      # Create column concatenating test and division to determine TAT targets
      Concate1 = paste(TEST, DIVISION),
      #
      # Create dashboard priority column
      DASHBOARD_PRIORITY = ifelse(
        cp_tat_targets$PRIORITY[match(
          Concate1, 
          paste(cp_tat_targets$TEST, cp_tat_targets$DIVISION))] == "All",
        "All", ADJ_PRIORITY),
      # Create column concatenating test, division, and priority to determine
      # TAT targets
      Concate2 = paste(TEST, DIVISION, DASHBOARD_PRIORITY),
      # Create column concatenating test, division, priority, and setting to
      # determine TAT targets
      Concate3 = paste(TEST, DIVISION, DASHBOARD_PRIORITY, DETAILED_SETTING),
      #
      # Determine Receive to Result TAT target using this logic:
      # 1. Try to match test, division, priority, and setting (applicable for
      # labs with different TAT targets based on patient setting and order priority)
      # 2. Try to match test, division, and priority (applicable for labs with
      # different TAT targets based on order priority)
      # 3. Try to match test and division - (applicable for labs with
      # TAT targets that are independent of patient setting or priority)
      #
      # Determine Receive to Result TAT target based on above logic/scenarios
      RECEIVE_RESULT_TARGET =
        # Match on scenario 1
        ifelse(!is.na(match(Concate3, cp_tat_targets$Concate)),
               cp_tat_targets$RECEIVE_TO_RESULT_TARGET[
                 match(Concate3, cp_tat_targets$Concate)],
               # Match on scenario 2
               ifelse(!is.na(match(Concate2, cp_tat_targets$Concate)),
                      cp_tat_targets$RECEIVE_TO_RESULT_TARGET[
                        match(Concate2, cp_tat_targets$Concate)],
                      # Match on scenario 3
                      cp_tat_targets$RECEIVE_TO_RESULT_TARGET[
                        match(Concate1, cp_tat_targets$Concate)])),
      #
      # Determine Collect to Result TAT target based on above logic/scenarios
      COLLECT_RESULT_TARGET =
        # Match on scenario 1
        ifelse(!is.na(match(Concate3, cp_tat_targets$Concate)),
               cp_tat_targets$COLLECT_TO_RESULT_TARGET[
                 match(Concate3, cp_tat_targets$Concate)],
               # Match on scenario 2
               ifelse(!is.na(match(Concate2, cp_tat_targets$Concate)),
                      cp_tat_targets$COLLECT_TO_RESULT_TARGET[
                        match(Concate2, cp_tat_targets$Concate)],
                      # Match on scenario 3
                      cp_tat_targets$COLLECT_TO_RESULT_TARGET[
                        match(Concate1, cp_tat_targets$Concate)])),
      #
      # Determine if Receive to Result and Collect to Result TAT meet targets
      RECEIVE_RESULT_IN_TARGET = ifelse(is.na(RECEIVE_TO_RESULT_TAT), FALSE,
                                        RECEIVE_TO_RESULT_TAT <= RECEIVE_RESULT_TARGET),
      COLLECT_RESULT_IN_TARGET = ifelse(is.na(COLLECT_TO_RESULT_TAT), FALSE,
                                        COLLECT_TO_RESULT_TAT <= COLLECT_RESULT_TARGET),
      # Create column with patient name, order ID, test, collect, receive, and
      # result date and determine if there is a duplicate; order time excluded
      Concate4 = paste(LAST_NAME, FIRST_NAME,
                       ORDER_ID, TEST_NAME,
                       COLLECTION_DATE, RECEIVE_DATE, VERIFIED_DATE),
      DuplTest = duplicated(Concate4),
      # Determine whether or not to include this particular lab in TAT analysis
      # Exclusion criteria:
      # 1. Add on orders
      # 2. Orders from "Other" settings
      # 3. Orders with collect or receive times after result time
      # 4. Orders with missing collect, receive, or result timestamps
      # 5. Orders with missing collection times are excluded from
      # collect-to-result and collect-to-receive turnaround time analyis
      RECEIVE_TIME_TAT_INCL = ifelse(ADD_ON_FINAL == "AddOn" |
                                       DETAILED_SETTING == "Other" |
                                       COLLECT_TO_RECEIVE_TAT < 0 |
                                       COLLECT_TO_RESULT_TAT < 0 |
                                       RECEIVE_TO_RESULT_TAT < 0 |
                                       is.na(COLLECT_TO_RESULT_TAT) |
                                       is.na(RECEIVE_TO_RESULT_TAT), FALSE, TRUE),
      COLLECT_TIME_TAT_INCL = ifelse(MISSING_COLLECT |
                                        ADD_ON_FINAL == "AddOn" |
                                        DETAILED_SETTING == "Other" |
                                        COLLECT_TO_RECEIVE_TAT < 0 |
                                        COLLECT_TO_RESULT_TAT < 0 |
                                        RECEIVE_TO_RESULT_TAT < 0 |
                                        is.na(COLLECT_TO_RESULT_TAT) |
                                        is.na(RECEIVE_TO_RESULT_TAT), FALSE, TRUE))
  
  # Remove duplicate tests
  raw_scc <- raw_scc %>%
    filter(!DuplTest)
  
  # Determine volume of labs associated with each date and identify correct date
  scc_resulted_dates_vol <- raw_scc %>%
    group_by(RESULT_DATE) %>%
    summarize(VolLabs = n()) %>%
    arrange(desc(VolLabs)) %>%
    ungroup()
  
  scc_correct_date <- scc_resulted_dates_vol$RESULT_DATE[1]
  
  raw_scc <- raw_scc %>%
    filter(RESULT_DATE %in% scc_correct_date)
  
  # Select columns
  scc_processed <- raw_scc %>%
    select(Ward, WARD_NAME, ORDER_ID, `REQUESTING_DOC NAME`, MPI, `WORK SHIFT`,
           TEST_NAME, TEST, DIVISION, PRIORITY,
           Site, ICU, CLINIC_TYPE,
           SETTING, SETTING_ROLL_UP, DETAILED_SETTING, DASHBOARD_SETTING,
           ADJ_PRIORITY, DASHBOARD_PRIORITY,
           ORDERING_DATE, COLLECTION_DATE, RECEIVE_DATE, VERIFIED_DATE,
           RESULT_DATE,
           COLLECT_TO_RECEIVE_TAT, RECEIVE_TO_RESULT_TAT, COLLECT_TO_RESULT_TAT,
           ADD_ON_FINAL, MISSING_COLLECT,
           RECEIVE_RESULT_TARGET, COLLECT_RESULT_TARGET,
           RECEIVE_RESULT_IN_TARGET, COLLECT_RESULT_IN_TARGET,
           RECEIVE_TIME_TAT_INCL, COLLECT_TIME_TAT_INCL
    ) %>%
    rename(LOC_CODE = Ward,
           LOC_NAME = WARD_NAME,
           REQUEST_MD = `REQUESTING_DOC NAME`,
           MSMRN = MPI,
           WORK_SHIFT = `WORK SHIFT`,
           ORDER_PRIORITY = PRIORITY,
           SITE = Site,
           LOC_TYPE = CLINIC_TYPE,
           ORDER_TIME = ORDERING_DATE,
           COLLECT_TIME = COLLECTION_DATE,
           RECEIVE_TIME = RECEIVE_DATE,
           RESULT_TIME = VERIFIED_DATE)
  
  return(scc_processed)
  
}
```

## Sunquest preprocessing function
```{r Custom function for preprocessing Sunquest reports}

# Custom function for preprocessing Sunquest data -----------------
preprocess_sun <- function(raw_sun) {
  
  # Preprocess Sunquest data --------------------------------
  # Remove any duplicates
  raw_sun <- unique(raw_sun)
  # Correct and format any columns that were not imported correctly; usually have a message saying "*failed to decode... *"  # raw_sun[c("OrderDateTime",
  #           "CollectDateTime",
  #           "ReceiveDateTime",
  #           "ResultDateTime")] <-
  #   lapply(raw_sun[c("OrderDateTime",
  #                    "CollectDateTime",
  #                    "ReceiveDateTime",
  #                    "ResultDateTime")],
  #          function(x) ifelse(!is.na(x) & str_detect(x, "\\*.*\\*")  == TRUE,
  #                             str_replace(x, "\\*.*\\*", ""), x))
  # 
  raw_sun <- raw_sun %>%
    mutate(across(where(is.character), gsub,
                  pattern = "\\*.*\\*",
                  replacement = ""))
  
  raw_sun[c("OrderDateTime",
            "CollectDateTime",
            "ReceiveDateTime",
            "ResultDateTime")] <-
    lapply(raw_sun[c("OrderDateTime",
                     "CollectDateTime",
                     "ReceiveDateTime",
                     "ResultDateTime")],
           as.POSIXct, tz = "UTC", format = "%m/%d/%Y %H:%M:%S")
  
  # Sunquest lookup references
  # Crosswalk labs included and remove out of scope labs
  raw_sun <- left_join(raw_sun, cp_sun_test_codes,
                       by = c("TestCode" = "SUN_TEST_CODE"))
  
  # Determine if test is included based on crosswalk results
  raw_sun <- raw_sun %>%
    mutate(TestIncl = !is.na(TEST)) %>%
    filter(TestIncl)
  
  
  # Crosswalk unit type
  raw_sun <- left_join(raw_sun, cp_sun_setting,
                       by = c("LocType" = "LOC_TYPE"))
  
  # Crosswalk site name
  raw_sun <- left_join(raw_sun, cp_mshs_sites,
                       by = c("HospCode" = "DATA_SITE"))
  
  # # Sunquest data formatting-----------------------------
  # Preprocess Sunquest data and add any necessary columns
  raw_sun <- raw_sun %>%
    mutate(
      # Determine if unit is an ICU based on site mappings
      ICU = paste(Site, LocCode, LocName) %in% cp_sun_icu$SiteCodeName,
      # Create a column for resulted date
      RESULT_DATE = as.Date(ResultDateTime, format = "%m/%d/%Y"),
      # Create master setting column to identify ICU and IP Non-ICU units
      DETAILED_SETTING = ifelse(SETTING_ROLL_UP == "IP" & ICU, "ICU",
                                ifelse(SETTING_ROLL_UP == "IP" & !ICU,
                                       "IP Non-ICU", SETTING_ROLL_UP)),
      # Create dashboard setting column to roll up master settings based on
      # desired dashboard grouping(ie, group ED and ICU together)
      DASHBOARD_SETTING = ifelse(DETAILED_SETTING %in% c("ED", "ICU"),
                                 "ED & ICU", DETAILED_SETTING),
      #
      # Create column with adjusted priority based on operational assumption
      # that all ED and ICU labs are treated as stat
      ADJ_PRIORITY = ifelse(DETAILED_SETTING %in% c("ED", "ICU") |
                             SpecimenPriority %in% "S", "Stat", "Routine"),
      #
      # Calculate turnaround times
      COLLECT_TO_RECEIVE_TAT =
        round(as.numeric(ReceiveDateTime - CollectDateTime, units = "mins"),
              digits = 3),
      RECEIVE_TO_RESULT_TAT =
        round(as.numeric(ResultDateTime - ReceiveDateTime, units = "mins"),
              digits = 3),
      COLLECT_TO_RESULT_TAT =
        round(as.numeric(ResultDateTime - CollectDateTime, units = "mins"),
              digits = 3),
      #
      # Determine if order was an add on or original order based on time between
      # order and receive times
      ADD_ON_FINAL = ifelse(as.numeric(OrderDateTime - ReceiveDateTime,
                                      units = "mins") > 5, "AddOn", "Original"),
      #
      # Determine if collection time is missing
      MISSING_COLLECT = CollectDateTime %in% OrderDateTime,
      #
      # Determine TAT target based on test, priority, and patient setting
      # Create column concatenating test and division to determine TAT targets
      Concate1 = paste(TEST, DIVISION),
      #
      # Create dashboard priority column
      DASHBOARD_PRIORITY = ifelse(
        cp_tat_targets$PRIORITY[match(
          Concate1,
          paste(cp_tat_targets$TEST, cp_tat_targets$DIVISION))] == "All",
        "All", ADJ_PRIORITY),
      # Create column concatenating test, division, and priority to determine
      # TAT targets
      Concate2 = paste(TEST, DIVISION, DASHBOARD_PRIORITY),
      # Create column concatenating test, division, priority, and setting to
      # determine TAT targets
      Concate3 = paste(TEST, DIVISION, DASHBOARD_PRIORITY, DETAILED_SETTING),
      #
      # Determine Receive to Result TAT target using this logic:
      # 1. Try to match test, priority, and setting (applicable for labs with
      # different TAT targets based on patient setting and order priority)
      # 2. Try to match test and priority (applicable for labs with different
      # TAT targets based on order priority)
      # 3. Try to match test - this is for tests with (applicable for labs with
      # TAT targets that are independent of patient setting or priority)
      #
      # Determine Receive to Result TAT target based on above logic/scenarios
      RECEIVE_RESULT_TARGET =
        # Match on scenario 1
        ifelse(!is.na(match(Concate3, cp_tat_targets$Concate)),
               cp_tat_targets$RECEIVE_TO_RESULT_TARGET[
                 match(Concate3, cp_tat_targets$Concate)],
               # Match on scenario 2
               ifelse(!is.na(match(Concate2, cp_tat_targets$Concate)),
                      cp_tat_targets$RECEIVE_TO_RESULT_TARGET[
                        match(Concate2, cp_tat_targets$Concate)],
                      # Match on scenario 3
                      cp_tat_targets$RECEIVE_TO_RESULT_TARGET[
                        match(Concate1, cp_tat_targets$Concate)])),
      #
      # Determine Collect to Result TAT target based on above logic/scenarios
      COLLECT_RESULT_TARGET =
        # Match on scenario 1
        ifelse(!is.na(match(Concate3, cp_tat_targets$Concate)),
               cp_tat_targets$COLLECT_TO_RESULT_TARGET[
                 match(Concate3, cp_tat_targets$Concate)],
               # Match on scenario 2
               ifelse(!is.na(match(Concate2, cp_tat_targets$Concate)),
                      cp_tat_targets$COLLECT_TO_RESULT_TARGET[
                        match(Concate2, cp_tat_targets$Concate)],
                      # Match on scenario 3
                      cp_tat_targets$COLLECT_TO_RESULT_TARGET[
                        match(Concate1, cp_tat_targets$Concate)])),
      #
      # Determine if Receive to Result and Collect to Result TAT meet targets
      RECEIVE_RESULT_IN_TARGET = ifelse(is.na(RECEIVE_TO_RESULT_TAT), FALSE,
                                        RECEIVE_TO_RESULT_TAT <= RECEIVE_RESULT_TARGET),
      COLLECT_RESULT_IN_TARGET = ifelse(is.na(COLLECT_TO_RESULT_TAT), FALSE,
                                        COLLECT_TO_RESULT_TAT <= COLLECT_RESULT_TARGET),
      #
      # Create column with patient name, order ID, test, collect, receive, and
      # result date and determine if there is a duplicate; order time excluded
      Concate4 = paste(PtNumber, HISOrderNumber, TSTName,
                       CollectDateTime, ReceiveDateTime, ResultDateTime),
      DuplTest = duplicated(Concate4),
      #
      # Determine whether or not to include this particular lab in TAT analysis
      # Exclusion criteria:
      # 1. Add on orders
      # 2. Orders from "Other" settings
      # 3. Orders with collect or receive times after result time
      # 4. Orders with missing collect, receive, or result timestamps
      # 5. Orders with missing collection times are excluded from
      # collect-to-result and collect-to-receive turnaround time analyis
      RECEIVE_TIME_TAT_INCL = ifelse(ADD_ON_FINAL == "AddOn" |
                                       DETAILED_SETTING == "Other" |
                                       COLLECT_TO_RECEIVE_TAT < 0 |
                                       COLLECT_TO_RESULT_TAT < 0 |
                                       RECEIVE_TO_RESULT_TAT < 0 |
                                       is.na(COLLECT_TO_RESULT_TAT) |
                                       is.na(RECEIVE_TO_RESULT_TAT), FALSE, TRUE),
      COLLECT_TIME_TAT_INCL = ifelse(MISSING_COLLECT |
                                        ADD_ON_FINAL == "AddOn" |
                                        DETAILED_SETTING == "Other" |
                                        COLLECT_TO_RECEIVE_TAT < 0 |
                                        COLLECT_TO_RESULT_TAT < 0 |
                                        RECEIVE_TO_RESULT_TAT < 0 |
                                        is.na(COLLECT_TO_RESULT_TAT) |
                                        is.na(RECEIVE_TO_RESULT_TAT), FALSE, TRUE))
  
  # Remove duplicate tests
  raw_sun <- raw_sun %>%
    filter(!DuplTest)
  
  # Determine volume of labs associated with each date and identify correct date
  sun_resulted_dates_vol <- raw_sun %>%
    group_by(RESULT_DATE) %>%
    summarize(VolLabs = n()) %>%
    arrange(desc(VolLabs)) %>%
    ungroup()
  
  sun_correct_date <- sun_resulted_dates_vol$RESULT_DATE[1]
  
  raw_sun <- raw_sun %>%
    filter(RESULT_DATE %in% sun_correct_date)
  
  # Select columns
  sun_processed <- raw_sun %>%
    select(LocCode, LocName,
           HISOrderNumber, PhysName,
           PtNumber, SHIFT,
           TSTName, TEST, DIVISION, SpecimenPriority,
           Site, ICU, LocType,
           SETTING, SETTING_ROLL_UP,
           DETAILED_SETTING, DASHBOARD_SETTING,
           ADJ_PRIORITY, DASHBOARD_PRIORITY,
           OrderDateTime, CollectDateTime,
           ReceiveDateTime, ResultDateTime,
           RESULT_DATE,
           COLLECT_TO_RECEIVE_TAT, RECEIVE_TO_RESULT_TAT,
           COLLECT_TO_RESULT_TAT,
           ADD_ON_FINAL, MISSING_COLLECT,
           RECEIVE_RESULT_TARGET, COLLECT_RESULT_TARGET,
           RECEIVE_RESULT_IN_TARGET, COLLECT_RESULT_IN_TARGET,
           RECEIVE_TIME_TAT_INCL, COLLECT_TIME_TAT_INCL
    ) %>%
    rename(LOC_CODE = LocCode,
           LOC_NAME = LocName,
           ORDER_ID = HISOrderNumber,
           REQUEST_MD = PhysName,
           MSMRN = PtNumber,
           WORK_SHIFT = SHIFT,
           TEST_NAME = TSTName,
           ORDER_PRIORITY = SpecimenPriority,
           SITE = Site,
           LOC_TYPE = LocType,
           ORDER_TIME = OrderDateTime,
           COLLECT_TIME = CollectDateTime,
           RECEIVE_TIME = ReceiveDateTime,
           RESULT_TIME = ResultDateTime
    )
  
  return(sun_processed)
}
```

## Process missing SCC and Sunquest files
```{r Process SCC and Sunquest reports}

# Process missing SCC and Sunquest files found on shared drive ------
test_new_scc_function <- lapply(
  X = scc_raw_reports, FUN = preprocess_scc
)

if(length(test_new_scc_function) > 0) {
  names(test_new_scc_function) <- paste0("SCC_File_", c(1:length(test_new_scc_function)))
}

test_new_sun_function <- lapply(
  X = sun_raw_reports, FUN = preprocess_sun
)

if(length(test_new_sun_function) > 0) {
  names(test_new_sun_function) <- paste0("Sunquest_File_", c(1:length(test_new_sun_function)))
}
```

## Database queries
```{r Database writing queries and functions}
# Database writing functions ---------------

## Get values function -----------------
get_values_raw_cp_data <- function(x, table_name){
  
  loc_code <- x[1]
  loc_name <- x[2]
  order_id <- x[3]
  request_md <- x[4]
  msmrn <- x[5]
  work_shift <- x[6]
  test_name <- x[7]
  test <- x[8]
  division <- x[9]
  order_priority <- x[10]
  site <- x[11]
  icu <- x[12]
  loc_type <- x[13]
  setting <- x[14]
  setting_roll_up <- x[15]
  detailed_setting <- x[16]
  dashboard_setting <- x[17]
  adj_priority <- x[18]
  dashboard_priority <- x[19]
  order_time <- x[20]
  collect_time <- x[21]
  receive_time <- x[22]
  result_time <- x[23]
  result_date <- x[24]
  collect_to_receive_tat <- x[25]
  receive_to_result_tat <- x[26]
  collect_to_result_tat <- x[27]
  add_on_final <- x[28]
  missing_collect <- x[29]
  receive_result_target <- x[30]
  collect_result_target <- x[31]
  receive_result_in_target <- x[32]
  collect_result_in_target <- x[33]
  receive_time_tat_incl <- x[34]
  collect_time_tat_incl <- x[35]
  
  
  values <- glue(
    "INTO \"{table_name}\" 
    (LOC_CODE,
    LOC_NAME,    
    ORDER_ID,
    REQUEST_MD,
    MSMRN,
    WORK_SHIFT,
    TEST_NAME,
    TEST,
    DIVISION,
    ORDER_PRIORITY,
    SITE,
    ICU,
    LOC_TYPE,
    SETTING,
    SETTING_ROLL_UP,
    DETAILED_SETTING,
    DASHBOARD_SETTING,
    ADJ_PRIORITY,
    DASHBOARD_PRIORITY,
    ORDER_TIME,
    COLLECT_TIME,
    RECEIVE_TIME,
    RESULT_TIME,
    RESULT_DATE,
    COLLECT_TO_RECEIVE_TAT,
    RECEIVE_TO_RESULT_TAT,
    COLLECT_TO_RESULT_TAT,
    ADD_ON_FINAL,
    MISSING_COLLECT,
    RECEIVE_RESULT_TARGET,
    COLLECT_RESULT_TARGET,
    RECEIVE_RESULT_IN_TARGET,
    COLLECT_RESULT_IN_TARGET,
    RECEIVE_TIME_TAT_INCL,
    COLLECT_TIME_TAT_INCL) 
    
    VALUES (
    '{loc_code}',
    '{loc_name}',         
    '{order_id}',
    '{request_md}',
    '{msmrn}',
    '{work_shift}',
    '{test_name}',
    '{test}',
    '{division}',
    '{order_priority}',
    '{site}',
    '{icu}',
    '{loc_type}',
    '{setting}',
    '{setting_roll_up}',
    '{detailed_setting}',
    '{dashboard_setting}',
    '{adj_priority}',
    '{dashboard_priority}',
    TO_TIMESTAMP('{order_time}', 'YYYY-MM-DD HH24:MI:SS'),
    TO_TIMESTAMP('{collect_time}', 'YYYY-MM-DD HH24:MI:SS'),
    TO_TIMESTAMP('{receive_time}', 'YYYY-MM-DD HH24:MI:SS'),
    TO_TIMESTAMP('{result_time}', 'YYYY-MM-DD HH24:MI:SS'),
    TO_DATE('{result_date}', 'YYYY-MM-DD'),
    '{collect_to_receive_tat}',
    '{receive_to_result_tat}',
    '{collect_to_result_tat}',
    '{add_on_final}',
    '{missing_collect}',
    '{receive_result_target}',
    '{collect_result_target}',
    '{receive_result_in_target}',
    '{collect_result_in_target}',
    '{receive_time_tat_incl}',
    '{collect_time_tat_incl}')"
  )
  
  return(values)
}

## Insert all into temporary table ---------
all_data_glue <- function(x) {
  all_data <- glue('INSERT ALL
                   {x}
                   SELECT 1 from DUAL;')
}

## Merge into repository table --------
merge_to_raw_data_repo_query <- function(temp_table, repo_table) {
  glue(
    'MERGE INTO "{repo_table}" RT
  USING "{temp_table}" SOURCE_TABLE
  ON (RT."ORDER_ID" = SOURCE_TABLE."ORDER_ID" AND
      RT."MSMRN" = SOURCE_TABLE."MSMRN" AND
      RT."TEST_NAME" = SOURCE_TABLE."TEST_NAME" AND
      RT."RESULT_TIME" = SOURCE_TABLE."RESULT_TIME")
      WHEN MATCHED THEN
      UPDATE SET RT."LOC_CODE" = SOURCE_TABLE."LOC_CODE",
                 RT."LOC_NAME" = SOURCE_TABLE."LOC_NAME",
                 RT."REQUEST_MD" = SOURCE_TABLE."REQUEST_MD",
                 RT."WORK_SHIFT" = SOURCE_TABLE."WORK_SHIFT",
                 RT."TEST" = SOURCE_TABLE."TEST",
                 RT."DIVISION" = SOURCE_TABLE."DIVISION",
                 RT."ORDER_PRIORITY" = SOURCE_TABLE."ORDER_PRIORITY",
                 RT."SITE" = SOURCE_TABLE."SITE",
                 RT."ICU" = SOURCE_TABLE."ICU",
                 RT."LOC_TYPE" = SOURCE_TABLE."LOC_TYPE",
                 RT."SETTING" = SOURCE_TABLE."SETTING",
                 RT."SETTING_ROLL_UP" = SOURCE_TABLE."SETTING_ROLL_UP",
                 RT."DETAILED_SETTING" = SOURCE_TABLE."DETAILED_SETTING",
                 RT."DASHBOARD_SETTING" = SOURCE_TABLE."DASHBOARD_SETTING",
                 RT."ADJ_PRIORITY" = SOURCE_TABLE."ADJ_PRIORITY",
                 RT."DASHBOARD_PRIORITY" = SOURCE_TABLE."DASHBOARD_PRIORITY",
                 RT."ORDER_TIME" = SOURCE_TABLE."ORDER_TIME",
                 RT."COLLECT_TIME" = SOURCE_TABLE."COLLECT_TIME",
                 RT."RECEIVE_TIME" = SOURCE_TABLE."RECEIVE_TIME",
                 RT."RESULT_DATE" = SOURCE_TABLE."RESULT_DATE",
                 RT."COLLECT_TO_RECEIVE_TAT" = SOURCE_TABLE."COLLECT_TO_RECEIVE_TAT",
                 RT."RECEIVE_TO_RESULT_TAT" = SOURCE_TABLE."RECEIVE_TO_RESULT_TAT",
                 RT."COLLECT_TO_RESULT_TAT" = SOURCE_TABLE."COLLECT_TO_RESULT_TAT",
                 RT."ADD_ON_FINAL" = SOURCE_TABLE."ADD_ON_FINAL",
                 RT."MISSING_COLLECT" = SOURCE_TABLE."MISSING_COLLECT",
                 RT."RECEIVE_RESULT_TARGET" = SOURCE_TABLE."RECEIVE_RESULT_TARGET",
                 RT."COLLECT_RESULT_TARGET" = SOURCE_TABLE."COLLECT_RESULT_TARGET",
                 RT."RECEIVE_RESULT_IN_TARGET" = SOURCE_TABLE."RECEIVE_RESULT_IN_TARGET",
                 RT."COLLECT_RESULT_IN_TARGET" = SOURCE_TABLE."COLLECT_RESULT_IN_TARGET",
                 RT."RECEIVE_TIME_TAT_INCL" = SOURCE_TABLE."RECEIVE_TIME_TAT_INCL",
                 RT."COLLECT_TIME_TAT_INCL" = SOURCE_TABLE."COLLECT_TIME_TAT_INCL"
        WHEN NOT MATCHED THEN
        INSERT(RT."LOC_CODE",
               RT."LOC_NAME",
               RT."ORDER_ID",
               RT."REQUEST_MD",
               RT."MSMRN",
               RT."WORK_SHIFT",
               RT."TEST_NAME",
               RT."TEST",
               RT."DIVISION",
               RT."ORDER_PRIORITY",
               RT."SITE",
               RT."ICU",
               RT."LOC_TYPE",
               RT."SETTING",
               RT."SETTING_ROLL_UP",
               RT."DETAILED_SETTING",
               RT."DASHBOARD_SETTING",
               RT."ADJ_PRIORITY",
               RT."DASHBOARD_PRIORITY",
               RT."ORDER_TIME",
               RT."COLLECT_TIME",
               RT."RECEIVE_TIME",
               RT."RESULT_TIME",
               RT."RESULT_DATE",
               RT."COLLECT_TO_RECEIVE_TAT",
               RT."RECEIVE_TO_RESULT_TAT",
               RT."COLLECT_TO_RESULT_TAT",
               RT."ADD_ON_FINAL",
               RT."MISSING_COLLECT",
               RT."RECEIVE_RESULT_TARGET",
               RT."COLLECT_RESULT_TARGET",
               RT."RECEIVE_RESULT_IN_TARGET",
               RT."COLLECT_RESULT_IN_TARGET",
               RT."RECEIVE_TIME_TAT_INCL",
               RT."COLLECT_TIME_TAT_INCL"
               )
         VALUES(SOURCE_TABLE."LOC_CODE",
                SOURCE_TABLE."LOC_NAME",
                SOURCE_TABLE."ORDER_ID",
                SOURCE_TABLE."REQUEST_MD",
                SOURCE_TABLE."MSMRN",
                SOURCE_TABLE."WORK_SHIFT",
                SOURCE_TABLE."TEST_NAME",
                SOURCE_TABLE."TEST",
                SOURCE_TABLE."DIVISION",
                SOURCE_TABLE."ORDER_PRIORITY",
                SOURCE_TABLE."SITE",
                SOURCE_TABLE."ICU",
                SOURCE_TABLE."LOC_TYPE",
                SOURCE_TABLE."SETTING",
                SOURCE_TABLE."SETTING_ROLL_UP",
                SOURCE_TABLE."DETAILED_SETTING",
                SOURCE_TABLE."DASHBOARD_SETTING",
                SOURCE_TABLE."ADJ_PRIORITY",
                SOURCE_TABLE."DASHBOARD_PRIORITY",
                SOURCE_TABLE."ORDER_TIME",
                SOURCE_TABLE."COLLECT_TIME",
                SOURCE_TABLE."RECEIVE_TIME",
                SOURCE_TABLE."RESULT_TIME",
                SOURCE_TABLE."RESULT_DATE",
                SOURCE_TABLE."COLLECT_TO_RECEIVE_TAT",
                SOURCE_TABLE."RECEIVE_TO_RESULT_TAT",
                SOURCE_TABLE."COLLECT_TO_RESULT_TAT",
                SOURCE_TABLE."ADD_ON_FINAL",
                SOURCE_TABLE."MISSING_COLLECT",
                SOURCE_TABLE."RECEIVE_RESULT_TARGET",
                SOURCE_TABLE."COLLECT_RESULT_TARGET",
                SOURCE_TABLE."RECEIVE_RESULT_IN_TARGET",
                SOURCE_TABLE."COLLECT_RESULT_IN_TARGET",
                SOURCE_TABLE."RECEIVE_TIME_TAT_INCL",
                SOURCE_TABLE."COLLECT_TIME_TAT_INCL"
                );'
  )
}
```

## Add SCC data to OAO database tables
```{r Add new SCC data to database tables}
# Update raw data tables --------

## Add SCC test level data to database ---------

system.time(
  scc_status_table <- if(length(missing_scc_files) > 0) {
    print("Begin adding SCC data to raw data repository.")

    lapply(
      X = seq_along(test_new_scc_function),
      
      FUN = function(n) {
        temp_table <- raw_data_temp_table
        repo_table <- raw_data_repo_table
        
        scc_status_table <- NULL
        
        scc_test_level_data <- test_new_scc_function[[n]] %>%
          mutate(LOC_CODE = as.character(LOC_CODE),
                 LOC_NAME = as.character(LOC_NAME),
                 ORDER_ID = ifelse(is.na(ORDER_ID), "NoOrderID", as.character(ORDER_ID)),
                 REQUEST_MD = as.character(REQUEST_MD),
                 MSMRN = ifelse(is.na(MSMRN), "NoMRN", as.character(MSMRN)),
                 WORK_SHIFT = as.character(WORK_SHIFT),
                 TEST_NAME = as.character(TEST_NAME),
                 TEST = as.character(TEST),
                 DIVISION = as.character(DIVISION),
                 ORDER_PRIORITY = as.character(ORDER_PRIORITY),
                 SITE = as.character(SITE),
                 ICU = as.numeric(ICU),
                 LOC_TYPE = as.character(LOC_TYPE),
                 SETTING = as.character(SETTING),
                 SETTING_ROLL_UP = as.character(SETTING_ROLL_UP),
                 DETAILED_SETTING = as.character(DETAILED_SETTING),
                 DASHBOARD_SETTING = as.character(DASHBOARD_SETTING),
                 ADJ_PRIORITY = as.character(ADJ_PRIORITY),
                 DASHBOARD_PRIORITY = as.character(DASHBOARD_PRIORITY),
                 ORDER_TIME = format(ORDER_TIME, "%Y-%m-%d %H:%M:%S"),
                 COLLECT_TIME = format(COLLECT_TIME, "%Y-%m-%d %H:%M:%S"),
                 RECEIVE_TIME = format(RECEIVE_TIME, "%Y-%m-%d %H:%M:%S"),
                 RESULT_TIME = format(RESULT_TIME, "%Y-%m-%d %H:%M:%S"),
                 RESULT_DATE = format(RESULT_DATE, "%Y-%m-%d"),
                 COLLECT_TO_RECEIVE_TAT = as.numeric(COLLECT_TO_RECEIVE_TAT),
                 RECEIVE_TO_RESULT_TAT = as.numeric(RECEIVE_TO_RESULT_TAT),
                 COLLECT_TO_RESULT_TAT = as.numeric(COLLECT_TO_RESULT_TAT),
                 ADD_ON_FINAL = as.character(ADD_ON_FINAL),
                 MISSING_COLLECT = as.numeric(MISSING_COLLECT),
                 RECEIVE_RESULT_TARGET = as.numeric(RECEIVE_RESULT_TARGET),
                 COLLECT_RESULT_TARGET = as.numeric(COLLECT_RESULT_TARGET),
                 RECEIVE_RESULT_IN_TARGET = as.numeric(RECEIVE_RESULT_IN_TARGET),
                 COLLECT_RESULT_IN_TARGET = as.numeric(COLLECT_RESULT_IN_TARGET),
                 RECEIVE_TIME_TAT_INCL = as.numeric(RECEIVE_TIME_TAT_INCL),
                 COLLECT_TIME_TAT_INCL = as.numeric(COLLECT_TIME_TAT_INCL)
                 ) %>%
          mutate(across(everything(), as.character)) %>%
          mutate(across(everything(), gsub, pattern = "\'", replacement = "''")) %>%
          mutate(across(everything(), replace_na, replace = '')) %>%
          mutate(across(everything(), gsub, pattern = "&",
                        replacement = "'||chr(38)||'"))
        
        inserts <- lapply(
          mclapply(
            mclapply(split(scc_test_level_data, 
                           1:nrow(scc_test_level_data)),
                     as.list), 
            as.character),
          FUN = get_values_raw_cp_data, temp_table)
        
        values <- glue_collapse(inserts, sep = "\n\n")
        
        # # Combine into statements from get_values() function and combine with insert statements
        # all_data <- glue('INSERT ALL {values} SELECT 1 from DUAL;')
        all_data <- all_data_glue(x = values)
        
        # Truncate query for temporary table -------------
        truncate_query <- glue('TRUNCATE TABLE "{temp_table}";')
        
        ## Merge query for repo table -----------
        # glue() query to merge data from temporary table to repository table
        query <- merge_to_raw_data_repo_query(temp_table = temp_table,
                                              repo_table = repo_table)
        
        chunk_length <- 200
        
        split_insert_queries <- split(inserts,
                                      ceiling(seq_along(inserts) / chunk_length))
        split_queries_final <- list()
        
        for (i in 1:length(split_insert_queries)) {
          row <- glue_collapse(split_insert_queries[[i]], sep = "\n\n")
          sql <- glue('INSERT ALL {row} SELECT 1 FROM DUAL;')
          split_queries_final <- append(split_queries_final, sql)
          }

        oao_personal_conn <- dbConnect(odbc(), "OAO Cloud DB Kate")
        dbBegin(oao_personal_conn)

        print(paste("Database writing for", names(test_new_scc_function)[[n]]))
        
        tryCatch({
          print("Before first truncate")
          dbExecute(oao_personal_conn, truncate_query)
          print("After first truncate")

          # mclapply(split_queries_final, write_to_temp_table)

          registerDoParallel()

          foreach(i = 1:length(split_queries_final),
                  .packages = c("DBI", "odbc"))%dopar%{
                    oao_personal_conn <- dbConnect(odbc(), "OAO Cloud DB Kate")
                    dbBegin(oao_personal_conn)
                    dbExecute(oao_personal_conn, split_queries_final[[i]])
                    dbCommit(oao_personal_conn)

                  }

          registerDoSEQ()

          print("After all rows added to temporary table")
          dbExecute(oao_personal_conn, query)
          print("After merge into repo table")
          dbExecute(oao_personal_conn, truncate_query)
          print("After second truncate")
          dbCommit(oao_personal_conn)
          print("After repo table commit")
          dbDisconnect(oao_personal_conn)
          print(paste0("Success! SCC File ", n, " added to database!"))
          scc_status_table <- rbind(scc_status_table,
                                    paste0("File ", missing_scc_files[n],
                                           " successfully added to database!"))
        },
        error = function(err){
          # print("error")
          dbRollback(oao_personal_conn)
          dbExecute(oao_personal_conn, truncate_query)
          dbDisconnect(oao_personal_conn)
          print(paste0("Error! Code experienced an error adding SCC File ", n, " to database!"))
          scc_status_table <- rbind(scc_status_table,
                                    paste0("Check ", missing_scc_files[n]))
        } # End error
        ) # End trycatch
      } # End function in lapply
    ) # End lapply

} else {
  print("No SCC data found to add.")
}
) # End system.time

scc_status_table <- unlist(scc_status_table)
```

## Add Sunquest data to OAO database tables
```{r Add new Sunquest data to database tables}
## Add Sunquest test level data to database ---------
system.time(
  sun_status_table <-
    if(length(missing_sun_files) > 0) {
      print("Begin adding Sunquest data to raw data repository.")
      
      lapply(
        X = seq_along(test_new_sun_function),
        
        FUN = function(n) {
          temp_table <- raw_data_temp_table
          repo_table <- raw_data_repo_table
          
          sun_status_table <- NULL
          
          sun_test_level_data <- test_new_sun_function[[n]] %>%
            mutate(LOC_CODE = as.character(LOC_CODE),
                   LOC_NAME = as.character(LOC_NAME),
                   ORDER_ID = ifelse(is.na(ORDER_ID), "NoOrderID", as.character(ORDER_ID)),
                   REQUEST_MD = as.character(REQUEST_MD),
                   MSMRN = ifelse(is.na(MSMRN), "NoMRN", as.character(MSMRN)),
                   WORK_SHIFT = as.character(WORK_SHIFT),
                   TEST_NAME = as.character(TEST_NAME),
                   TEST = as.character(TEST),
                   DIVISION = as.character(DIVISION),
                   ORDER_PRIORITY = as.character(ORDER_PRIORITY),
                   SITE = as.character(SITE),
                   ICU = as.numeric(ICU),
                   LOC_TYPE = as.character(LOC_TYPE),
                   SETTING = as.character(SETTING),
                   SETTING_ROLL_UP = as.character(SETTING_ROLL_UP),
                   DETAILED_SETTING = as.character(DETAILED_SETTING),
                   DASHBOARD_SETTING = as.character(DASHBOARD_SETTING),
                   ADJ_PRIORITY = as.character(ADJ_PRIORITY),
                   DASHBOARD_PRIORITY = as.character(DASHBOARD_PRIORITY),
                   ORDER_TIME = format(ORDER_TIME, "%Y-%m-%d %H:%M:%S"),
                   COLLECT_TIME = format(COLLECT_TIME, "%Y-%m-%d %H:%M:%S"),
                   RECEIVE_TIME = format(RECEIVE_TIME, "%Y-%m-%d %H:%M:%S"),
                   RESULT_TIME = format(RESULT_TIME, "%Y-%m-%d %H:%M:%S"),
                   RESULT_DATE = format(RESULT_DATE, "%Y-%m-%d"),
                   COLLECT_TO_RECEIVE_TAT = as.numeric(COLLECT_TO_RECEIVE_TAT),
                   RECEIVE_TO_RESULT_TAT = as.numeric(RECEIVE_TO_RESULT_TAT),
                   COLLECT_TO_RESULT_TAT = as.numeric(COLLECT_TO_RESULT_TAT),
                   ADD_ON_FINAL = as.character(ADD_ON_FINAL),
                   MISSING_COLLECT = as.numeric(MISSING_COLLECT),
                   RECEIVE_RESULT_TARGET = as.numeric(RECEIVE_RESULT_TARGET),
                   COLLECT_RESULT_TARGET = as.numeric(COLLECT_RESULT_TARGET),
                   RECEIVE_RESULT_IN_TARGET = as.numeric(RECEIVE_RESULT_IN_TARGET),
                   COLLECT_RESULT_IN_TARGET = as.numeric(COLLECT_RESULT_IN_TARGET),
                   RECEIVE_TIME_TAT_INCL = as.numeric(RECEIVE_TIME_TAT_INCL),
                   COLLECT_TIME_TAT_INCL = as.numeric(COLLECT_TIME_TAT_INCL)
                   ) %>%
            mutate(across(everything(), as.character)) %>%
            mutate(across(everything(), gsub, pattern = "\'", replacement = "''")) %>%
            mutate(across(everything(), replace_na, replace = '')) %>%
            mutate(across(everything(), gsub, pattern = "&",
                          replacement = "'||chr(38)||'"))
          
          inserts <- mclapply(
            mclapply(
              mclapply(split(sun_test_level_data, 
                             1:nrow(sun_test_level_data)),
                       as.list), 
              as.character),
            FUN = get_values_raw_cp_data, temp_table)
          
          values <- glue_collapse(inserts, sep = "\n\n")
          
          # # Combine into statements from get_values() function and combine with insert statements
          # all_data <- glue('INSERT ALL {values} SELECT 1 from DUAL;')
          all_data <- all_data_glue(x = values)
          
          # Truncate query for temporary table -------------
          truncate_query <- glue('TRUNCATE TABLE "{temp_table}";')
          
          ## Merge query for repo table -----------
          # glue() query to merge data from temporary table to repository table
          query <- merge_to_raw_data_repo_query(temp_table = temp_table,
                                                repo_table = repo_table)
          
          chunk_length <- 200
          
          split_insert_queries <- split(inserts,
                                        ceiling(seq_along(inserts) / chunk_length))
          
          split_queries_final <- list()
          
          for (i in 1:length(split_insert_queries)) {
            row <- glue_collapse(split_insert_queries[[i]], sep = "\n\n")
            sql <- glue('INSERT ALL {row} SELECT 1 FROM DUAL;')
            split_queries_final <- append(split_queries_final, sql)
            }
          
          oao_personal_conn <- dbConnect(odbc(), "OAO Cloud DB Kate")
          dbBegin(oao_personal_conn)
          
          print(paste("Database writing for", names(test_new_sun_function)[[n]]))
          
          tryCatch({
            print("Before first truncate")
            dbExecute(oao_personal_conn, truncate_query)
            print("After first truncate")
            
            # mclapply(split_queries_final, write_to_temp_table)
            
            registerDoParallel()
            
            foreach(i = 1:length(split_queries_final),
                    .packages = c("DBI", "odbc"))%dopar%{
                      oao_personal_conn <- dbConnect(odbc(), "OAO Cloud DB Kate")
                      dbBegin(oao_personal_conn)
                      dbExecute(oao_personal_conn, split_queries_final[[i]])
                      dbCommit(oao_personal_conn)
                      }
            
            registerDoSEQ()
            
            print("After all rows added to temporary table")
            dbExecute(oao_personal_conn, query)
            print("After merge into repo table")
            dbExecute(oao_personal_conn, truncate_query)
            print("After second truncate")
            dbCommit(oao_personal_conn)
            print("After repo table commit")
            dbDisconnect(oao_personal_conn)
            print(paste0("Success! Sunquest File ", n, " added to database!"))
            sun_status_table <- rbind(sun_status_table,
                                      paste0("File ", missing_sun_files[n],
                                             " successfully added to database!"))
            },
            error = function(err){
              dbRollback(oao_personal_conn)
              dbExecute(oao_personal_conn, truncate_query)
              dbDisconnect(oao_personal_conn)
              print(paste0("Error! Code experienced an error adding Sunquest File ", n, " to database!"))
              sun_status_table <- rbind(sun_status_table,
                                    paste0("Check ", missing_sun_files[n]))
              } # End error
            ) # End try catch
          } # End custom function in lapply
        ) # End lapply
      } else {
        print("No Sunquest data found to add.")
      }
) # End sys.time
  
sun_status_table <- unlist(sun_status_table)

```

```{r Summary output messages}
scc_status_table

sun_status_table

```
