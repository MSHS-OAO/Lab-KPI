---
title: "MSHS Laboratory KPI Dashboard"
output:
  html_document:
    toc: true
    toc_depth: 2
    toc_float: true
---


```{r include = FALSE}
#Install packages only the first time you run the code
# install.packages("timeDate")
# install.packages("lubridate")
# install.packages("readxl")
# install.packages("dplyr")
# install.packages("reshape2")
# install.packages("knitr")
# install.packages("gdtools")
# install.packages("kableExtra")
# install.packages("formattable")
# install.packages("bizdays")
# install.packages("rmarkdown")
# install.packages("stringr")
# install.packages("writexl")

#-------------------------------Required packages------------------------------#

#Required packages: run these every time you run the code
library(timeDate)
library(readxl)
library(bizdays)
library(dplyr)
library(lubridate)
library(reshape2)
library(knitr)
# library(gdtools)
library(kableExtra)
library(formattable)
library(rmarkdown)
library(stringr)
library(writexl)


```


<h4><span style = "color:red">Draft - Not For Distribution</h4></span style = "color:red">


```{r global_options, echo = FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
```

```{r Determine date, warning = FALSE, message = FALSE, echo = FALSE}
#Clear existing history
rm(list = ls())
#-------------------------------holiday/weekend-------------------------------#
# Get today and yesterday's date

today <- as.timeDate(format(Sys.Date(), "%m/%d/%Y"))
#today <- as.timeDate(as.Date("03/04/2021", format = "%m/%d/%Y"))

#Determine if yesterday was a holiday/weekend
#get yesterday's DOW
yesterday <- as.timeDate(format(Sys.Date() - 1, "%m/%d/%Y"))
#yesterday <- as.timeDate(as.Date("03/03/2021", format = "%m/%d/%Y"))

#Get yesterday's DOW
yesterday_day <- dayOfWeek(yesterday)

#Remove Good Friday from MSHS Holidays
nyse_holidays <- as.Date(holidayNYSE(year = 1990:2100))
good_friday <- as.Date(GoodFriday())
mshs_holiday <- nyse_holidays[good_friday != nyse_holidays]

#Determine whether yesterday was a holiday/weekend
holiday_det <- isHoliday(yesterday, holidays = mshs_holiday)

#Set up a calendar for collect to received TAT calculations for Path & Cyto
create.calendar("MSHS_working_days", mshs_holiday,
                weekdays = c("saturday", "sunday"))
bizdays.options$set(default.calendar = "MSHS_working_days")
```

#### *Dashboard Creation Date: `r format(today, "%m/%d/%Y")`*

```{r Import all data, warning = FALSE, message = FALSE, echo = FALSE}
# Select file/folder path for easier file selection and navigation

if (list.files("J://") == "Presidents") {
  user_directory <- paste0("J:/Presidents/HSPI-PM/",
                           "Operations Analytics and Optimization/Projects/",
                           "Service Lines/Lab Kpi/Data")
} else {
  user_directory <- paste0("J:/deans/Presidents/HSPI-PM/",
                           "Operations Analytics and Optimization/Projects/",
                           "Service Lines/Lab Kpi/Data")
}

#------------------------------Read Excel sheets------------------------------#

#Import weekday files
scc_weekday <- read_excel(
  choose.files(
    default = paste0(user_directory, "/SCC CP Reports/*.*"),
    caption = "Select SCC Report for Labs Resulted on Most Recent Weekday"),
    sheet = 1, col_names = TRUE)

sq_weekday <- suppressWarnings(read_excel(
  choose.files(
    default = paste0(user_directory, "/SUN CP Reports/*.*"),
    caption =
      "Select Sunquest Report for Labs Resulted on Most Recent Weekday"),
    sheet = 1, col_names = TRUE))
  
pp_weekday <- read_excel(
  choose.files(
    default = paste0(user_directory, "/AP & Cytology Signed Cases Reports/*.*"),
    caption =
      "Select PowerPath Report for Spec Signed Out on Most Recent Weekday"),
    skip = 1, 1)

pp_weekday <- data.frame(pp_weekday[-nrow(pp_weekday), ],
                         stringsAsFactors = FALSE)

epic_weekday <- read_excel(
  choose.files(
    default = paste0(user_directory, "/EPIC Cytology/*.*"),
    caption = "Select Epic Report for Spec Signed Out on Most Recent Weekday"),
  1)
  
# The if-statement below determines the number of raw data files to import
# based on the day of week and holidays. The user is then prompted to select
# each file from the relevant folder.

if (((holiday_det) & (yesterday_day == "Mon")) |
   ((yesterday_day == "Sun") & (isHoliday(yesterday - (86400 * 2))))) {
  # Scenario 1: Mon Holiday or Friday Holiday (Need to select 4 files)
  # Save scenario
  scenario <- 1
  # Import SCC data
  scc_hol_mon_fri <- read_excel(
    choose.files(
      default = paste0(user_directory, "/SCC CP Reports/*.*"),
      caption = "Select SCC Report for Labs Resulted on Recent Holiday"),
    sheet = 1, col_names = TRUE)
  scc_sun <- read_excel(
    choose.files(
      default = paste0(user_directory, "/SCC CP Reports/*.*"),
      caption = "Select SCC Report for Labs Resulted on Sunday"),
    sheet = 1, col_names = TRUE)
  scc_sat <- read_excel(
    choose.files(
      default = paste0(user_directory, "/SCC CP Reports/*.*"),
      caption = "Select SCC Report for Labs Resulted on Saturday"),
    sheet = 1, col_names = TRUE)
  #Merge the weekend data with the holiday data in one data frame
  scc_not_weekday <- rbind(scc_hol_mon_fri,
                           scc_sun,
                           scc_sat)
  #
  # Import Sunquest data
  sq_hol_mon_fri <- suppressWarnings(read_excel(
    choose.files(
      default = paste0(user_directory, "/SUN CP Reports/*.*"),
      caption = "Select Sunquest Report for Labs Resulted on Recent Holiday"),
    sheet = 1, col_names = TRUE))
  sq_sun <- suppressWarnings(read_excel(
    choose.files(
      default = paste0(user_directory, "/SUN CP Reports/*.*"),
      caption = "Select Sunquest Report for Labs Resulted on Sunday"),
    sheet = 1, col_names = TRUE))
  sq_sat <- suppressWarnings(read_excel(
    choose.files(
      default = paste0(user_directory, "/SUN CP Reports/*.*"),
      caption = "Select Sunquest Report for Labs Resulted on Saturday"),
    sheet = 1, col_names = TRUE))
  #Merge the weekend data with the holiday data in one data frame
  sq_not_weekday <- rbind(sq_hol_mon_fri, sq_sun, sq_sat)
  #
  # Import Powerpath data
  pp_hol_mon_fri <- read_excel(
    choose.files(
      default =
        paste0(user_directory, "/AP & Cytology Signed Cases Reports/*.*"),
      caption =
        "Select PowerPath Report for Spec Signed Out on Recent Holiday"),
    skip = 1, 1)
  pp_hol_mon_fri  <- pp_hol_mon_fri[
    -nrow(pp_hol_mon_fri), ]
  pp_sun <- read_excel(
    choose.files(
      default =
        paste0(user_directory, "/AP & Cytology Signed Cases Reports/*.*"),
      caption =
        "Select PowerPath Report for Spec Signed Out on Sunday"),
    skip = 1, 1)
  pp_sun <- pp_sun[-nrow(pp_sun), ]
  pp_sat <- read_excel(
    choose.files(
      default =
        paste0(user_directory, "/AP & Cytology Signed Cases Reports/*.*"),
      caption =
        "Select PowerPath Report for Spec Signed Out on Saturday"),
    skip = 1, 1)
  pp_sat <- pp_sat[-nrow(pp_sat), ]
  #Merge the weekend data with the holiday data in one data frame
  pp_not_weekday <- data.frame(rbind(pp_hol_mon_fri,
                                     pp_sun,
                                     pp_sat), stringsAsFactors = FALSE)
  #
  # Import EPIC Cytology data
  epic_hol_mon_fri <- read_excel(
    choose.files(
      default = paste0(user_directory, "/EPIC Cytology/*.*"),
      caption = "Select Epic Report for Spec Signed Out on Recent Holiday"),
    1)
  epic_sun <- read_excel(
    choose.files(
      default = paste0(user_directory, "/EPIC Cytology/*.*"),
      caption = "Select Epic Report for Spec Signed Out on Sunday"), 1)
  epic_sat <- read_excel(
    choose.files(
      default = paste0(user_directory, "/EPIC Cytology/*.*"),
      caption = "Select PowerPath Report for Spec Signed Out on Saturday"), 1)
  #Merge the weekend data with the holiday data in one data frame
  epic_not_weekday <- data.frame(rbind(epic_hol_mon_fri,
                                       epic_sun,
                                       epic_sat), stringsAsFactors = FALSE)

} else if ((holiday_det) & (yesterday_day == "Sun")) {
  # Scenario 2: Regular Monday (Need to select 3 files)
  # Save scenario
  scenario <- 2
  #
  # Import SCC data
  scc_sun <- read_excel(
    choose.files(default = paste0(user_directory, "/SCC CP Reports/*.*"),
                 caption = "Select SCC Report for Labs Resulted on Sunday"),
    sheet = 1, col_names = TRUE)
  scc_sat <- read_excel(
    choose.files(default = paste0(user_directory, "/SCC CP Reports/*.*"),
                 caption = "Select SCC Report for Labs Resulted on Saturday"),
    sheet = 1, col_names = TRUE)
  #Merge the weekend data with the holiday data in one data frame
  scc_not_weekday <- rbind(scc_sun, scc_sat)
  #
  # Import Sunquest data
  sq_sun <- suppressWarnings(read_excel(
    choose.files(
      default = paste0(user_directory, "/SUN CP Reports/*.*"),
      caption = "Select Sunquest Report for Labs Resulted on Sunday"),
    sheet = 1, col_names = TRUE))
  sq_sat <- suppressWarnings(read_excel(
    choose.files(
      default = paste0(user_directory, "/SUN CP Reports/*.*"),
      caption = "Select Sunquest Report for Labs Resulted on Saturday"),
    sheet = 1, col_names = TRUE))
  #Merge the weekend data with the holiday data in one data frame
  sq_not_weekday <- rbind(sq_sun, sq_sat)
  #
  # Import Powerpath data
  pp_sun <- read_excel(
    choose.files(
      default =
        paste0(user_directory, "/AP & Cytology Signed Cases Reports/*.*"),
      caption =
        "Select PowerPath Report for Spec Signed Out on Sunday"),
    skip = 1, 1)
  pp_sun <- pp_sun[-nrow(pp_sun), ]
  pp_sat <- read_excel(
    choose.files(
      default =
        paste0(user_directory, "/AP & Cytology Signed Cases Reports/*.*"),
      caption =
        "Select PowerPath Report for Spec Signed Out on Saturday"),
    skip = 1, 1)
  pp_sat <- pp_sat[-nrow(pp_sat), ]
  #Merge the weekend data with the holiday data in one data frame
  pp_not_weekday <- data.frame(rbind(pp_sun,
                                     pp_sat), stringsAsFactors = FALSE)
  #
  # Import Epic Cytology data
  epic_sun <- read_excel(
    choose.files(
      default = paste0(user_directory, "/EPIC Cytology/*.*"),
      caption = "Select Epic Report for Spec Signed Out on Sunday"), 1)
  epic_sat <- read_excel(
    choose.files(
      default = paste0(user_directory, "/EPIC Cytology/*.*"),
      caption = "Select Epic Report for Spec Signed Out on Saturday"), 1)
  #Merge the weekend data with the holiday data in one data frame
  epic_not_weekday <- data.frame(rbind(epic_sun,
                                       epic_sat),
                                 stringsAsFactors = FALSE)

} else if ((holiday_det) & ((yesterday_day != "Mon") |
                            (yesterday_day != "Sun"))) {
  #Scenario 3: Midweek holiday (Need to select 2 files)
  # Save scenario
  scenario <- 3
  #
  # Import SCC data
  scc_hol_weekday <- read_excel(
    choose.files(
      default = paste0(user_directory, "/SCC CP Reports/*.*"),
      caption = "Select SCC Report for Labs Resulted on Recent Holiday"),
    sheet = 1, col_names = TRUE)
  scc_not_weekday <- scc_hol_weekday
  #
  # Import Sunquest data
  sq_hol_weekday <- suppressWarnings(read_excel(
    choose.files(
      default = paste0(user_directory, "/SUN CP Reports/*.*"),
      caption = "Select Sunquest Report for Labs Resulted on Recent Holiday"),
    sheet = 1, col_names = TRUE))
  sq_not_weekday <- sq_hol_weekday
  #
  # Import Powerpath data
  pp_hol_weekday <- read_excel(
    choose.files(
      default =
        paste0(user_directory, "/AP & Cytology Signed Cases Reports/*.*"),
      caption =
        "Select PowerPath Report for Spec Signed Out on Recent Holiday"),
    skip = 1, 1)
  pp_hol_weekday <- pp_hol_weekday[-nrow(pp_hol_weekday), ]
  pp_not_weekday <- data.frame(pp_hol_weekday, stringsAsFactors = FALSE)
  #
  # Import Epic Cytology data
  epic_hol_weekday <- read_excel(
    choose.files(
      default = paste0(user_directory, "/EPIC Cytology/*.*"),
      caption = "Select Epic Report for Spec Signed Out on Recent Holiday"), 1)
  epic_not_weekday <- data.frame(epic_hol_weekday, stringsAsFactors = FALSE)

} else {#Scenario 4: Tue-Fri without holidays (Need to select 1 file)
  # Save scenario
  scenario <- 4
  #
  scc_not_weekday <- NULL
  #
  sq_not_weekday <- NULL
  #
  pp_not_weekday <- NULL
  #
  epic_not_weekday <- NULL
}

#-----------Cytology Backlog Excel Files-----------#
#For the backlog files the read excel is starting from the second row and
#remove last row
cyto_backlog_raw <- read_excel(
  choose.files(default = paste0(user_directory,
                                "/Cytology Backlog Reports/*.*"),
               caption = "Select Cytology Backlog Report"),
  skip = 1, 1)
cyto_backlog_raw <- data.frame(
  cyto_backlog_raw[-nrow(cyto_backlog_raw), ], stringsAsFactors = FALSE)

```

```{r Reference Data, warning = FALSE, message = FALSE, echo = FALSE}
# Import analysis reference data
reference_file <- paste0(user_directory,
                         "/Code Reference/",
                         "Analysis Reference 2021-02-23.xlsx")

# CP and Micro --------------------------------

test_code <- read_excel(reference_file, sheet = "TestNames")

tat_targets <- read_excel(reference_file, sheet = "Turnaround Targets")
#
# Add a column concatenating test, priority, and setting for matching later
tat_targets <- tat_targets %>%
  mutate(Concate = ifelse(
    Priority == "All" & `Pt Setting` == "All", Test,
    ifelse(Priority != "All" & `Pt Setting` == "All", paste(Test, Priority),
           paste(Test, Priority, `Pt Setting`))))

scc_icu <- read_excel(reference_file, sheet = "SCC_ICU")
scc_setting <- read_excel(reference_file, sheet = "SCC_ClinicType")
sun_icu <- read_excel(reference_file, sheet = "SUN_ICU")
sun_setting <- read_excel(reference_file, sheet = "SUN_LocType")

mshs_site <- read_excel(reference_file, sheet = "SiteNames")

scc_wday <- scc_weekday
sun_wday <- sq_weekday

cp_micro_lab_order <- c("Troponin",
                        "Lactate WB",
                        "BUN",
                        "HGB",
                        "PT",
                        "Rapid Flu",
                        "C. diff")

site_order <- c("MSH", "MSQ", "MSBI", "MSB", "MSW", "MSM", "MSSN")
city_sites <- c("MSH", "MSQ", "MSBI", "MSB", "MSW", "MSM")

pt_setting_order <- c("ED", "ICU", "IP Non-ICU", "Amb", "Other")
pt_setting_order2 <- c("ED & ICU", "IP Non-ICU", "Amb", "Other")
dashboard_pt_setting <- c("ED & ICU", "IP Non-ICU", "Amb")

dashboard_priority_order <- c("All", "Stat", "Routine")

#-----------Patient Setting Excel File-----------#
#Using Rev Center to determine patient setting
patient_setting <- data.frame(read_excel(reference_file,
                                         sheet = "AP_Patient Setting"),
                              stringsAsFactors = FALSE)

#-----------Anatomic Pathology Targets Excel File-----------#
tat_targets_ap <- data.frame(read_excel(reference_file,
                                     sheet = "AP_TAT Targets"),
                          stringsAsFactors = FALSE)

#-----------GI Codes Excel File-----------#
#Upload the exclusion vs inclusion criteria associated with the GI codes
gi_codes <- data.frame(read_excel(reference_file, sheet = "GI_Codes"),
                       stringsAsFactors = FALSE)

#-----------Create table template for Cyto/Path-----------#
#The reason behind the table templates is to make sure all the variables and
#patient settings are included

#Cyto
#this template for cyto is with an assumption that received to result is not
#centralized
table_temp_cyto <- data.frame(matrix(ncol = 19, nrow = 4))

colnames(table_temp_cyto) <- c("Spec_group", "Patient_setting",
                                   "no_cases_signed",
                                   "MSH.x", "BIMC.x", "MSQ.x", "NYEE.x",
                                   "PACC.x", "R.x", "SL.x", "KH.x", "BIMC.y",
                                   "MSH.y", "MSQ.y", "NYEE.y", "PACC.y", "R.y",
                                   "SL.y", "KH.y")

table_temp_cyto[1] <- c("CYTO GYN", "CYTO GYN", "CYTO NONGYN", "CYTO NONGYN")
table_temp_cyto[2] <- c("IP", "Amb")

#this template for cyto is with an assumption that received to result is
#centralized
table_temp_cyto_v2 <- data.frame(matrix(ncol = 12, nrow = 4))

colnames(table_temp_cyto_v2) <- c("Spec_group", "Patient_setting",
                                      "no_cases_signed",
                                      "received_to_signed_out_within_target",
                                      "BIMC", "MSH", "MSQ", "NYEE", "PACC",
                                      "R", "SL", "KH")

table_temp_cyto_v2[1] <- c("CYTO GYN", "CYTO GYN", "CYTO NONGYN", "CYTO NONGYN")
table_temp_cyto_v2[2] <- c("IP", "Amb")

#this table template is for cytology volume
table_temp_cyto_vol <- data.frame(matrix(ncol = 10, nrow = 4))

colnames(table_temp_cyto_vol) <- c("Spec_group", "Patient_setting",
                                       "BIMC", "MSH", "MSQ", "NYEE", "PACC",
                                       "R", "SL", "KH")

table_temp_cyto_vol[1] <- c("CYTO GYN", "CYTO GYN",
                            "CYTO NONGYN", "CYTO NONGYN")
table_temp_cyto_vol[2] <- c("IP", "Amb")

#Patho
#this template for patho (sp) is with an assumption that received to result is
#not centralized
table_temp_patho <- data.frame(matrix(ncol = 17, nrow = 4))
colnames(table_temp_patho) <- c("Spec_group", "Patient_setting",
                                    "no_cases_signed",
                                    "MSH.x", "BIMC.x", "MSQ.x", "PACC.x",
                                    "R.x", "SL.x", "KH.x", "BIMC.y", "MSH.y",
                                    "MSQ.y", "PACC.y", "R.y", "SL.y", "KH.y")

table_temp_patho[1] <- c("Breast", "Breast", "GI", "GI")
table_temp_patho[2] <- c("IP", "Amb")

#this table template is for surgical pathology volume
table_temp_patho_vol <- data.frame(matrix(ncol = 9, nrow = 4))
colnames(table_temp_patho_vol) <- c("Spec_group", "Patient_setting",
                                        "BIMC", "MSH", "MSQ", "PACC",
                                        "R", "SL", "KH")

table_temp_patho_vol[1] <- c("Breast", "Breast", "GI", "GI")
table_temp_patho_vol[2] <- c("IP", "Amb")

```


```{r Custom Function for preprocessing raw SCC and Sunquest data, warning = FALSE, message = FALSE, echo = FALSE}
preprocess_cp <- function(raw_scc, raw_sun)  {

  # Preprocess SCC data -------------------------------
  # Correct and format any timestamps that were not imported correctly
  raw_scc[c("ORDERING_DATE",
            "COLLECTION_DATE",
            "RECEIVE_DATE",
            "VERIFIED_DATE")] <-
    lapply(raw_scc[c("ORDERING_DATE",
                     "COLLECTION_DATE",
                     "RECEIVE_DATE",
                     "VERIFIED_DATE")],
           function(x)
             ifelse(!is.na(x) & str_detect(x, "\\*.*\\*"),
                    str_replace(x, "\\*.*\\*", ""), x))

  raw_scc[c("ORDERING_DATE",
            "COLLECTION_DATE",
            "RECEIVE_DATE",
            "VERIFIED_DATE")] <-
    lapply(raw_scc[c("ORDERING_DATE",
                     "COLLECTION_DATE",
                     "RECEIVE_DATE",
                     "VERIFIED_DATE")],
           as.POSIXct, tz = "UTC",
           format = "%Y-%m-%d %H:%M:%OS",
           options(digits.sec = 1))

  # SCC lookup references ----------------------------------------------
  # Crosswalk in scope labs
  raw_scc <- left_join(raw_scc,
                       test_code[, c("Test", "SCC_TestID", "Division")],
                       by = c("TEST_ID" = "SCC_TestID"))

  # Determine if test is included based on crosswalk results
  raw_scc <- raw_scc %>%
    mutate(TestIncl = !is.na(Test)) %>%
    filter(TestIncl)

  # Crosswalk unit type
  raw_scc <- left_join(raw_scc, scc_setting,
                       by = c("CLINIC_TYPE" = "Clinic_Type"))
  # Crosswalk site name
  raw_scc <- left_join(raw_scc, mshs_site,
                       by = c("SITE" = "DataSite"))

  # Crosswalk units and identify ICUs
  raw_scc <- raw_scc %>%
    mutate(WardandName = paste(Ward, WARD_NAME))

  raw_scc <- left_join(raw_scc, scc_icu[, c("Concatenate", "ICU")],
                       by = c("WardandName" = "Concatenate"))

  # Preprocess SCC data and add any necessary columns
  raw_scc <- raw_scc %>%
    mutate(
      # Determine if unit is an ICU based on crosswalk results
      ICU = ifelse(is.na(ICU), FALSE, ICU),
      # Create a column for resulted date
      ResultedDate = date(VERIFIED_DATE),
      # Create master setting column to identify ICU and IP Non-ICU units
      MasterSetting = ifelse(SettingRollUp == "IP" & ICU, "ICU",
                             ifelse(SettingRollUp == "IP" & !ICU,
                                    "IP Non-ICU", SettingRollUp)),
      # Create dashboard setting column to roll up master settings based on
      # desired dashboard grouping (ie, group ED and ICU together)
      DashboardSetting = ifelse(MasterSetting %in% c("ED", "ICU"),
                                "ED & ICU", MasterSetting),
      # Create column with adjusted priority based on assumption that all ED and
      # ICU labs are treated as stat per operational leadership
      AdjPriority = ifelse(MasterSetting %in% c("ED", "ICU") |
                             PRIORITY %in% "S", "Stat", "Routine"),
      # Create dashboard priority column
      DashboardPriority = ifelse(
        tat_targets$Priority[match(Test, tat_targets$Test)] == "All",
        "All", AdjPriority),
      # Calculate turnaround times
      CollectToReceive =
        as.numeric(RECEIVE_DATE - COLLECTION_DATE, units = "mins"),
      ReceiveToResult =
        as.numeric(VERIFIED_DATE - RECEIVE_DATE, units = "mins"),
      CollectToResult =
        as.numeric(VERIFIED_DATE - COLLECTION_DATE, units = "mins"),
      #
      # Determine if order was an add on or original order based on time between
      # order and receive times
      AddOnMaster = ifelse(as.numeric(ORDERING_DATE - RECEIVE_DATE,
                                      units = "mins")
                           > 5, "AddOn", "Original"),
      # Determine if collection time is missing
      MissingCollect = CollectToReceive == 0,
      #
      # Determine TAT based on test, priority, and patient setting
      # Create column concatenating test and priority to determine TAT targets
      Concate1 = paste(Test, DashboardPriority),
      # Create column concatenating test, priority, and setting to determine
      # TAT targets
      Concate2 = paste(Test, DashboardPriority, MasterSetting),
      # Determine Receive to Result TAT target using this logic:
      # 1. Try to match test, priority, and setting (applicable for labs with
      # different TAT targets based on patient setting and order priority)
      # 2. Try to match test and priority (applicable for labs with different
      # TAT targets based on order priority)
      # 3. Try to match test - this is for tests with (applicable for labs with
      # TAT targets that are independent of patient setting or priority)
      #
      # Determine Receive to Result TAT target based on above logic/scenarios
      ReceiveResultTarget =
        # Match on scenario 1
        ifelse(!is.na(match(Concate2, tat_targets$Concate)),
               tat_targets$ReceiveToResultTarget[
                 match(Concate2, tat_targets$Concate)],
               # Match on scenario 2
               ifelse(!is.na(match(Concate1, tat_targets$Concate)),
                      tat_targets$ReceiveToResultTarget[
                        match(Concate1, tat_targets$Concate)],
                      # Match on scenario 3
                      tat_targets$ReceiveToResultTarget[
                        match(Test, tat_targets$Concate)])),
      #
      # Determine Collect to Result TAT target based on above logic/scenarios
      CollectResultTarget =
        # Match on scenario 1
        ifelse(!is.na(match(Concate2, tat_targets$Concate)),
               tat_targets$CollectToResultTarget[
                 match(Concate2, tat_targets$Concate)],
               # Match on scenario 2
               ifelse(!is.na(match(Concate1, tat_targets$Concate)),
                      tat_targets$CollectToResultTarget[
                        match(Concate1, tat_targets$Concate)],
                      # Match on scenario 3
                      tat_targets$CollectToResultTarget[
                        match(Test, tat_targets$Concate)])),
      #
      # Determine if Receive to Result and Collect to Result TAT meet targets
      ReceiveResultInTarget = ReceiveToResult <= ReceiveResultTarget,
      CollectResultInTarget = CollectToResult <= CollectResultTarget,
      # Create column with patient name, order ID, test, collect, receive, and
      # result date and determine if there is a duplicate; order time excluded
      Concate3 = paste(LAST_NAME, FIRST_NAME,
                       ORDER_ID, TEST_NAME,
                       COLLECTION_DATE, RECEIVE_DATE, VERIFIED_DATE),
      DuplTest = duplicated(Concate3),
      # Determine whether or not to include this particular lab in TAT analysis
      # Exclusion criteria:
      # 1. Add on orders
      # 2. Orders from "Other" settings
      # 3. Orders with collect or receive times after result time
      # 4. Orders with missing collect, receive, or result timestamps
      TATInclude = ifelse(AddOnMaster == "AddOn" |
                            MasterSetting == "Other" |
                            CollectToResult < 0 |
                            ReceiveToResult < 0 |
                            is.na(CollectToResult) |
                            is.na(ReceiveToResult), FALSE, TRUE))

  # Remove duplicate tests
  raw_scc <- raw_scc %>%
    filter(!DuplTest)

  # Select columns
  scc_master <- raw_scc[, c("Ward", "WARD_NAME", "WardandName",
                              "ORDER_ID", "REQUESTING_DOC NAME",
                              "MPI", "WORK SHIFT",
                              "TEST_NAME", "Test", "Division", "PRIORITY",
                              "Site", "ICU", "CLINIC_TYPE",
                              "Setting", "SettingRollUp",
                              "MasterSetting", "DashboardSetting",
                              "AdjPriority", "DashboardPriority",
                              "ORDERING_DATE", "COLLECTION_DATE",
                              "RECEIVE_DATE", "VERIFIED_DATE",
                              "ResultedDate",
                              "CollectToReceive", "ReceiveToResult",
                              "CollectToResult",
                              "AddOnMaster", "MissingCollect",
                              "ReceiveResultTarget", "CollectResultTarget",
                              "ReceiveResultInTarget", "CollectResultInTarget",
                              "TATInclude")]
  # Rename columns
  colnames(scc_master) <- c("LocCode", "LocName", "LocConcat",
                             "OrderID", "RequestMD",
                             "MSMRN", "WorkShift",
                             "TestName", "Test", "Division", "OrderPriority",
                             "Site", "ICU", "LocType",
                             "Setting", "SettingRollUp",
                             "MasterSetting", "DashboardSetting",
                             "AdjPriority", "DashboardPriority",
                             "OrderTime", "CollectTime",
                             "ReceiveTime", "ResultTime",
                             "ResultDate",
                             "CollectToReceiveTAT", "ReceiveToResultTAT",
                             "CollectToResultTAT",
                             "AddOnMaster", "MissingCollect",
                             "ReceiveResultTarget", "CollectResultTarget",
                             "ReceiveResultInTarget", "CollectResultInTarget",
                             "TATInclude")

  # Preprocess Sunquest data --------------------------------
  # Correct and format any timestamps that were not imported correctly
  raw_sun[c("OrderDateTime",
            "CollectDateTime",
            "ReceiveDateTime",
            "ResultDateTime")] <-
    lapply(raw_sun[c("OrderDateTime",
                     "CollectDateTime",
                     "ReceiveDateTime",
                     "ResultDateTime")],
           function(x) ifelse(!is.na(x) & str_detect(x, "\\*.*\\*")  == TRUE,
                              str_replace(x, "\\*.*\\*", ""), x))

  raw_sun[c("OrderDateTime",
            "CollectDateTime",
            "ReceiveDateTime",
            "ResultDateTime")] <-
    lapply(raw_sun[c("OrderDateTime",
                     "CollectDateTime",
                     "ReceiveDateTime",
                     "ResultDateTime")],
           as.POSIXct, tz = "UTC", format = "%m/%d/%Y %H:%M:%S")

  # Sunquest lookup references
  # Crosswalk labs included and remove out of scope labs
  raw_sun <- left_join(raw_sun, test_code[, c("Test",
                                               "SUN_TestCode",
                                               "Division")],
                       by = c("TestCode" = "SUN_TestCode"))

  # Determine if test is included based on crosswalk results
  raw_sun <- raw_sun %>%
    mutate(TestIncl = !is.na(Test)) %>%
    filter(TestIncl)


  # Crosswalk unit type
  raw_sun <- left_join(raw_sun, sun_setting,
                       by = c("LocType" = "LocType"))

  # Crosswalk site name
  raw_sun <- left_join(raw_sun, mshs_site,
                       by = c("HospCode" = "DataSite"))

  # Crosswalk units and identify ICUs
  raw_sun <- raw_sun %>%
    mutate(LocandName = paste(LocCode, LocName))

  raw_sun <- left_join(raw_sun, sun_icu[, c("Concatenate", "ICU")],
                       by = c("LocandName" = "Concatenate"))

  raw_sun[is.na(raw_sun$ICU), "ICU"] <- FALSE


  # # Sunquest data formatting-----------------------------
  # Preprocess Sunquest data and add any necessary columns
  raw_sun <- raw_sun %>%
    mutate(
      # Determine if unit is an ICU based on crosswalk results
      ICU = ifelse(is.na(ICU), FALSE, ICU),
      # Create a column for resulted date
      ResultedDate = as.Date(ResultDateTime, format = "%m/%d/%Y"),
      # Create master setting column to identify ICU and IP Non-ICU units
      MasterSetting = ifelse(SettingRollUp == "IP" & ICU, "ICU",
                             ifelse(SettingRollUp == "IP" & !ICU,
                                    "IP Non-ICU", SettingRollUp)),
      # Create dashboard setting column to roll up master settings based on
      # desired dashboard grouping(ie, group ED and ICU together)
      DashboardSetting = ifelse(MasterSetting %in% c("ED", "ICU"), "ED & ICU",
                                MasterSetting),
      #
      # Create column with adjusted priority based on operational assumption
      # that all ED and ICU labs are treated as stat
      AdjPriority = ifelse(MasterSetting %in% c("ED", "ICU") |
                             SpecimenPriority %in% "S", "Stat", "Routine"),
      #
      # Create dashboard priority column
      DashboardPriority = ifelse(
        tat_targets$Priority[match(Test, tat_targets$Test)] == "All", "All",
        AdjPriority),
      #
      # Calculate turnaround times
      CollectToReceive =
        as.numeric(ReceiveDateTime - CollectDateTime, units = "mins"),
      ReceiveToResult =
        as.numeric(ResultDateTime - ReceiveDateTime, units = "mins"),
      CollectToResult =
        as.numeric(ResultDateTime - CollectDateTime, units = "mins"),
      #
      # Determine if order was an add on or original order based on time between
      # order and receive times
      AddOnMaster = ifelse(as.numeric(OrderDateTime - ReceiveDateTime,
                                      units = "mins") > 5, "AddOn", "Original"),
      #
      # Determine if collection time is missing
      MissingCollect = CollectDateTime == OrderDateTime,
      #
      # Determine TAT target based on test, priority, and patient setting
      # Create column concatenating test and priority to determine TAT targets
      Concate1 = paste(Test, DashboardPriority),
      # Create column concatenating test, priority, and setting to determine
      # TAT targets
      Concate2 = paste(Test, DashboardPriority, MasterSetting),
      # Determine Receive to Result TAT target using this logic:
      # 1. Try to match test, priority, and setting (applicable for labs with
      # different TAT targets based on patient setting and order priority)
      # 2. Try to match test and priority (applicable for labs with different
      # TAT targets based on order priority)
      # 3. Try to match test - this is for tests with (applicable for labs with
      # TAT targets that are independent of patient setting or priority)
      #
      # Determine Receive to Result TAT target based on above logic/scenarios
      ReceiveResultTarget =
        # Match on scenario 1
        ifelse(!is.na(match(Concate2, tat_targets$Concate)),
               tat_targets$ReceiveToResultTarget[
                 match(Concate2, tat_targets$Concate)],
               # Match on scenario 2
               ifelse(!is.na(match(Concate1, tat_targets$Concate)),
                      tat_targets$ReceiveToResultTarget[
                        match(Concate1, tat_targets$Concate)],
                      # Match on scenario 3
                      tat_targets$ReceiveToResultTarget[
                        match(Test, tat_targets$Concate)])),
      #
      # Determine Collect to Result TAT target based on above logic/scenarios
      CollectResultTarget =
        # Match on scenario 1
        ifelse(!is.na(match(Concate2, tat_targets$Concate)),
               tat_targets$CollectToResultTarget[
                 match(Concate2, tat_targets$Concate)],
               # Match on scenario 2
               ifelse(!is.na(match(Concate1, tat_targets$Concate)),
                      tat_targets$CollectToResultTarget[
                        match(Concate1, tat_targets$Concate)],
                      # Match on scenario 3
                      tat_targets$CollectToResultTarget[
                        match(Test, tat_targets$Concate)])),
      #
      # Determine if Receive to Result and Collect to Result TAT meet targets
      ReceiveResultInTarget = ReceiveToResult <= ReceiveResultTarget,
      CollectResultInTarget = CollectToResult <= CollectResultTarget,
      #
      # Create column with patient name, order ID, test, collect, receive, and
      # result date and determine if there is a duplicate; order time excluded
      Concate3 = paste(PtNumber, HISOrderNumber, TSTName,
                       CollectDateTime, ReceiveDateTime, ResultDateTime),
      DuplTest = duplicated(Concate3),
      #
      # Determine whether or not to include this particular lab in TAT analysis
      # Exclusion criteria:
      # 1. Add on orders
      # 2. Orders from "Other" settings
      # 3. Orders with collect or receive times after result time
      # 4. Orders with missing collect, receive, or result timestamps
      TATInclude = ifelse(AddOnMaster == "AddOn" |
                            MasterSetting == "Other" |
                            CollectToResult < 0 |
                            ReceiveToResult < 0 |
                            is.na(CollectToResult) |
                            is.na(ReceiveToResult), FALSE, TRUE))

  # Remove duplicate tests
  raw_sun <- raw_sun %>%
    filter(!DuplTest)

  # Select columns
  sun_master <- raw_sun[, c("LocCode", "LocName", "LocandName",
                             "HISOrderNumber", "PhysName",
                             "PtNumber", "SHIFT",
                             "TSTName", "Test", "Division", "SpecimenPriority",
                             "Site", "ICU", "LocType",
                             "Setting", "SettingRollUp",
                             "MasterSetting", "DashboardSetting",
                             "AdjPriority", "DashboardPriority",
                             "OrderDateTime", "CollectDateTime",
                             "ReceiveDateTime", "ResultDateTime",
                             "ResultedDate",
                             "CollecttoReceive", "ReceivetoResult",
                             "CollecttoResult",
                             "AddOnMaster", "MissingCollect",
                             "ReceiveResultTarget", "CollectResultTarget",
                             "ReceiveResultInTarget", "CollectResultInTarget",
                             "TATInclude")]

  colnames(sun_master) <- c("LocCode", "LocName", "LocConcat",
                             "OrderID", "RequestMD",
                             "MSMRN", "WorkShift",
                             "TestName", "Test", "Division", "OrderPriority",
                             "Site", "ICU", "LocType",
                             "Setting", "SettingRollUp",
                             "MasterSetting", "DashboardSetting",
                             "AdjPriority", "DashboardPriority",
                             "OrderTime", "CollectTime",
                             "ReceiveTime", "ResultTime",
                             "ResultDate",
                             "CollectToReceiveTAT", "ReceiveToResultTAT",
                             "CollectToResultTAT",
                             "AddOnMaster", "MissingCollect",
                             "ReceiveResultTarget", "CollectResultTarget",
                             "ReceiveResultInTarget", "CollectResultInTarget",
                             "TATInclude")


  scc_sun_master <- rbind(scc_master, sun_master)

  # Save output data to list
  scc_sun_list <- list(raw_scc, raw_sun, scc_sun_master)
  #
  return(scc_sun_list)

}
```

```{r Data Preprocessing and Merging for SCC and Sunquest data, message = FALSE, warning = FALSE, echo = FALSE}
scc_sun_wday_list <- preprocess_cp(raw_scc = scc_weekday,
                                   raw_sun = sq_weekday)
scc_wday <- scc_sun_wday_list[[1]]
sun_wday <- scc_sun_wday_list[[2]]
scc_sun_wday_master <- scc_sun_wday_list[[3]]

if (is.null(sq_not_weekday) & is.null(scc_not_weekday)) {
  include_not_wday <- FALSE
  scc_sun_not_wday_list <- NULL
  scc_not_wday <- NULL
  sun_not_wday <- NULL
  scc_sun_not_wday_master <- NULL
} else {
  include_not_wday <- TRUE
  scc_sun_not_wday_list <- preprocess_cp(raw_scc = scc_not_weekday,
                                         raw_sun = sq_not_weekday)
  scc_not_wday <- scc_sun_not_wday_list[[1]]
  sun_not_wday <- scc_sun_not_wday_list[[2]]
  scc_sun_not_wday_master <- scc_sun_not_wday_list[[3]]
}

# Remove labs from master data frame that were resulted at exactly midnight on
# next morning or prior day
# Custom function to determine correct number of dates
correct_scc_result_dates <- function(data, number_days) {
  all_resulted_dates_vol <- data %>%
    group_by(ResultDate) %>%
    summarize(VolLabs = n()) %>%
    arrange(desc(VolLabs)) %>%
    ungroup()

  correct_dates <- all_resulted_dates_vol$ResultDate[1:number_days]

  new_data <- data %>%
    filter(ResultDate %in% correct_dates)

  return(new_data)
}

# Update preprocessed data to only include correct dates ----------------------
scc_sun_wday_master <- correct_scc_result_dates(scc_sun_wday_master, 1)

if (scenario == 1) {
  scc_sun_not_wday_master <- correct_scc_result_dates(scc_sun_not_wday_master,
                                                      3)
} else if (scenario == 2) {
  scc_sun_not_wday_master <- correct_scc_result_dates(scc_sun_not_wday_master,
                                                      2)
} else if (scenario == 3) {
  scc_sun_not_wday_master <- correct_scc_result_dates(scc_sun_not_wday_master,
                                                      1)
}


# Determine resulted date for weekday labs
wday_result_date <- format(unique(scc_sun_wday_master$ResultDate),
                           format = "%a %m/%d/%y")


if (!is.null(scc_sun_not_wday_master)) {
  not_wday_result_date <- sort(unique(scc_sun_not_wday_master$ResultDate))
  wkend_holiday_result_date <- ifelse(
    length(not_wday_result_date) == 1,
    format(not_wday_result_date, format = "%a %m/%d/%y"),
    paste0(format(not_wday_result_date[1],
                  format = "%a %m/%d/%y"),
           "-",
           format(not_wday_result_date[length(not_wday_result_date)],
                  format = "%a %m/%d/%y")))
} else {
  wkend_holiday_result_date <- NULL
}
```

```{r Summarize weekday and weekend/holiday data for dashboard tables and repository, eval = FALSE, echo = FALSE, warning = FALSE, message = FALSE}
#
# Summarize weekday data by site, date, test, setting, priority, etc.-------
cp_wday_summary <- scc_sun_wday_master %>%
  group_by(Site,
           ResultDate,
           Test,
           Division,
           Setting,
           SettingRollUp,
           MasterSetting,
           DashboardSetting,
           OrderPriority,
           AdjPriority,
           DashboardPriority,
           ReceiveResultTarget,
           CollectResultTarget) %>%
  summarize(TotalResulted = n(),
            TotalResultedTAT = sum(TATInclude),
            TotalReceiveResultInTarget =
              sum(ReceiveResultInTarget[TATInclude]),
            TotalCollectResultInTarget =
              sum(CollectResultInTarget[TATInclude]),
            TotalAddOnOrder = sum(AddOnMaster == "AddOn"),
            TotalMissingCollections = sum(MissingCollect[TATInclude]),
            .groups = "keep") %>%
  arrange(Site, ResultDate) %>%
  ungroup()


# Summarize and bind weekday and non-weekday data, if any exists
if (!is.null(scc_sun_not_wday_master)) {
  # Summarize weekend/holiday data by site, date, test, setting, priority, etc.
  cp_not_wday_summary <- scc_sun_not_wday_master %>%
    group_by(Site,
             ResultDate,
             Test,
             Division,
             Setting,
             SettingRollUp,
             MasterSetting,
             DashboardSetting,
             OrderPriority,
             AdjPriority,
             DashboardPriority,
             ReceiveResultTarget,
             CollectResultTarget) %>%
    summarize(TotalResulted = n(),
              TotalResultedTAT = sum(TATInclude),
              TotalReceiveResultInTarget =
                sum(ReceiveResultInTarget[TATInclude]),
              TotalCollectResultInTarget =
                sum(CollectResultInTarget[TATInclude]),
              TotalAddOnOrder = sum(AddOnMaster == "AddOn"),
              TotalMissingCollections = sum(MissingCollect[TATInclude]),
              .groups = "keep") %>%
    arrange(Site, ResultDate) %>%
    ungroup()
  #
  # Combine weekday and weekend data into dataframe for repository
  cp_all_days <- rbind(cp_wday_summary, cp_not_wday_summary)
} else {
  #
  # Create dataframe for repository
  cp_all_days <- cp_wday_summary
}

# Open existing repository
# existing_repo <- read_excel(
#   choose.files(default = user_path,
#                caption = "Select SCC and Sunquest Historical Repository"),
#   sheet = 1, col_names = TRUE)
existing_repo <- readRDS(file =
  choose.files(default = paste0(user_directory,
                                "/SCC Sunquest Historical Repo",
                                "/*.*"),
               caption = "Select SCC and Sunquest Historical Repository"))

# Convert ResultDate from date-time to date
existing_repo <- existing_repo %>%
   mutate(ResultDate  = date(ResultDate))

# Bind new data with existing repository
cp_repo <- rbind(existing_repo, cp_all_days)

# Remove any duplicates
cp_repo <- unique(cp_repo)

# Determine earliest and latest date in repository for use in file name
start_date <- format(min(cp_repo$ResultDate), "%m%d%y")
end_date <- format(max(cp_repo$ResultDate), "%m%d%y")

# Save updated repository
# write_xlsx(scc_sun_repo, path = paste0(user_directory,
#                                        "\\SCC Sunquest Historical Repo",
#                                        "\\Hist Repo Test ", start_date, " to",
#                                        end_date, " Created ", Sys.Date(),
#                                        ".xlsx"))
saveRDS(cp_repo, file = paste0(user_directory,
                                    "/SCC Sunquest Historical Repo",
                                    "/Hist Repo ", start_date, " to ",
                                    end_date, " Created ",
                                    format(Sys.Date(), "%m%d%y"), ".RDS"))
```


```{r Custom function for preprocessing raw Powerpath and Epic data and calling function, warning = FALSE, message = FALSE, echo = FALSE}

#create a function to prepare cytology data for pre-processing
cyto_prep <- function(epic_data, raw_data) {
  if (is.null(raw_data) || nrow(raw_data) == 0) {
    raw_data <- NULL
    epic_data <- NULL
  } else {
    #preprocessing for epic data
    #we are only looking for the specimens that were finalized/final
    #edited in epic
    epic_data_final <-
      epic_data[which(epic_data$LAB_STATUS == "Final result" |
                           epic_data$LAB_STATUS == "Edited Result - FINAL"), ]

    globalVariables(names(epic_data_final))

    #get only the SPECIMEN_ID Column from Epic data
    epic_data_spec <- NULL
    epic_data_spec <- as.data.frame(epic_data_final$SPECIMEN_ID)
    colnames(epic_data_spec) <- c("Case_no")

    #keep only the unique spec IDs
    epic_data_spec <- unique(epic_data_spec)

    # create an extra column for old Fcaility
    raw_data <- raw_data %>%
      mutate(Facility_Old = Facility)

    raw_data$Facility[raw_data$Facility_Old == "MSS"] <- "MSH"
    raw_data$Facility[raw_data$Facility_Old == "STL"] <- "SL"
    raw_data$spec_group[raw_data$spec_group == "BREAST"] <- "Breast"

    #--------------Extract the Cytology GYN and NON-GYN Data Only------------#
    #Cytology
    #Keep the cyto gyn and cyto non-gyn

    cyto_raw <-
      raw_data[which((raw_data$spec_group == "CYTO NONGYN" |
                          raw_data$spec_group == "CYTO GYN") &
                         raw_data$spec_sort_order == "A"), ]

    cyto_final <- merge(x = cyto_raw, y = epic_data_spec)
    }

  return(cyto_final)

  }

cyto_weekday_final <- cyto_prep(epic_weekday, pp_weekday)

#create a function to prepare pathology data for pre-processing

patho_prep <- function(raw_data, gi_codes) {
  if (is.null(raw_data) || nrow(raw_data) == 0) {
    raw_data <- NULL
    } else {

    #------------Extract the All Breast and GI specs Data Only--------------#
    #Merge the exclusion/inclusion cloumn into the modified powerpath Dataset
    #for weekdays and not weekdays

    raw_data <- merge(x = raw_data, y = gi_codes, all.x = TRUE)

    #find case numbers with GI_Code = exclude
    exclude_gi_codes_df <-
      raw_data[
        which
        ((
          raw_data$spec_group == "GI") &
            (raw_data$GI.Codes.Must.Include.in.Analysis..All.GI.Biopsies. ==
               "Exclude")), ]

    must_exclude_cnum <- unique(exclude_gi_codes_df$Case_no)

    #this dataframe has all the GI specs and biopsies that should be excluded
    #it includes any biopsy that came with another excluded code
    #this DF is only for our reference
    must_exclude_cnum_df <-
      raw_data[which(raw_data$Case_no %in% must_exclude_cnum), ]

    sp_data <-
      raw_data[which((((raw_data$spec_group == "GI") &
                           (!(raw_data$Case_no %in% must_exclude_cnum))) |
                          (raw_data$spec_group == "Breast")) &
                         raw_data$spec_sort_order == "A"), ]

    sp_data <-
      sp_data[which(
        sp_data$Facility != "NYEE"), ]
    }

  return(sp_data)

  }

sp_weekday <- patho_prep(pp_weekday, gi_codes)

#------------------------------Data Pre-Processing-----------------------------#
############Create a function for Data pre-processing############

pre_processing_pp <- function(raw_data) {
  if (is.null(raw_data) || nrow(raw_data) == 0) {
    raw_data_ps <- NULL
    raw_data_new <- NULL
    vol_cases_signed <- NULL
    vol_cases_signed_strat <- NULL
    patient_metric <- NULL
    lab_metric <- NULL
    lab_metric_v2 <- NULL
    processed_data_table_v2 <- NULL
    processed_data_table <- NULL
    summarized_table <- NULL
    return_tables <- NULL
    } else {
    #vlookup the Rev_Center and its corresponding patient setting for the
      #PowerPath Data
    raw_data_ps <- merge(x = raw_data, y = patient_setting, all.x = TRUE)

    #make sure to fix the MSBK patient type based on the extra column in the
    #new report

    raw_data_ps$Patient.Setting[raw_data_ps$Rev_ctr == "MSBK" &
                                  (raw_data_ps$patient_type == "A" |
                                     raw_data_ps$patient_type == "O")] <- "Amb"

    raw_data_ps$Patient.Setting[raw_data_ps$Rev_ctr == "MSBK" &
                                  raw_data_ps$patient_type == "IN"] <- "IP"

    #vlookup targets based on spec_group and patient setting
    raw_data_new <- merge(x = raw_data_ps, y = tat_targets_ap,
                          all.x = TRUE, by = c("spec_group", "Patient.Setting"))

    #check if any of the dates was imported as char
    if (is.character(raw_data_new$Collection_Date)) {
      raw_data_new <- raw_data_new %>%
        mutate(Collection_Date = as.numeric(Collection_Date)) %>%
        mutate(Collection_Date = as.Date(Collection_Date,
                                         origin = "1899-12-30"))
      } else {
      raw_data_new <- raw_data_new %>%
        mutate(Collection_Date = Collection_Date)
      }
    #Change all Dates into POSIXct format to start the calculations
    raw_data_new[c("Case_created_date",
                   "Collection_Date",
                   "Received_Date",
                   "signed_out_date")] <-
      lapply(raw_data_new[c("Case_created_date",
                            "Collection_Date",
                            "Received_Date",
                            "signed_out_date")],
             as.POSIXct, tz = "", format = "%m/%d/%y %I:%M %p")

    #add columns for calculations:
    #collection to signed out and received to signed out
    #collection to signed out
    #All days in the calendar
    raw_data_new <- raw_data_new %>%
      mutate(Collection_to_signed_out =
               as.numeric(difftime(signed_out_date, Collection_Date,
                                   units = "days")))
    #recieve to signed out
    #without weekends and holidays
    raw_data_new <- raw_data_new %>%
      mutate(Received_to_signed_out = bizdays(Received_Date, signed_out_date))

    #prepare data for first part accessioned volume analysis
    #1. Find the date that we need to report --> the date of the last weekday
    acc_date <- as.Date(raw_data_new$signed_out_date[1])
    
    #2. count the accessioned volume that was accessioned on that date
    #from the cyto report
    raw_data_new$acc_date_only <- as.Date(raw_data_new$Received_Date)
    
    #summarize the data to be used for analysis and to be stored as historical
    #repo
    summarized_table <-
      summarise(
        group_by(raw_data_new,
                 Spec_code,
                 spec_group,
                 Facility,
                 Patient.Setting,
                 Rev_ctr,
                 as.Date(signed_out_date),
                 weekdays(as.Date(signed_out_date)),
                 Received.to.signed.out.target..Days.,
                 Collected.to.signed.out.target..Days.,
                 acc_date_only,
                 weekdays(acc_date_only)),
        no_cases_signed = n(),
        lab_metric_tat_avg = round(mean(Received_to_signed_out,
                                        na.rm = TRUE), 0),
        lab_metric_tat_med = round(median(Received_to_signed_out,
                                          na.rm = TRUE), 0),
        lab_metric_tat_sd = round(sd(Received_to_signed_out, na.rm = TRUE), 1),
        lab_metric_within_target = as.numeric(format(
          round(
            sum(Received_to_signed_out <= Received.to.signed.out.target..Days.,
                na.rm = TRUE) / sum(
                  Received_to_signed_out >= 0, na.rm = TRUE), 2))),
        patient_metric_tat_avg = as.numeric(format(
          ceiling(mean(Collection_to_signed_out, na.rm = TRUE)))),
        patient_metric_tat_med = round(median(Collection_to_signed_out,
                                              na.rm = TRUE), 0),
        patient_metric_tat_sd = round(sd(Collection_to_signed_out,
                                        na.rm = TRUE), 1),
        cyto_acc_vol = as.numeric(sum(acc_date == acc_date_only,
                                   na.rm = TRUE)))

    #standardize the name for the current summary to match the historical repo
    colnames(summarized_table) <-
      c("Spec_code", "Spec_group", "Facility", "Patient_setting", "Rev_ctr",
    "Signed_out_date_only", "Signed_out_day_only", "Lab_metric_target",
    "Patient_metric_target", "acc_date_only", "acc_day_only",
    "No_cases_signed_out", "Lab_metric_avg", "Lab_metric_med", "Lab_metric_std",
    "Lab_metric_within_target", "Patient_metric_avg", "Patient_metric_med",
    "Patient_metric_std", "cyto_acc_vol")

    #Calculate total number of cases signed per spec group
    vol_cases_signed <- summarise(group_by(summarized_table,
                                           Spec_group,
                                           Patient_setting),
                                  no_cases_signed = sum(No_cases_signed_out,
                                                        na.rm = TRUE))

    #Calculate total number of cases signed out per spec_group per facility
    vol_cases_signed_strat <- summarise(group_by(summarized_table,
                                                 Spec_group,
                                                 Facility,
                                                 Patient_setting),
                                        no_cases_signed =
                                          sum(No_cases_signed_out,
                                              na.rm = TRUE))

    vol_cases_signed_strat <- dcast(
      vol_cases_signed_strat,
      Spec_group + Patient_setting ~ Facility, value.var = "no_cases_signed")

    vol_cases_signed_strat[is.na(vol_cases_signed_strat)] <- 0    

    #Calculate average collection to signed out
    patient_metric <- summarise(group_by(summarized_table,
                                         Spec_group,
                                         Facility,
                                         Patient_setting),
                          avg_collection_to_signed_out =
                            format(
                              round(
                                sum(
                                  (Patient_metric_avg * No_cases_signed_out) /
                                    sum(No_cases_signed_out),
                                  na.rm = TRUE), 0)))

    patient_metric <- dcast(patient_metric,
                            Spec_group + Patient_setting ~ Facility,
                            value.var = "avg_collection_to_signed_out")

    #Calculate % Receive to result TAT within target

    #this part of the code creates the table for the received to result TAT
    #within target with an assumption that the receive to result is not 
    #centralized which means it is stratified by facility
    lab_metric <- summarise(group_by(summarized_table,
                                     Spec_group,
                                     Facility,
                                     Patient_setting),
                            received_to_signed_out_within_target =
                              format(
                                round(
                                  sum(
                                    (Lab_metric_within_target *
                                       No_cases_signed_out) /
                                      sum(No_cases_signed_out),
                                    na.rm = TRUE), 2)))

    lab_metric <- dcast(lab_metric,
                        Spec_group + Patient_setting ~ Facility,
                        value.var = "received_to_signed_out_within_target")

    #this part of the code creates the table for the received to result TAT
    #within target with an assumption that the receive to result is centralized
    lab_metric_v2 <- summarise(group_by(summarized_table,
                                     Spec_group,
                                     Patient_setting),
                            received_to_signed_out_within_target =
                              format(
                                round(
                                  sum(
                                    (Lab_metric_within_target *
                                       No_cases_signed_out) /
                                      sum(No_cases_signed_out),
                                    na.rm = TRUE), 2)))  


    #here I will merge number of cases signed, received to result TAT,
    #and acollect to result TAT calcs into one table
    processed_data_table <-
      left_join(full_join(vol_cases_signed, lab_metric),
                patient_metric,
                by = c("Spec_group", "Patient_setting"))
    processed_data_table <-
      processed_data_table[!(processed_data_table$Patient_setting == "Other"), ]

    processed_data_table_v2 <-
      left_join(full_join(vol_cases_signed, lab_metric_v2),
                patient_metric,
                by = c("Spec_group", "Patient_setting"))
    processed_data_table_v2 <-
      processed_data_table_v2[!(processed_data_table_v2$Patient_setting ==
                                  "Other"), ]
    
    cyto_acc_vol1 <- summarise(group_by(summarized_table, Spec_group),
                               cyto_acc_vol1 = 
                                 as.numeric(sum(cyto_acc_vol,
                                   na.rm = TRUE)))
    

    return_tables <- list(processed_data_table,
                          processed_data_table_v2,
                          vol_cases_signed_strat,
                          raw_data_new,
                          summarized_table,
                          cyto_acc_vol1)
  }
  return(return_tables)
}

#This table will give us the summarized TAT for cyto with an assumption that
#receive to result is not centralized.
cyto_table_weekday <-
  pre_processing_pp(cyto_weekday_final)[[1]]

#This table will give us the summarized TAT for cyto with an assumption that
#receive to result is centralized.
cyto_table_weekday_v2 <-
  pre_processing_pp(cyto_weekday_final)[[2]]

#this table summarizes the volume for cyto per hospital per patient setting
cyto_strat_vol_weekday <-
  pre_processing_pp(cyto_weekday_final)[[3]]

#this table gives the processed and cleaned raw cyto data only
cyto_table_weekday_raw <-
  pre_processing_pp(cyto_weekday_final)[[4]]

#this table gives the summarized cyto data for historical repo
cyto_table_weekday_summarized <- pre_processing_pp(cyto_weekday_final)[[5]]

#this table gives the volume of the accessioned specimens of the specific 
#accessioned date. This table will be used to poduce the total accession volume
cyto_acc_vol1 <- pre_processing_pp(cyto_weekday_final)[[6]]

#This table will give us the summarized TAT for surgical pathology
#with an assumption that receive to result is not centralized.
sp_table_weekday <-
  pre_processing_pp(sp_weekday)[[1]]

#this table summarizes the volume for surgical pathology per hospital per
#patient setting
sp_strat_vol_weekday <-
  pre_processing_pp(sp_weekday)[[3]]

#this table gives the processed and cleaned raw surgical pathology data only
sp_table_weekday_raw <-
  pre_processing_pp(sp_weekday)[[4]]

#this table gives the summarized surgical pathology data for historical repo
sp_table_weekday_summarized <- pre_processing_pp(sp_weekday)[[5]]

```

```{r Cytology backlog preprocessing and analysis, echo=FALSE, warning = FALSE, message=FALSE}

cyto_backlog_tbl <- function(cyto_backlog_raw) {
  #cyto backlog Calculation
  #vlookup the Rev_Center and its corresponding patient setting for the
  #PowerPath Data

  cyto_backlog_ps <- merge(x = cyto_backlog_raw, y = patient_setting,
                           all.x = TRUE)

  #vlookup targets based on spec_group and patient setting
  cyto_backlog_ps_target <- merge(x = cyto_backlog_ps, y = tat_targets_ap,
                                  all.x = TRUE,
                                  by = c("spec_group", "Patient.Setting"))

  #Keep the cyto gyn and cyto non-gyn
  cyto_backlog <-
    cyto_backlog_ps_target[which(
      cyto_backlog_ps_target$spec_group == "CYTO NONGYN" |
        cyto_backlog_ps_target$spec_group == "CYTO GYN"), ]

  #Change all Dates into POSIXct format to start the calculations
  cyto_backlog[c("Case_created_date", "Collection_Date", "Received_Date",
                 "signed_out_date")] <-
    lapply(cyto_backlog[c("Case_created_date", "Collection_Date",
                          "Received_Date", "signed_out_date")],
           as.POSIXct, tz = "", format = "%m/%d/%y %I:%M %p")

  #Backlog Calculations: Date now - case created date
  #without weekends and holidays, subtract one so we don't include today's date

  cyto_backlog$backlog <-
    bizdays(cyto_backlog$Case_created_date, today) - 1

  cyto_backlog$acc_date_only <- as.Date(cyto_backlog$Received_Date)

  acc_date <- cyto_table_weekday_summarized$Signed_out_date_only[1]

  #summarize the data to be used for analysis and to be stored as historical
  #repo
  summarized_table <-
    summarise(
      group_by(cyto_backlog,
               Spec_code,
               spec_group,
               Facility,
               Patient.Setting,
               Rev_ctr,
               acc_date_only,
               weekdays(acc_date_only)),
      cyto_backlog = format(
            round(
              sum(
                backlog > Received.to.signed.out.target..Days.,
                na.rm = TRUE), 0)),

      percentile_25th =
        format(
          ceiling(
            quantile(
              backlog[backlog > Received.to.signed.out.target..Days.],
              prob = 0.25, na.rm = TRUE))),

      percentile_50th =
        format(
          ceiling(
            quantile(
              backlog[backlog > Received.to.signed.out.target..Days.],
              prob = 0.5, na.rm = TRUE))),

      maximum = format(
        ceiling(
          max(
            backlog[backlog > Received.to.signed.out.target..Days.],
            na.rm = TRUE))),

      cyto_acc_vol = as.numeric(sum(acc_date == acc_date_only,
                                     na.rm = TRUE)))

  summarized_table$maximum[summarized_table$maximum == "-Inf"] <- "NA"

  #standardize the name for the current summary to match the historical repo
  colnames(summarized_table) <-
    c("Spec_code", "Spec_group", "Facility", "Patient_setting", "Rev_ctr",
    "acc_date_only", "acc_day_only", "cyto_backlog", "percentile_25th",
    "percentile_50th", "maximum", "cyto_acc_vol")

  cyto_backlog_vol <- summarise(group_by(summarized_table, Spec_group),
                                cyto_backlog = sum(as.numeric(cyto_backlog), na.rm = TRUE),
                                percentile_25th = ceiling(quantile(as.numeric(percentile_25th),
                                                           prob = 0.25,
                                                           na.rm = TRUE)),
                                percentile_50th = ceiling(quantile(as.numeric(percentile_50th),
                                                           prob = 0.5,
                                                           na.rm = TRUE)), 
                                maximum = ceiling(max(as.numeric(maximum), na.rm = TRUE))
                                )

  cyto_backlog_vol$maximum[cyto_backlog_vol$maximum == "-Inf"] <- "NA"
  #Days of work
  cyto_case_vol_dow <- as.numeric(cyto_backlog_vol$cyto_backlog[1]) / 80

  #count the accessioned volume that was accessioned on that date
  #from the backlog report
  cyto_acc_vol2 <-
    summarise(
      group_by(
        summarized_table,
        Spec_group),
      cyto_acc_vol2 = as.numeric(sum(cyto_acc_vol,
                                   na.rm = TRUE)))
  #sum the two counts
  cyto_acc_vol3 <- merge(x = cyto_acc_vol1, y = cyto_acc_vol2)
  
  cyto_acc_vol3$total_acc_vol <-
    cyto_acc_vol3$cyto_acc_vol1 + cyto_acc_vol3$cyto_acc_vol2
  
  cyto_acc_vol3$cyto_acc_vol1 <- NULL
  cyto_acc_vol3$cyto_acc_vol2 <- NULL
  
  backlog_acc_table <- merge(x = cyto_acc_vol3,
                             y = cyto_backlog_vol,
                             all = TRUE)
  
  table_temp_backlog_acc <- data.frame(matrix(ncol = 6, nrow = 2))
  colnames(table_temp_backlog_acc) <- c("Spec_group",
                                        "total_accessioned_volume",
                                        "cyto_backlog",
                                        "percentile_25th",
                                        "percentile_50th",
                                        "maximum")
  
  table_temp_backlog_acc[1] <- c("CYTO GYN", "CYTO NONGYN")
  
  backlog_acc_table_new <- merge(x = table_temp_backlog_acc,
                                 y = backlog_acc_table, all.y = TRUE)
  
  backlog_acc_table_new2 <- merge(x = table_temp_backlog_acc[1],
                                  y = backlog_acc_table,
                                  all.x = TRUE, by = c("Spec_group"))
  
  backlog_acc_table_new2[is.na(backlog_acc_table_new2)] <- 0
  
  #added this line to delete the cyto gyn from the table until we get correct data
  #currently not in use
  backlog_acc_table_new3 <- backlog_acc_table_new2[-c(1), ]
  
  return_tables <- list(backlog_acc_table_new2, summarized_table)
  
  return(return_tables)
}

backlog_acc_table_new2 <- cyto_backlog_tbl(cyto_backlog_raw)[[1]]
cyto_backlog_summarized <- cyto_backlog_tbl(cyto_backlog_raw)[[2]]

```

```{r Add the current summary to the historical repo for cytology/pathology, echo = FALSE, warning = FALSE, message = FALSE, eval = TRUE}

#1. import the historical repo
historical_repo <- read_excel(
  paste0(user_directory, "/AP & Cytology Historical Repo/",
         "Historical_Repo_Surgical_Pathology", "_", yesterday, ".xlsx"))

#2. append all the summary tables together

#bind the cyto repo with the surgical pathology repo to prepare for the
#merge with the historical repo
current_summary <- rbind(cyto_table_weekday_summarized,
                         sp_table_weekday_summarized)

#make sure that the summarized data is a data frame
current_summary <- as.data.frame(current_summary)

#make sure the data types for both dataframes are the same
common <-
  names(historical_repo)[names(historical_repo) %in% names(current_summary)]

historical_repo[common] <- lapply(common, function(x) {
  match.fun(paste0("as.", class(current_summary[[x]])))(historical_repo[[x]])
})

#3. combine the current summary with the historical repo and write them
#into a xlsx file

historical_repo_updated <- rbind(historical_repo, current_summary)

#4. to ensure that the selected rows are the unique ones only without
#any dupilacation

historical_repo_updated <- unique(historical_repo_updated)

xlsx_file_name <- paste0(user_directory, "/AP & Cytology Historical Repo/",
                       "Historical_Repo_Surgical_Pathology", "_",
                       today, ".xlsx")

write_xlsx(historical_repo_updated, xlsx_file_name)

```

```{r Add the current summary to the historical repo for cytology backlog, echo = FALSE, warning = FALSE, message = FALSE, eval = TRUE}

backlog_repo <- read_excel(
  paste0(user_directory, "/AP & Cytology Historical Repo/",
         "Backlog_Repo", "_", yesterday, ".xlsx"))

#make sure that the summarized data is a data frame
cyto_backlog_df <- as.data.frame(cyto_backlog_summarized)

#make sure the data types for both dataframes are the same
common <-
  names(backlog_repo)[names(backlog_repo) %in% names(cyto_backlog_df)]

backlog_repo[common] <- lapply(common, function(x) {
  match.fun(paste0("as.", class(cyto_backlog_df[[x]])))(backlog_repo[[x]])
})

#3. combine the current summary with the historical repo and write them
#into a xlsx file

backlog_repo_updated <- rbind(backlog_repo, cyto_backlog_df)

#4. to ensure that the selected rows are the unique ones only without
#any dupilacation

backlog_repo_updated <- unique(backlog_repo_updated)

backlog_file_name <- paste0(user_directory, "/AP & Cytology Historical Repo/",
                       "Backlog_Repo", "_", today, ".xlsx")

write_xlsx(backlog_repo_updated, backlog_file_name)

```

```{r Create dataframe templates for TAT and volume tables}
# Create template dataframes for combinations of tests, priority, and settings
# that will be used in TAT and volume look back tables. These templates ensure
# all relevant combinations are included in the tables regardless of resulted
# volume
# Create template data frames for combinations of tests, priority and settings
# that will be used in TAT tables and volume lookback tables
test_name_division <- unique(test_code[, c("Division", "Test")])

test_names <- unique(test_code$Test)

# Create data frame of test and site combinations
rep_test_site <- sort(rep(test_names, length(city_sites)))

rep_sites <- rep(city_sites, length(test_names))

test_site_comb <- data.frame("Test" = rep_test_site,
                             "Site" = rep_sites,
                             stringsAsFactors = FALSE)

# Create data frame of test and priority combinations
rep_test_priority <- sort(rep(test_names, length(dashboard_priority_order)))

rep_priority <- rep(dashboard_priority_order, length(test_names))

test_priority_comb <- data.frame("Test" = rep_test_priority,
                                "DashboardPriority" = rep_priority,
                                stringsAsFactors = FALSE)

# Create data frame of test and setting combinations for TAT tables
rep_test_setting_tat <- sort(rep(test_names, length(dashboard_pt_setting)))

rep_setting_tat <- rep(dashboard_pt_setting, length(test_names))

test_setting_comb_tat <- data.frame("Test" = rep_test_setting_tat,
                                "DashboardSetting" = rep_setting_tat,
                                stringsAsFactors = FALSE)

# Create data frame of test and setting combinations for volume lookback tables
rep_test_setting_vol <- sort(rep(test_names, length(pt_setting_order)))

rep_setting_vol <- rep(pt_setting_order, length(test_names))

test_setting_comb_vol <- data.frame("Test" = rep_test_setting_vol,
                                "PtSetting" = rep_setting_vol,
                                stringsAsFactors = FALSE)

# Combine data frames to create data frame with all combinations of tests,
# sites, priority, and settings for both TAT tables and lookback tables
test_site_prty <- left_join(test_site_comb,
                            test_priority_comb,
                            by = c("Test" = "Test"))

test_site_prty_setting_tat <- left_join(test_site_prty,
                                   test_setting_comb_tat,
                                   by = c("Test" = "Test"))

test_site_prty_setting_tat <- left_join(test_site_prty_setting_tat,
                                    unique(test_code[, c("Test", "Division")]),
                                    by = c("Test" = "Test"))

test_site_prty_setting_vol <- left_join(test_site_prty,
                                   test_setting_comb_vol,
                                   by = c("Test" = "Test"))

test_site_prty_setting_vol <- left_join(test_site_prty_setting_vol,
                                    unique(test_code[, c("Test", "Division")]),
                                    by = c("Test" = "Test"))

# Select applicable test, priority, setting combinations based on lab operations
tat_dashboard_templ <- test_site_prty_setting_tat %>%
  mutate(
    # Create column for applicable combinations
    Incl = ifelse(
      # Remove ED & ICU labs with Routine priority since all labs in these
      # these settings are treated as stat
      (DashboardPriority %in% c("Routine") &
         DashboardSetting %in% c("ED & ICU")) |
        # Remove ambulatory troponin and lactate since these labs are collected
        # in ambulatory settings. Remove stat and routine stratification for
        # these labs since all are treated as stat.
        (Test %in% c("Troponin", "Lactate WB") &
           (DashboardPriority %in% c("Stat", "Routine") |
              DashboardSetting %in% c("Amb"))) |
        # Remove "all" priority for BUN, PT, and HGB labs
        (Test %in% c("BUN", "PT", "HGB") & DashboardPriority %in% c("All")) |
        # Remove priority stratification for rapid flu and c. diff since all
        # are treated as stat
        (Test %in% c("Rapid Flu", "C. diff") &
           !(DashboardPriority %in% c("All"))), "Excl", "Incl")) %>%
  filter(Incl == "Incl")

vol_dashboard_templ <- test_site_prty_setting_vol %>%
  mutate(
    # Create column for applicable combinations
    Incl = ifelse(
      # Remove ED & ICU labs with Routine priority since all labs in these
      # these settings are treated as stat
      (DashboardPriority %in% c("Routine") &
         PtSetting %in% c("ED", "ICU")) |
        # Remove stat and routine stratification for troponin and lactate labs
        # these labs since all are treated as stat
        (Test %in% c("Troponin", "Lactate WB") &
           (DashboardPriority %in% c("Stat", "Routine"))) |
        # Remove "all" priority for BUN, PT, and HGB labs
        (Test %in% c("BUN", "PT", "HGB") & DashboardPriority %in% c("All")) |
        # Remove Microbiology RRL since resulted volume is included already in
        # TAT tables
        (Division %in% c("Microbiology RRL")), "Excl", "Incl")) %>%
  filter(Incl == "Incl")

```


```{r Custom Functions for subsetting and summarizing CP data for dashboard tables, warning = FALSE, message = FALSE, echo = FALSE}
# Custom function to subset and summarize data for each lab division ----------
summarize_cp_tat <- function(x, lab_division) {
  # Subset data to be included based on lab division, whether or not TAT
  # meets inclusion criteria, and site location
  lab_div_df <- x %>%
    filter(Division == lab_division &
             Site %in% city_sites)
  #
  # Summarize data based on test, site, priority, setting, and TAT targets.
  lab_summary <- lab_div_df %>%
    group_by(Test,
             Site,
             DashboardPriority,
             DashboardSetting,
             ReceiveResultTarget,
             CollectResultTarget) %>%
    summarize(ResultedVolume = sum(TotalResultedTAT),
              ReceiveResultInTarget = sum(TotalReceiveResultInTarget),
              CollectResultInTarget = sum(TotalCollectResultInTarget),
              ReceiveResultPercent = round(
                ReceiveResultInTarget / ResultedVolume, digits = 3),
              CollectResultPercent = round(
                CollectResultInTarget / ResultedVolume, digits = 3),
              .groups = "keep") %>%
    ungroup()
  #
  # Subset template data frame for this division
  lab_div_df_templ <- tat_dashboard_templ %>%
    mutate(Incl = NULL) %>%
    filter(Division == lab_division)
  #
  # Combine lab summary with template data frame for this division for
  # dashboard visualization
  lab_summary <- left_join(lab_div_df_templ, lab_summary,
                           by = c("Test" = "Test",
                                  "Site" = "Site",
                                  "DashboardPriority" = "DashboardPriority",
                                  "DashboardSetting" = "DashboardSetting"))
  #
  # Format relevant columns as factors, look up target TAT for labs with 0
  # resulted volume, add formatting for percent within targets
  lab_summary <- lab_summary %>%
    mutate(
      #
      # Set test, site, priority, and setting as factors
      Test = droplevels(factor(Test, levels = test_names, ordered = TRUE)),
      Site = droplevels(factor(Site, levels = city_sites, ordered = TRUE)),
      DashboardPriority = droplevels(factor(DashboardPriority,
                                            levels = dashboard_priority_order,
                                            ordered = TRUE)),
      DashboardSetting = droplevels(factor(DashboardSetting,
                                           levels = dashboard_pt_setting,
                                           ordered = TRUE)),
      #
      # Determine TAT target for sites with 0 resulted labs
      # Create column concatenating test and priority to determine TAT targets
      Concate1 = paste(Test, DashboardPriority),
      # Create column concatenating test, priority, and setting to determine
      # TAT targets
      Concate2 = paste(Test, DashboardPriority, DashboardSetting),
      # Determine Receive to Result TAT target using this logic:
      # 1. Try to match test, priority, and setting (applicable for labs with
      # different TAT targets based on patient setting and order priority)
      # 2. Try to match test and priority (applicable for labs with different
      # TAT targets based on order priority)
      # 3. Try to match test - this is for tests with (applicable for labs with
      # TAT targets that are independent of patient setting or priority)
      #
      # Determine Receive to Result TAT target based on above logic/scenarios
      ReceiveResultTarget =
        # If TAT target is known, keep TAT target
        ifelse(!is.na(ReceiveResultTarget), ReceiveResultTarget,
               # Try to match on scenario 1
               ifelse(
                 !is.na(match(Concate2, tat_targets$Concate)),
                 tat_targets$ReceiveToResultTarget[
                   match(Concate2, tat_targets$Concate)],
                 # Try to match on scenario 2
                 ifelse(
                   !is.na(match(Concate1, tat_targets$Concate)),
                   tat_targets$ReceiveToResultTarget[
                     match(Concate1, tat_targets$Concate)],
                   # Try to match on scenario 3
                   tat_targets$ReceiveToResultTarget[
                     match(Test, tat_targets$Concate)]))),
      #
      # Determine Collect to Result TAT target based on above logic/scenarios
      # Determine Receive to Result TAT target based on above logic/scenarios
      CollectResultTarget =
        # If TAT target is known, keep TAT target
        ifelse(!is.na(CollectResultTarget), CollectResultTarget,
               # Try to match on scenario 1
               ifelse(
                 !is.na(match(Concate2, tat_targets$Concate)),
                 tat_targets$CollectToResultTarget[
                   match(Concate2, tat_targets$Concate)],
                 # Try to match on scenario 2
                 ifelse(
                   !is.na(match(Concate1, tat_targets$Concate)),
                   tat_targets$CollectToResultTarget[
                     match(Concate1, tat_targets$Concate)],
                   # Try to match on scenario 3
                   tat_targets$CollectToResultTarget[
                     match(Test, tat_targets$Concate)]))),
      #
      # Format target TAT for tables from numbers to "<=X min"
      ReceiveResultTarget = paste0("<=", ReceiveResultTarget, " min"),
      CollectResultTarget = paste0("<=", CollectResultTarget, " min"),
      #
      # Format percentage of labs in target
      ReceiveResultPercent = percent(ReceiveResultPercent, digits = 0),
      CollectResultPercent = percent(CollectResultPercent, digits = 0),
      #
      # Apply conditional color formatting to TAT percentages based on status
      # definitions for each lab division
      #
      # Chemistry & Hematology:
      # Green: >= 95%, Yellow: >= 80% & < 95%, Red: < 80%
      # Microbiology:
      # Green: 100%, Yellow: >= 90% & < 100%, Red: < 90%
      #
      ReceiveResultPercent = cell_spec(
        ReceiveResultPercent, "html",
        color = ifelse(is.na(ReceiveResultPercent), "lightgray",
                       ifelse(
                         (ReceiveResultPercent >= 0.95 &
                            lab_division %in% c("Chemistry", "Hematology")) |
                           (ReceiveResultPercent == 1.00 &
                              lab_division %in% c("Microbiology RRL")),
                         "green",
                         ifelse(
                           (ReceiveResultPercent >= 0.8 &
                              lab_division %in% c("Chemistry", "Hematology")) |
                             (ReceiveResultPercent >= 0.9 &
                                lab_division %in% c("Microbiology RRL")),
                           "orange", "red")))),
      CollectResultPercent = cell_spec(
        CollectResultPercent, "html",
        color = ifelse(is.na(CollectResultPercent), "lightgray",
                       ifelse(
                         (CollectResultPercent >= 0.95 &
                            lab_division %in% c("Chemistry", "Hematology")) |
                           (CollectResultPercent == 1.00 &
                              lab_division %in% c("Microbiology RRL")),
                         "green",
                         ifelse(
                           (CollectResultPercent >= 0.8 &
                              lab_division %in% c("Chemistry", "Hematology")) |
                             (CollectResultPercent >= 0.9 &
                                lab_division %in% c("Microbiology RRL")),
                           "orange", "red")))),
      #
      # Create a new column with test and priority to be used in tables later
      TestAndPriority = paste(Test, "-", DashboardPriority, "Labs"),
      #
      # Remove concatenated columns used for matching
      Concate1 = NULL,
      Concate2 = NULL) %>%
    arrange(Test, Site, DashboardPriority, DashboardSetting)
  #
  # Melt summarized data into a long dataframe
  lab_dashboard_melt <- melt(lab_summary,
                             id.var = c("Test",
                                        "Site",
                                        "DashboardPriority",
                                        "TestAndPriority",
                                        "DashboardSetting",
                                        "ReceiveResultTarget",
                                        "CollectResultTarget"),
                             measure.vars = c("ReceiveResultPercent",
                                              "CollectResultPercent"))
  #
  # Case dataframe into wide format for use in tables later
  lab_dashboard_cast <- dcast(lab_dashboard_melt,
                              Test +
                                DashboardPriority +
                                TestAndPriority +
                                DashboardSetting +
                                ReceiveResultTarget +
                                CollectResultTarget ~
                                variable +
                                Site,
                              value.var = "value")
  #
  # Rearrange columns based on desired dashboard aesthetics
  lab_dashboard_cast <- lab_dashboard_cast %>%
  mutate(DashboardSetting2 = DashboardSetting) %>%
  select(Test, DashboardPriority, TestAndPriority,
         ReceiveResultTarget, DashboardSetting,
         ReceiveResultPercent_MSH, ReceiveResultPercent_MSQ,
         ReceiveResultPercent_MSBI, ReceiveResultPercent_MSB,
         ReceiveResultPercent_MSW, ReceiveResultPercent_MSM,
         CollectResultTarget, DashboardSetting2,
         CollectResultPercent_MSH, CollectResultPercent_MSQ,
         CollectResultPercent_MSBI, CollectResultPercent_MSB,
         CollectResultPercent_MSW, CollectResultPercent_MSM)
  #
  # Save outputs in a list
  lab_sub_output <- list(lab_div_df,
                         lab_summary,
                         lab_dashboard_melt,
                         lab_dashboard_cast)
  #
  lab_sub_output

}

# Custom function for creating kables for each CP lab division ----------------
kable_cp_tat <- function(x) {
  #
  # Select columns 3 and on
  data <- x[, c(3:ncol(x))]
  #
  # Format kable
  kable(data, format = "html", escape = FALSE, align = "c",
        col.names = c("Test & Priority",
                      "Target", "Setting",
                      "MSH", "MSQ", "MSBI", "MSB", "MSW", "MSM",
                      "Target", "Setting",
                      "MSH", "MSQ", "MSBI", "MSB", "MSW", "MSM")) %>%
    kable_styling(bootstrap_options = "hover", position = "center",
                  font_size = 11) %>%
    column_spec(column = c(1, 9, 17),
                border_right = "thin solid lightgray") %>%
    add_header_above(c(" " = 1,
                       "Receive to Result Within Target" =
                         (ncol(data) - 1) / 2,
                       "Collect to Result Within Target" =
                         (ncol(data) - 1) / 2),
                     background = c("white", "#00AEEF", "#221f72"),
                     color = "white", line = FALSE, font_size = 13) %>%
    column_spec(column = 2:9, background = "#E6F8FF", color = "black") %>%
    column_spec(column = 10:17, background = "#EBEBF9", color = "black") %>%
    #column_spec(column = 2:17, background = "inherit", color = "inherit") %>%
    column_spec(column = 1, width_min = "125px") %>%
    column_spec(column = c(3, 11), width_min = "100px") %>%
    row_spec(row = 0, font_size = 13) %>%
    collapse_rows(columns = c(1, 2, 10))
}

```

```{r Subset and format SCC and Sunquest data for each lab division weekday dashboard, warning = FALSE, message = FALSE, echo = FALSE}

# Chemistry
chem_sub_output <- summarize_cp_tat(x = cp_wday_summary,
                                   lab_division = "Chemistry")
chem_subset <- chem_sub_output[[1]]
chem_summary <- chem_sub_output[[2]]
chem_dashboard_melt <- chem_sub_output[[3]]
chem_dashboard_cast <- chem_sub_output[[4]]

# Hematology
hem_sub_output <- summarize_cp_tat(x = cp_wday_summary,
                                   lab_division = "Hematology")
hem_subset <- hem_sub_output[[1]]
hem_summary <- hem_sub_output[[2]]
hem_dashboard_melt <- hem_sub_output[[3]]
hem_dashboard_cast <- hem_sub_output[[4]]

# Microbiology RRL
micro_sub_output <- summarize_cp_tat(x = cp_wday_summary,
                                    lab_division = "Microbiology RRL")

micro_subset <- micro_sub_output[[1]]
micro_summary <- micro_sub_output[[2]]
micro_dashboard_melt <- micro_sub_output[[3]]
micro_dashboard_cast <- micro_sub_output[[4]]

# Microbiology RRL: Manually remove C. diff ambulatory TAT since only volume
# is monitored for this lab/setting combination
micro_dashboard_cast <- micro_dashboard_cast %>%
  filter(!(Test == "C. diff" & DashboardSetting == "Amb"))
row.names(micro_dashboard_cast) <- seq_len(nrow(micro_dashboard_cast))

```


```{r Custom functions for formatting Cytology dashboard tables, echo = FALSE, warning = FALSE, message = FALSE}

######Create a function for Table standardization for cyto and patho########
#To add all the missing rows and columns

#cyto table
table_merging_cyto <- function(cyto_table) {
  if (is.null(cyto_table)) {
    cyto_table_new <- NULL
    cyto_table_new2 <- NULL
  } else {
    #first step is merging the table template with the cyto table and this
    #will include all of the missing columns.

    cyto_table_new <- merge(x = table_temp_cyto, y = cyto_table, all.y = TRUE)
    #second step is merging the table with all of the columns with only the
    #first two columns of the template to include all the missing rows
    cyto_table_new2 <- merge(x = table_temp_cyto[c(1, 2)],
                             y = cyto_table_new, all.x = TRUE,
                             by = c("Spec_group", "Patient_setting"))

    rows_order_cyto <- factor(rownames(cyto_table_new2), levels = c(2, 1, 4, 3))

    cyto_table_new2 <-
      cyto_table_new2[
        order(rows_order_cyto),
        c("Spec_group",
          "Patient_setting",
          "no_cases_signed",
          "MSH.x", "MSQ.x", "BIMC.x", "PACC.x", "KH.x", "R.x", "SL.x", "NYEE.x",
          "MSH.y", "MSQ.y", "BIMC.y", "PACC.y", "KH.y", "R.y", "SL.y",
          "NYEE.y")]
  }

  return(cyto_table_new2)

}

table_merging_cyto_v2 <- function(cyto_table_v2) {
  if (is.null(cyto_table_v2)) {
    cyto_table_new_v2 <- NULL
    cyto_table_new2_v2 <- NULL
  } else {
    #first step is merging the table template with the cyto table and this
    #will include all of the missing columns.

    cyto_table_new_v2 <- merge(x = table_temp_cyto_v2, y = cyto_table_v2,
                               all.y = TRUE)

    #second step is merging the table with all of the columns with only the
    #first two columns of the template to include all the missing rows

    cyto_table_new2_v2 <- merge(x = table_temp_cyto_v2[c(1, 2)],
                                y = cyto_table_new_v2,
                                all.x = TRUE,
                                by = c("Spec_group", "Patient_setting"))

    rows_order_cyto_v2 <- factor(rownames(cyto_table_new2_v2),
                                 levels = c(2, 1, 4, 3))

    cyto_table_new2_v2 <-
      cyto_table_new2_v2[order(rows_order_cyto_v2),
                             c("Spec_group",
                               "Patient_setting",
                               "no_cases_signed",
                               "received_to_signed_out_within_target",
                               "MSH", "MSQ", "BIMC", "PACC", "KH", "R",
                               "SL", "NYEE")]
    }

  return(cyto_table_new2_v2)
}

#final cyto summarized table with an assumption that
#received to result is not centralized
cyto_table_weekday_new2 <- table_merging_cyto(cyto_table_weekday)

#final cyto summarized table with an assumption that
#received to result is centralized
cyto_table_weekday_new2_v2 <- table_merging_cyto_v2(cyto_table_weekday_v2)

#Pathology table
table_merging_patho <- function(sp_table) {
  if (is.null(sp_table)) {
    sp_table_new <- NULL
    sp_table_new2 <- NULL
  } else {
    #first step is merging the table template with the cyto table
    #and this will include all of the missing columns.

    sp_table_new <- merge(x = table_temp_patho, y = sp_table, all.y = TRUE)

    #second step is merging the table with all of the columns with
    #only the first two columns of the template to include all the missing rows
    sp_table_new2 <- merge(x = table_temp_patho[c(1, 2)], y = sp_table_new,
                           all.x = TRUE,
                           by = c("Spec_group", "Patient_setting"))

    rows_order_patho <- factor(rownames(sp_table_new2), levels = c(2, 1, 4, 3))

    sp_table_new2 <-
      sp_table_new2[
        order(rows_order_patho),
        c("Spec_group",
          "Patient_setting",
          "no_cases_signed",
          "MSH.x", "MSQ.x", "BIMC.x", "PACC.x", "KH.x", "R.x", "SL.x",
          "MSH.y", "MSQ.y", "BIMC.y", "PACC.y", "KH.y", "R.y", "SL.y")]

  }

  return(sp_table_new2)

}

#final surgical pathology summarized table with an assumption that
#received to result is not centralized
sp_table_weekday_new2 <- table_merging_patho(sp_table_weekday)

sp_vol_column_order <- c("Spec_group", "Patient_setting",
                         "MSH", "MSQ", "BIMC", "PACC", "KH", "R", "SL")

cyto_vol_column_order <- c("Spec_group", "Patient_setting",
                           "MSH", "MSQ", "BIMC", "PACC", "KH", "R", "SL",
                           "NYEE")

table_merging_volume <-
  function(table_temp_vol, vol_table, columns_order_v3) {
  if (is.null(vol_table)) {
    vol_table_new <- NULL
    vol_table_new2 <- NULL
    rows_order_vol <- NULL
  } else {
    vol_table_new <- merge(x = table_temp_vol, y = vol_table, all.y = TRUE)

    vol_table_new2 <- merge(x = table_temp_vol[c(1, 2)],
                            y = vol_table_new, all.x = TRUE,
                            by = c("Spec_group", "Patient_setting"))

    rows_order_vol <- factor(rownames(vol_table_new2), levels = c(2, 1, 4, 3))
    vol_table_new2 <- vol_table_new2[order(rows_order_vol), columns_order_v3]
    row.names(vol_table_new2) <- NULL
    vol_table_new2[is.na(vol_table_new2)] <- 0
  }
  return(vol_table_new2)
}


#final surgical pathology volume table per site per patient setting
sp_strat_vol_weekday_new2 <- table_merging_volume(
  table_temp_patho_vol,
  sp_strat_vol_weekday,
  sp_vol_column_order)

sp_strat_vol_weekday_new2$Spec_group[
  sp_strat_vol_weekday_new2$Spec_group == "GI"] <-
  "GI Biopsies"

sp_strat_vol_weekday_new2$Spec_group[
  sp_strat_vol_weekday_new2$Spec_group == "Breast"] <-
  "All Breast Specimens"

#final cyto volume table per site per patient setting
cyto_strat_vol_weekday_new2 <- table_merging_volume(
  table_temp_cyto_vol,
  cyto_strat_vol_weekday,
  cyto_vol_column_order)

#added this line to delete the cyto gyn from the table until we get correct data
#this line is not used anymore
cyto_strat_vol_weekday_new3 <-
  cyto_strat_vol_weekday_new2[-c(1, 2), ]

############Create a function for conditional formatting############
conditional_formatting_cyto <- function(table_new2) {
  if (is.null(table_new2)) {
    table_new3 <- NULL
    table_new4 <- NULL
    table_new5 <- NULL
  } else {

    table_new2[, 4:19] <- lapply(table_new2[, 4:19], as.numeric)

    table_new2[, 4:11] <- lapply(table_new2[, 4:11], formattable::percent)

    #steps for conditional formatting:

    table_new3 <-
      melt(
        table_new2,
        id = c("Spec_group",
               "Patient_setting",
               "no_cases_signed",
               "MSH.y", "MSQ.y", "BIMC.y", "PACC.y", "KH.y",
               "R.y", "SL.y", "NYEE.y"))

    table_new3 <- table_new3 %>%
      mutate(value = ifelse(is.na(value),
                            cell_spec(value, "html",
                                      color = "lightgray"),
                            ifelse(value > 0.9,
                                   cell_spec(value, "html",
                                             color = "green"),
                                   ifelse(value < 0.8,
                                          cell_spec(value, "html",
                                                    color = "red"),
                                          cell_spec(value, "html",
                                                    color = "orange")))))

    table_new3 <-
      dcast(table_new3,
            Spec_group +
              Patient_setting +
              no_cases_signed +
              BIMC.y + MSH.y + MSQ.y + NYEE.y + PACC.y + R.y + SL.y +
              KH.y ~ variable)

    table_new4 <-
      melt(
        table_new3,
        id = c("Spec_group",
               "Patient_setting",
               "no_cases_signed",
               "MSH.x", "MSQ.x", "BIMC.x", "PACC.x", "KH.x", "R.x", "SL.x",
               "NYEE.x"))

    table_new4 <-
      table_new4 %>%
      mutate(value = ifelse(is.na(value),
                            cell_spec(value, "html", color = "lightgray"),
                            cell_spec(value, "html", color = "black")))

    table_new4 <-
      dcast(table_new4,
            Spec_group +
              Patient_setting +
              no_cases_signed +
              BIMC.x + MSH.x + MSQ.x + NYEE.x + PACC.x + R.x + SL.x +
              KH.x ~ variable)

    table_new5 <- merge(x = table_new4, y = tat_targets_ap[1:3],
                        by.x = c("Spec_group", "Patient_setting"),
                        by.y = c("spec_group", "Patient.Setting"))

    rows_order <- factor(rownames(table_new5), levels = c(2, 1, 4, 3))

    table_new5 <-
      table_new5[
        order(rows_order),
        c("Spec_group",
          "Received.to.signed.out.target..Days.",
          "Patient_setting",
          "no_cases_signed",
          "MSH.x", "MSQ.x", "BIMC.x", "PACC.x", "KH.x", "R.x", "SL.x", "NYEE.x",
          "MSH.y", "MSQ.y", "BIMC.y", "PACC.y", "KH.y", "R.y", "SL.y",
          "NYEE.y")]


    table_new5 <-
      table_new5 %>%
      mutate(Received.to.signed.out.target..Days. =
      paste("<= ", Received.to.signed.out.target..Days., "days"))

    row.names(table_new5) <- NULL

    table_new5 <- table_new5 %>%
      mutate(no_cases_signed = coalesce(no_cases_signed, 0))

  }
  return(table_new5)
}

#final cyto summarized table with conditional formatting and receive to result
#targets with an assumption that received to result is not centralized

cyto_table_weekday_new3 <- conditional_formatting_cyto(cyto_table_weekday_new2)

#added this line to delete the cyto gyn from the table until we get correct data
#this line is not used anymore
cyto_table_weekday_new4 <- cyto_table_weekday_new3[-c(1, 2), ]

conditional_formatting_cyto2 <- function(table_new2_v2) {
  if (is.null(table_new2_v2)) {
    table_new3_v2 <- NULL
    table_new4_v2 <- NULL
  } else {

    table_new2_v2[4] <- lapply(table_new2_v2[4], as.numeric)
    table_new2_v2[4] <- lapply(table_new2_v2[4], formattable::percent, d = 0)

    #steps for conditional formatting:

    table_new3_v2 <-
      table_new2_v2 %>%
      mutate(
        received_to_signed_out_within_target =
          ifelse(
            is.na(received_to_signed_out_within_target),
            cell_spec(received_to_signed_out_within_target, "html",
                      color = "lightgray"),
            ifelse(
              received_to_signed_out_within_target > 0.9,
              cell_spec(received_to_signed_out_within_target, "html",
                        color  = "green"),
              ifelse(
                received_to_signed_out_within_target < 0.8,
                cell_spec(received_to_signed_out_within_target, "html",
                          color = "red"),
                cell_spec(received_to_signed_out_within_target, "html",
                          color = "orange")))))

    table_new4_v2 <-
      melt(table_new3_v2,
           id = c("Spec_group",
                  "Patient_setting",
                  "no_cases_signed",
                  "received_to_signed_out_within_target"))


    table_new4_v2 <-
      table_new4_v2 %>%
      mutate(value = ifelse(is.na(value),
                            cell_spec(value, "html", color = "lightgray"),
                            cell_spec(value, "html", color = "black")))

    table_new4_v2 <-
      dcast(table_new4_v2,
            Spec_group +
              Patient_setting +
              no_cases_signed +
              received_to_signed_out_within_target ~ variable)

    table_new4_v2 <- merge(x = table_new4_v2, y = tat_targets_ap[1:3],
                           by.x = c("Spec_group", "Patient_setting"),
                           by.y = c("spec_group", "Patient.Setting"))

    rows_order_v2 <- factor(rownames(table_new4_v2), levels = c(2, 1, 4, 3))

    table_new4_v2 <-
      table_new4_v2[order(rows_order_v2),
                    c("Spec_group",
                      "Received.to.signed.out.target..Days.",
                      "Patient_setting", "no_cases_signed",
                      "received_to_signed_out_within_target",
                      "MSH", "MSQ", "BIMC", "PACC", "KH", "R", "SL", "NYEE")]

    table_new4_v2 <- table_new4_v2 %>%
      mutate(Received.to.signed.out.target..Days. =
      paste("<= ", Received.to.signed.out.target..Days., "days"))

    row.names(table_new4_v2) <- NULL

    table_new4_v2 <- table_new4_v2 %>%
      mutate(no_cases_signed = coalesce(no_cases_signed, 0))
  }
  return(table_new4_v2)
}

#final cyto summarized table with conditional formatting and receive to
#result targets with an assumption that received to result is centralized

cyto_table_weekday_new3_v2 <-
  conditional_formatting_cyto2(cyto_table_weekday_new2_v2)

#added this line to delete the cyto gyn from the table until we get correct data
#this line is not in use anymore
cyto_table_weekday_new3_v3 <- cyto_table_weekday_new3_v2[-c(1, 2), ]

conditional_formatting_patho <- function(table_new2) {
  if (is.null(table_new2)) {
    table_new3 <- NULL
    table_new4 <- NULL
    table_new5 <- NULL
  } else {

    table_new2[, 4:17] <- lapply(table_new2[, 4:17], as.numeric)
    table_new2[, 4:10] <- lapply(table_new2[, 4:10], formattable::percent,
                                 d = 0)

    #steps for conditional formatting:

    table_new3 <-
      melt(table_new2,
           id = c("Spec_group",
                  "Patient_setting",
                  "no_cases_signed",
                  "MSH.y", "MSQ.y", "BIMC.y", "PACC.y", "KH.y", "R.y", "SL.y"))


    table_new3 <-
      table_new3 %>%
      mutate(value = ifelse(is.na(value),
                            cell_spec(value, "html",
                                      color = "lightgray"),
                            ifelse(value > 0.9,
                                   cell_spec(value, "html",
                                             color  = "green"),
                                   ifelse(value < 0.8,
                                          cell_spec(value, "html",
                                                    color = "red"),
                                          cell_spec(value, "html",
                                                    color = "orange")))))


    table_new3 <-
      dcast(table_new3,
            Spec_group +
              Patient_setting +
              no_cases_signed +
              BIMC.y + MSH.y + MSQ.y + PACC.y + R.y + SL.y + KH.y ~ variable)

    table_new4 <-
      melt(table_new3,
           id = c("Spec_group",
                  "Patient_setting",
                  "no_cases_signed",
                  "MSH.x", "MSQ.x", "BIMC.x", "PACC.x", "KH.x", "R.x", "SL.x"))


    table_new4 <-
      table_new4 %>%
      mutate(value =
               ifelse(is.na(value),
                      cell_spec(value, "html", color = "lightgray"),
                      cell_spec(value, "html", color = "black")))

    table_new4 <-
      dcast(table_new4,
            Spec_group +
              Patient_setting +
              no_cases_signed +
              BIMC.x + MSH.x + MSQ.x + PACC.x + R.x + SL.x + KH.x ~ variable)

    table_new5 <- merge(x = table_new4, y = tat_targets_ap[1:3],
                        by.x = c("Spec_group", "Patient_setting"),
                        by.y = c("spec_group", "Patient.Setting"))

    rows_order <- factor(rownames(table_new5), levels = c(2, 1, 4, 3))

    table_new5 <-
      table_new5[order(rows_order),
                 c("Spec_group",
                   "Received.to.signed.out.target..Days.",
                   "Patient_setting",
                   "no_cases_signed",
                   "MSH.x", "MSQ.x", "BIMC.x", "PACC.x", "KH.x", "R.x", "SL.x",
                   "MSH.y", "MSQ.y", "BIMC.y", "PACC.y", "KH.y", "R.y", "SL.y")]

    table_new5 <- table_new5 %>% mutate(Received.to.signed.out.target..Days. =
      paste("<= ", Received.to.signed.out.target..Days., "days"))

    row.names(table_new5) <- NULL

    table_new5 <- table_new5 %>%
      mutate(no_cases_signed = coalesce(no_cases_signed, 0))
  }
  return(table_new5)
}

#final surgical pathology summarized table with conditional formatting and
#receive to result targets with an assumption that received to result
#is centralized
sp_table_weekday_new3 <- conditional_formatting_patho(sp_table_weekday_new2)


sp_table_weekday_new3$Spec_group[sp_table_weekday_new3$Spec_group == "GI"] <-
  "GI Biopsies"

sp_table_weekday_new3$Spec_group[
  sp_table_weekday_new3$Spec_group == "Breast"] <-
  "All Breast Specimens"


```

```{r Custom function for Anatomic Pathology kable formatting, echo=FALSE, warning = FALSE, message = FALSE}
sp_standardized_column_names <-
  c("Case Type", "Target", "Setting", "No. Cases Signed Out",
    "MSH", "MSQ", "MSBI", "PACC", "MSB", "MSW", "MSSL",
    "MSH", "MSQ", "MSBI", "PACC", "MSB", "MSW", "MSSL")


table_formatting <- function(table_new3, column_names) {
  if (is.null(table_new3)) {
    table_new3 <- NULL
  } else {
    table_new3 %>%
    select(everything()) %>%
    kable(escape = F, align = "c", col.names = column_names) %>%
    kable_styling(bootstrap_options = "hover", full_width = FALSE,
                  position = "center", row_label_position = "c",
                  font_size = 11) %>%
    add_header_above(c(" " = 1,
                       "Receive to Result within Target (Business Days)" = 10,
                       "Average Collection to Result TAT (Calendar Days)" = 7),
                     background = c("white", "#00B9F2", "#221F72"),
                     color = "white", font_size = 13) %>%
    column_spec(2:11, background = "#E6F8FF", color = "black") %>%
    column_spec(12:18, background = "#EBEBF9", color = "black") %>%
    row_spec(row = 0, font_size = 13) %>%
    collapse_rows(columns = c(1, 2))
  }
}


table_formatting2 <- function(table_new3_v2) {
  if (is.null(table_new3_v2)) {
    table_new3_v2 <- NULL
  } else {
    table_new3_v2 %>%
    select(everything()) %>%
    kable(escape = F, align = "c",
          col.names = c("Case Type", "Target", "Setting",
                        "No. Cases Signed Out", "Centralized Lab",
                        "MSH", "MSQ", "MSBI", "PACC", "MSB", "MSW", "MSSL",
                        "NYEE")) %>%
    kable_styling(bootstrap_options = "hover", full_width = FALSE,
                  position = "center", row_label_position = "c",
                  font_size = 11) %>%
    add_header_above(c(" " = 1,
                       "Receive to Result within Target (Business Days)" = 4,
                       "Average Collection to Result TAT (Calendar Days)" = 8),
                     background = c("white", "#00B9F2", "#221F72"),
                     color = "white", font_size = 13) %>%
    column_spec(2:5, background = "#E6F8FF", color = "black") %>%
    column_spec(6:13, background = "#EBEBF9", color = "black") %>%
    row_spec(row = 0, font_size = 13) %>%
    collapse_rows(columns = c(1, 2))
  }
}

sp_vol_column_names <- c("Case Type", "Setting",
                          "MSH", "MSQ", "MSBI", "PACC", "MSB", "MSW", "MSSL")

cyto_vol_column_names <- c("Case Type", "Setting",
                            "MSH", "MSQ", "MSBI", "PACC", "MSB", "MSW", "MSSL",
                            "NYEE")

#Volume table formatting
table_formatting_volume <- function(vol_table, column_names) {
  if (is.null(vol_table)) {
    vol_table <- NULL
  } else {
    vol_table %>%
    select(everything()) %>%
    kable(escape = F, align = "c", col.names = column_names) %>%
    kable_styling(bootstrap_options = "hover", full_width = FALSE,
                  position = "center", row_label_position = "c",
                  font_size = 11) %>%
      add_header_above(c(" " = 2,
                         "Resulted Lab Volume" = length(column_names) - 2),
                       background = c("white", "#00B9F2"), color = "white",
                       font_size = 13) %>%
      column_spec(3:length(column_names), background = "#E6F8FF",
                  color = "black") %>%
    row_spec(row = 0, font_size = 13) %>%
    collapse_rows(columns = 1)

  }
}

```

<br />

## **Weekday Efficiency Indicators** {.tabset}
### Chemistry       
#### *Chemistry KPI (Labs Resulted on `r wday_result_date`)*
<h5>Status Definitions: <span style = "color:red">Red:</span> <80%, 
<span style = "color:orange">Yellow:</span> >=80% & <95%,
<span style = "color:green">Green:</span> >=95%</h5>
```{r Chemistry dashboard table, warning = FALSE, message = FALSE, echo = FALSE}
kable_cp_tat(x = chem_dashboard_cast)
```
<h6>*TAT Analysis excludes add on orders, labs with missing timestamps, labs with negative TAT, and labs not from above settings.*</h6>


### Hematology
#### *Hematology KPI (Labs Resulted on `r wday_result_date`)*
<h5>Status Definitions: <span style = "color:red">Red:</span> <80%, 
<span style = "color:orange">Yellow:</span> >=80% & <95%,
<span style = "color:green">Green:</span> >=95%</h5>
```{r Hematology dashboard table, warning = FALSE, message = FALSE, echo = FALSE}
kable_cp_tat(x = hem_dashboard_cast)
```
<h6>*TAT Analysis excludes add on orders, labs with missing timestamps, labs with negative TAT, and labs not from above settings.*</h6>

```{r Microbiology RRL volume and TAT table creation, warning = FALSE, message = FALSE, echo = FALSE}
#
# Create volume table for Microbiology RRL that mimics TAT table layout
micro_volume_melt <- melt(micro_summary,
                               id.var = c("Test",
                                          "Site",
                                          "DashboardPriority",
                                          "TestAndPriority",
                                          "DashboardSetting",
                                          "ReceiveResultTarget",
                                          "CollectResultTarget"),
                               measure.vars = "ResultedVolume")

# Ensure all Microbiology RRL test, site, and priority combinations are included
micro_vol_templ <- tat_dashboard_templ %>%
  filter(Division == "Microbiology RRL") %>%
  mutate(Incl = NULL,
         Division = NULL)

micro_volume_melt <- left_join(micro_vol_templ,
                               micro_volume_melt,
                               by = c("Test" = "Test",
                                      "Site" = "Site",
                                      "DashboardPriority" = "DashboardPriority",
                                      "DashboardSetting" = "DashboardSetting"))

# Replace NA with 0 and format site, tests, priority, and settings as factors
micro_volume_melt <- micro_volume_melt %>%
  mutate(
    #
    # Replace NA with 0
    value = ifelse(is.na(value), 0, value),
    #
    # Set test, site, priority, and setting as factors
    Test = droplevels(factor(Test, levels = test_names, ordered = TRUE)),
    Site = droplevels(factor(Site, levels = city_sites, ordered = TRUE)),
    DashboardPriority = droplevels(factor(DashboardPriority,
                                          levels = dashboard_priority_order,
                                          ordered = TRUE)),
    DashboardSetting = droplevels(factor(DashboardSetting,
                                         levels = dashboard_pt_setting,
                                         ordered = TRUE)))

micro_volume_cast <- dcast(micro_volume_melt,
                           Test + DashboardPriority + TestAndPriority +
                             DashboardSetting + ReceiveResultTarget +
                             CollectResultTarget ~
                             variable + Site,
                           value.var = "value")

original_length <- ncol(micro_volume_cast)

micro_volume_cast <- micro_volume_cast %>%
  mutate(
    #
    # Replace TAT targets with "Resulted Volume"
    ReceiveResultTarget = "Resulted Volume",
    CollectResultTarget = "Resulted Volume",
    #
    # Duplicate dashboard setting column
    DashboardSetting2 = DashboardSetting,
    #
    # Duplicate resulted volume columns
    ResultedVolume_MSH2 = ResultedVolume_MSH,
    ResultedVolume_MSQ2 = ResultedVolume_MSQ,
    ResultedVolume_MSBI2 = ResultedVolume_MSBI,
    ResultedVolume_MSB2 = ResultedVolume_MSB,
    ResultedVolume_MSW2 = ResultedVolume_MSW,
    ResultedVolume_MSM2 = ResultedVolume_MSM) %>%
  select(Test,
         DashboardPriority,
         TestAndPriority,
         ReceiveResultTarget,
         DashboardSetting,
         ResultedVolume_MSH,
         ResultedVolume_MSQ,
         ResultedVolume_MSBI,
         ResultedVolume_MSB,
         ResultedVolume_MSW,
         ResultedVolume_MSM,
         CollectResultTarget,
         DashboardSetting2,
         ResultedVolume_MSH2,
         ResultedVolume_MSQ2,
         ResultedVolume_MSBI2,
         ResultedVolume_MSB2,
         ResultedVolume_MSW2,
         ResultedVolume_MSM2)

# Rename columns to match TAT table for binding
colnames(micro_volume_cast) <- colnames(micro_dashboard_cast)

micro_volume_cast[, c(original_length:ncol(micro_volume_cast))] <- ""

micro_tat_vol_cast <- rbind(micro_dashboard_cast, micro_volume_cast)

micro_tat_vol_cast <- micro_tat_vol_cast %>%
  arrange(Test, ReceiveResultTarget)

```

### Microbiology RRL
#### *Microbiology RRL KPI (Labs Resulted on `r wday_result_date`)*
<h5>Status Definitions: <span style = "color:red">Red:</span> <90%, 
<span style = "color:orange">Yellow:</span> >=90% & <100%,
<span style = "color:green">Green:</span> =100%</h5>
```{r Create Micro RRL TAT and Volume Table, warning = FALSE, message = FALSE, echo = FALSE}
kable_cp_tat(x = micro_tat_vol_cast)
```
<h6>*TAT Analysis excludes add on orders, labs with missing timestamps, labs with negative TAT, and labs not from above settings.*</h6>

### Missing Collections & Add Ons
#### *Missing Collection Times and Add On Order Volume (Labs Resulted on `r wday_result_date`)*
<h5>Status Definitions: <span style = "color:red">Red:</span> >15%, 
<span style = "color:orange">Yellow:</span> <=15% & >5%,
<span style = "color:green">Green:</span> <=5%</h5>
```{r Missing Collection Times Tables, warning = FALSE, message = FALSE, echo = FALSE}
# Labs with missing collection times -----------------------
# Determine percentage of labs with missing collection times
missing_collect <- cp_wday_summary %>%
  filter(Site %in% city_sites) %>%
  group_by(Site) %>%
  summarize(ResultedVolume = sum(TotalResultedTAT),
            MissingCollection = sum(TotalMissingCollections, na.rm = TRUE),
            Percent = percent(MissingCollection / ResultedVolume,
                              digits = 0)) %>%
  mutate(
    # Apply conditional formatting based on percentage of labs with missing
    # collections
    Percent = cell_spec(
      Percent, "html",
      color = ifelse(is.na(Percent), "grey",
                     ifelse(Percent <= 0.05, "green",
                            ifelse(Percent <= 0.15, "orange", "red")))),
    # Format site as factors
    Site = factor(Site, levels = city_sites, ordered = TRUE))
#
# Cast missing collections into table format
missing_collect_table <- dcast(missing_collect,
                               "Percentage of Specimens" ~ Site,
                               value.var = "Percent")
#
# Create a kable of missing collection percentages
missing_collect_table %>%
  kable(format = "html", escape = FALSE, align = "c",
        col.names = c("Site", "MSH", "MSQ", "MSBI", "MSB", "MSW", "MSM")) %>%
  kable_styling(
    bootstrap = "hover",
    position = "float_left",
    font_size = 11,
    full_width = FALSE) %>%
  add_header_above(
    c(" " = 1,
      "Percentage of Labs Missing Collect Times" =
        ncol(missing_collect_table) - 1),
    background = c("white", "#00AEEF"),
    color = "white",
    line = FALSE,
    font_size = 13) %>%
  column_spec(column = c(1, ncol(missing_collect_table)),
              border_right = "thin solid lightgray") %>%
  column_spec(column = c(2:ncol(missing_collect_table)),
              background = "#E6F8FF",
              color = "black") %>%
 # column_spec(column = c(2:ncol(missing_collect_table)),
 #             background = "inherit",
 #             color = "inherit",
 #             width_max = 0.15) %>%
  row_spec(row = 0, font_size = 13)

# Add On Order Volume ---------------------------------
# Determine add on order volume
add_on_volume <- cp_wday_summary %>%
  filter(Site %in% city_sites) %>%
  group_by(Test, Site) %>%
  summarize(AddOnVolume = sum(TotalAddOnOrder, na.rm = TRUE))

add_on_volume <- left_join(test_site_comb, add_on_volume,
                            by = c("Site" = "Site",
                                  "Test" = "Test"))

add_on_volume <- add_on_volume %>%
  mutate(
    # Set test and site as factors
    Test = droplevels(factor(Test, levels = test_names, ordered = TRUE)),
    Site = factor(Site, levels = city_sites, ordered = TRUE),
    AddOnVolume = ifelse(is.na(AddOnVolume), 0, AddOnVolume))

add_on_table <- dcast(add_on_volume, Test ~ Site, value.var = "AddOnVolume")

add_on_table %>%
  kable(format = "html", escape = FALSE, align = "c",
        col.names = c("Test", "MSH", "MSQ", "MSBI", "MSB", "MSW", "MSM"),
        color = "gray") %>%
  kable_styling(
    bootstrap = "hover",
    position = "right",
    font_size = 11,
    full_width = FALSE) %>%
  add_header_above(
    c(" " = 1,
      "Volume of Add On Labs" = ncol(missing_collect_table) - 1),
    background = c("white", "#00AEEF"),
    color = "white",
    line = FALSE,
    font_size = 13) %>%
  column_spec(
    column = c(1, ncol(missing_collect_table)),
    border_right = "thin solid lightgray") %>%
  column_spec(
    column = c(2:ncol(missing_collect_table)),
    background = "#E6F8FF", color = "black") %>%
  # column_spec(column = c(2:ncol(missing_collect_table)),
  #             background = "inherit",
  #             color = "inherit") %>%
  row_spec(row = 0, font_size = 13)

```
<h6>*Missing collection time analysis includes analytes represented in Chemistry, Hematology, and Microbiology RRL dashboard TAT analysis from ED, ICU, IP Non-ICU, and ambulatory settings.*</h6>

### Surgical Pathology
#### *Surgical Pathology KPI (Specimens Resulted on `r wday_result_date`)*
<h5>Status Definitions: <span style = "color:red">Red:</span> <80%, 
<span style = "color:orange">Yellow:</span> >=80% & <90%,
<span style = "color:green">Green:</span> >=90%</h5>
```{r Surgical Pathology Efficiency Indicator Weekday, echo=FALSE, warning=FALSE, message=FALSE}

table_formatting(sp_table_weekday_new3, sp_standardized_column_names)
```
<h6>*TAT analysis includes all breast specimens and GI biopsies and excludes those with missing timestamps, negative TAT, and not from above settings.*</h6>


### Cytology

#### *Cytology KPI (Specimens Resulted on `r wday_result_date`)*
<h5>Status Definitions: <span style = "color:red">Red:</span> <80%, 
<span style = "color:orange">Yellow:</span> >=80% & <90%,
<span style = "color:green">Green:</span> >=90%</h5>
```{r Cytology Efficiency Indicators Weekday, echo=FALSE, warning=FALSE, message=FALSE}
table_formatting2(cyto_table_weekday_new3_v2)
```

<h6>*TAT analysis includes excludes specimens with missing timestamps, negative TAT, and not from above settings.*</h6>


```{r Lab KPI Form for Qualitative Indicators, echo=FALSE, message=FALSE, warning=FALSE, eval = TRUE}
#read the excel sheet that is generated from office form responses
kpi_form <- data.frame(read_excel(
  choose.files(default = paste0(user_directory, "/Lab KPI Form/*.*"),
               caption = "Select the KPI form generated today"), 1),
  stringsAsFactors = FALSE)


#Determine the dates within the KPI excel sheet and report only the latest date
kpi_form <- kpi_form %>%
  mutate(Completion_Date = as.Date(as.POSIXct(Completion.time, tz = "",
                                              format = "%m/%d/%y %I:%M %p")))

kpi_form <- kpi_form %>%
  mutate(Completion_Hour = format(Completion.time, format = "%H:%M:%S"))


kpi_form_today  <-
  kpi_form[which(kpi_form$Completion_Date == as.Date(today) |
                   (kpi_form$Completion_Date == as.Date(yesterday) &
                      kpi_form$Completion_Hour >= "17:00:00")), ]

#Rename the columns of the kpi form data
colnames(kpi_form_today) <- c("ID", "Start_time", "Completion_time", "Email",
                              "Name", "Facility", "LabCorp", "Vendor_Services",
                              "Environment", "Equipment", "IT",
                              "Service_Changes", "Volume", "Staffing",
                              "Comments", "NEVER_EVENTS",
                              "NEVER_EVENTS_COMMENTS", "Good_Catch",
                              "LIS_Staffing",
                              "LIS_Unplanned_Service",
                              "LIS_Preplanned_Downtime",
                              "Completion_Date", "Completion_Hour")

#keep only unique rows with the latest timestamp
#order data by facility and time by descending order
kpi_form_today <- kpi_form_today[with(kpi_form_today, order(Facility, -ID)), ]
#add a column to include the dupliacted values
kpi_form_today$duplicated_id <- duplicated(kpi_form_today$Facility)
#only keep the unique ids
kpi_form_today <-
  kpi_form_today[which(kpi_form_today$duplicated_id == "FALSE"), ]

#do not run now until test it - waiting for Daya to send the data for today's
#read historical repo
historical_repo_form <- read_excel(
  paste0(user_directory, "/Lab KPI Form/Lab KPI Hsitorical Repo/",
         "Lab_KPI_Form_Repo", "_", yesterday, ".xlsx"))


#2. combine the current summary with the historical repo and write them
#into a xlsx file
historical_repo_form2 <- rbind(historical_repo_form, kpi_form_today)

#3. to ensure that the selected rows are the unique ones only without
#any dupilacation

historical_repo_form2 <- unique(historical_repo_form2)

xlsx_form <- paste0(user_directory, "/Lab KPI Form/Lab KPI Hsitorical Repo/",
                    "Lab_KPI_Form_Repo", "_", today, ".xlsx")

write_xlsx(historical_repo_form2, xlsx_form)

#split the data into 3 datasets

# the first dataset representes the following: CP/AP/CPA/4LABS
clinical_labs_ops_ind <-
  kpi_form_today[
    which(kpi_form_today$Facility !=
            "Laboratory Information System (LIS)"), c(6:15)]

# the second dataset represents the LIS indicators
lis_ops_ind <-
  kpi_form_today[
    which(kpi_form_today$Facility ==
            "Laboratory Information System (LIS)"), c(6, 19:21)]

# the third and last dataset is the never events and good catches dataset
never_events <-
  kpi_form_today[
    which(kpi_form_today$Facility !=
            "Laboratory Information System (LIS)"), c(6, 16:18)]

####### Start creating and formatting the tables

#first melt the tables to get the values needed in one column:

#1. Clinical labs table
clinical_labs_melt <-
  melt(clinical_labs_ops_ind,
       id = c("Facility", "Comments"))

#2. LIS table
lis_melt <- melt(lis_ops_ind,
                 id = c("Facility",
                        "LIS_Unplanned_Service",
                        "LIS_Preplanned_Downtime"))

##### create a function to rename the status of the measures to a standard one
#( Safe, Under Stress, and Not Safe)

renaming <- function(melted_dataset) {
  if (is.null(melted_dataset) || nrow(melted_dataset) == 0) {
    melted_dataset <- NULL
  } else {

  melted_dataset[melted_dataset == "Green (No issues)"] <- "Safe"

  melted_dataset[
    melted_dataset == "Yellow (Safe/Under Stress)" |
      melted_dataset == "Yellow (Delays)" |
      melted_dataset == "Yellow (Delays in pickup/delivery)" |
      melted_dataset == "Yellow (Shortage with no/minimal significant impact)" |
      melted_dataset ==
      "Yellow (Minor issues/Coordinating with Reference Labs)"] <-
    "Under Stress"

  melted_dataset[
    melted_dataset == "Yellow (Safe/Under Stress)" |
      melted_dataset == "Yellow (Delays)" |
      melted_dataset == "Yellow (Delays in pickup/delivery)" |
      melted_dataset == "Yellow (Shortage with no/minimal significant impact)" |
      melted_dataset ==
      "Yellow (Minor issues/Coordinating with Reference Labs)"] <-
    "Under Stress"

  melted_dataset[
    melted_dataset == "Red (Severe shortage of consumables)" |
      melted_dataset == "Red (Missed pickups)" |
      melted_dataset == "Red (Not Safe/Risk)" |
      melted_dataset == "Red (Severe shortage that halts activity)" |
      melted_dataset == "Red (Major issues/Requires Immediate Attention)"] <-
    "Not Safe"
  }

return(melted_dataset)

}

clinical_labs_melt_new <- renaming(clinical_labs_melt)
lis_melt_new <- renaming(lis_melt)


### create a function to format the data table into the correct colors
conditional_format_form <- function(melted_data_new) {
  if (is.null(melted_data_new) || nrow(melted_data_new) == 0) {
    melted_data_new <- NULL
  } else {
  melted_data_new <-
    melted_data_new %>%
      mutate(
        value =
          ifelse(is.na(value),
                 cell_spec(value, "html", color = "lightgray"),
                 ifelse((value == "Safe" | value == "None"),
                        cell_spec(value, "html", color  = "green"),
                        ifelse((value == "Not Safe" | value == "Present"),
                               cell_spec(value, "html", color = "red"),
                               cell_spec(value, "html", color = "orange")))))

return(melted_data_new)

  }

}

formatted_clinical_labs <-
  conditional_format_form(clinical_labs_melt_new)

formatted_lis_new <- conditional_format_form(lis_melt_new)

###### ------------- Now decast the melted clinical table ------------- ######
formatted_clinical_labs1 <-
  dcast(formatted_clinical_labs,
        Facility + Comments ~ variable)

#Change the order of the columns in the table
columns_order_form_clinical <-
  c("Facility", "LabCorp", "Vendor_Services", "Environment", "Equipment", "IT",
    "Service_Changes", "Volume", "Staffing", "Comments")

formatted_clinical_labs1 <-
  formatted_clinical_labs1[, columns_order_form_clinical]

needed_rows <- data.frame(matrix(ncol = 1, nrow = 11))

colnames(needed_rows) <- c("Facility")

needed_rows[1] <-
  c("MSH (Clinical Pathology, Blood Bank, Anatomic Pathology Front End, etc.)",
    "MSQ (Clinical Pathology, Blood Bank, Anatomic Pathology Front End, etc.)",
    "MSBI (Clinical Pathology, Blood Bank, Anatomic Pathology Front End, etc.)",
    "MSB (Clinical Pathology, Blood Bank, Anatomic Pathology Front End, etc.)",
    "MSW (Clinical Pathology, Blood Bank, Anatomic Pathology Front End, etc.)",
    "MSSL (Clinical Pathology, Blood Bank, Anatomic Pathology Front End, etc.)",
    "NYEE (Clinical Pathology, Blood Bank, Anatomic Pathology Front End, etc.)",
    "MSSN (Clinical Pathology, Blood Bank, Anatomic Pathology Front End, etc.)",
    "MSH - Anatomic Pathology (Centralized)",
    "MSH - Central Processing & Accessioning",
    "4LABS - Client Services")

#i need all the columns from x and all the rows from x and y
trial <- right_join(formatted_clinical_labs1, needed_rows)
#
rownames(trial) <- trial$Facility

#Change the order of the rows in the table

formatted_clinical_labs2 <-
  trial[c(
    "MSH (Clinical Pathology, Blood Bank, Anatomic Pathology Front End, etc.)",
    "MSQ (Clinical Pathology, Blood Bank, Anatomic Pathology Front End, etc.)",
    "MSBI (Clinical Pathology, Blood Bank, Anatomic Pathology Front End, etc.)",
    "MSB (Clinical Pathology, Blood Bank, Anatomic Pathology Front End, etc.)",
    "MSW (Clinical Pathology, Blood Bank, Anatomic Pathology Front End, etc.)",
    "MSSL (Clinical Pathology, Blood Bank, Anatomic Pathology Front End, etc.)",
    "NYEE (Clinical Pathology, Blood Bank, Anatomic Pathology Front End, etc.)",
    "MSSN (Clinical Pathology, Blood Bank, Anatomic Pathology Front End, etc.)",
    "MSH - Anatomic Pathology (Centralized)",
    "MSH - Central Processing & Accessioning",
    "4LABS - Client Services"), ]

rownames(formatted_clinical_labs2) <- NULL

#Change the names in the Facility columns to be standardized

rownames(formatted_clinical_labs2) <-
  c("MSH", "MSQ", "MSBI", "MSB", "MSW", "MSSL", "NYEE", "MSSN",
    "Anatomic Pathology (Centralized)",
    "Central Processiong & Accessioning (CPA)",
    "Client Services - 4LABS")

formatted_clinical_labs2 <- formatted_clinical_labs2 %>%
  mutate(Facility = rownames(formatted_clinical_labs2))

rownames(formatted_clinical_labs2) <- NULL

formatted_clinical_labs3 <- formatted_clinical_labs2[, c(1:9)]

comments_clinical_labs <- formatted_clinical_labs2[, c(1, 10)]
comments_clinical_labs[is.na(comments_clinical_labs)] <-
  "No Issues Reported (Safe)"

comments_clinical_labs[comments_clinical_labs == "None" |
                         comments_clinical_labs == "NONE" |
                         comments_clinical_labs == "none" |
                         comments_clinical_labs == "N/A" |
                         comments_clinical_labs == "n/a" |
                         comments_clinical_labs == "na" |
                         comments_clinical_labs == "NA"] <-
  "No Issues Reported (Safe)"

###### --------------- now decast the LIS  table --------------- ######
if (is.null(formatted_lis_new) || nrow(formatted_lis_new) == 0) {
    formatted_lis_new2 <- NULL
} else{
  formatted_lis_new2 <-
    dcast(formatted_lis_new,
          Facility +
            LIS_Unplanned_Service +
            LIS_Preplanned_Downtime ~ variable)

  columns_order_form_lis <-
    c("Fcaility",
      "LIS_Staffing",
      "LIS_Unplanned_Service",
      "LIS_Preplanned_Downtime")

  formatted_lis_new2 <- formatted_lis_new2[, columns_order_form_lis]
  rownames(formatted_lis_new2) <- NULL
  formatted_lis_new2[is.na(formatted_lis_new2)] <- "None"
}
###### --------------- Formatting Never Events Table --------------- ######

# added 4 extra columns each one for different never event
never_events["Specimen(s) Lost"] <- NA
never_events["QNS - specimen that cannot be recollected"] <- NA
never_events["Treatment based on mislabeled/misidentified specimen"] <- NA
never_events["Treatment based on false positive/false negative results"] <- NA

#because we have multiple never events in one cell i created a
#list with these by:
split_text <- sapply(never_events$NEVER_EVENTS, strsplit, "[;]")

#created a nested for loop with nested if to determine which of these
#never events are listed
for (i in 1:nrow(never_events)) {
  for (j in 1:length(split_text[[i]])) {
    if (split_text[[i]][j] == colnames(never_events)[5]) {
      never_events$`Specimen(s) Lost`[i] <- 1
      }
    else if (split_text[[i]][j] == colnames(never_events)[6]) {
      never_events$`QNS - specimen that cannot be recollected`[i] <- 1
      }
    else if (split_text[[i]][j] == colnames(never_events)[7]) {
      never_events$`Treatment based on mislabeled/misidentified specimen`[i] <- 
        1
      }
    else if (split_text[[i]][j] == colnames(never_events)[8]) {
      never_events$`Treatment based on false positive/false negative results`[i] <- 1
      }
  }
}

never_events <- never_events %>%
  mutate(NEVER_EVENTS = NULL)

never_events_melt <-
  melt(never_events,
       id = c(
         "Facility",
         "NEVER_EVENTS_COMMENTS",
         "Good_Catch"))

never_events_melt$value[is.na(never_events_melt$value)] <- "None"
never_events_melt$value[never_events_melt$value == 1] <- "Present"

never_events_melt[never_events_melt == "None" |
                    never_events_melt == "NONE" |
                    never_events_melt == "none" |
                    never_events_melt == "N/A" |
                    never_events_melt == "n/a" |
                    never_events_melt == "na" |
                    never_events_melt == "NA"] <- "None"

formatted_never_event_melt <- conditional_format_form(never_events_melt)

formatted_never_event_ <-
  dcast(formatted_never_event_melt,
        Facility +
        NEVER_EVENTS_COMMENTS +
        Good_Catch ~ variable)

never_events_column_order_1 <-
  c("Facility",
    "Specimen(s) Lost",
    "QNS - specimen that cannot be recollected",
    "Treatment based on mislabeled/misidentified specimen",
    "Treatment based on false positive/false negative results",
    "NEVER_EVENTS_COMMENTS", "Good_Catch")

formatted_never_event_ <- formatted_never_event_[, never_events_column_order_1]

#Change the order of the rows in the table
trial_neverevent <- right_join(formatted_never_event_, needed_rows)
rownames(trial_neverevent) <- trial_neverevent$Facility

#Change the order of the rows in the table

formatted_never_event <-
  trial_neverevent[c(
    "MSH (Clinical Pathology, Blood Bank, Anatomic Pathology Front End, etc.)",
    "MSQ (Clinical Pathology, Blood Bank, Anatomic Pathology Front End, etc.)",
    "MSBI (Clinical Pathology, Blood Bank, Anatomic Pathology Front End, etc.)",
    "MSB (Clinical Pathology, Blood Bank, Anatomic Pathology Front End, etc.)",
    "MSW (Clinical Pathology, Blood Bank, Anatomic Pathology Front End, etc.)",
    "MSSL (Clinical Pathology, Blood Bank, Anatomic Pathology Front End, etc.)",
    "NYEE (Clinical Pathology, Blood Bank, Anatomic Pathology Front End, etc.)",
    "MSSN (Clinical Pathology, Blood Bank, Anatomic Pathology Front End, etc.)",
    "MSH - Anatomic Pathology (Centralized)",
    "MSH - Central Processing & Accessioning",
    "4LABS - Client Services"), ]

rownames(formatted_never_event) <- NULL

#Change the names in the Facility columns to be standardized

rownames(formatted_never_event) <-
  c("MSH", "MSQ", "MSBI", "MSB", "MSW", "MSSL", "NYEE", "MSSN",
    "Anatomic Pathology (Centralized)",
    "Central Processiong & Accessioning (CPA)",
    "Client Services - 4LABS")

formatted_never_event <- formatted_never_event %>%
  mutate(Facility = rownames(formatted_never_event))

rownames(formatted_never_event) <- NULL

#Split the table into three
#table one is the comments only while table two is the details

good_catch <- formatted_never_event[, c(1, 7)]
good_catch[is.na(good_catch)] <- "No Issues Reported"

good_catch[good_catch == "None" |
             good_catch == "NONE" |
             good_catch == "none" |
             good_catch == "N/A" |
             good_catch == "n/a" |
             good_catch == "na" |
             good_catch == "NA" |
             good_catch == 0] <- "No Issues Reported"


never_events_comments <- formatted_never_event[, c(1, 6)]
never_events_comments[is.na(never_events_comments)] <- "No Issues Reported"

never_events_comments[never_events_comments == "None" |
                        never_events_comments == "NONE" |
                        never_events_comments == "none" |
                        never_events_comments == "N/A" |
                        never_events_comments == "n/a" |
                        never_events_comments == "na" |
                        never_events_comments == "NA" |
                        never_events_comments == 0] <- "No Issues Reported"

never_events_only <- formatted_never_event[, c(1:5)]

```

<br />

## **Operational and Quality Indicators** {.tabset}
### Operational Indicators

#### *Operational Indicators for Labs at each Site & Centralized Anatomic Pathology (Submitted on `r wday_result_date`)*

```{r Qualitative Indicators for Clinical Labs, echo=FALSE, message=FALSE, warning=FALSE, eval = TRUE}

formatted_clinical_labs3 %>%
    select(everything()) %>%
    kable(escape = F, align = "c",
          col.names = c("Facility", "Lab Corp Consumable", "Vendor Services",
                        "Enviroment", "Equipment", "IT", "Service Change",
                        "Acute Volume Increase", "Staffing")) %>%
    kable_styling(bootstrap_options = "hover", full_width = FALSE,
                  position = "center", row_label_position = "c",
                  font_size = 11) %>%
    row_spec(row = 0, font_size = 13)

comments_clinical_labs %>%
    select(everything()) %>%
    kable(escape = F, align = "c",
          col.names = c("Facility", "Comments if At Risk or Not Safe")) %>%
    kable_styling(bootstrap_options = "hover", full_width = TRUE,
                  position = "center", row_label_position = "c",
                  font_size = 11) %>%
    row_spec(row = 0, font_size = 13)

```


### Laboratory Information System
#### *Operational Indicators for LIS (Submitted on `r wday_result_date`)*

```{r Qualitative Indicators for LIS, echo=FALSE, message=FALSE, warning=FALSE, eval = TRUE}

if (is.null(formatted_lis_new2) || nrow(formatted_lis_new2) == 0) {
    formatted_lis_new2 <- NULL
} else{
  formatted_lis_new2 %>%
      select(everything()) %>%
      kable(escape = F, align = "c",
            col.names = c("", "Staffing", "Service Change",
                          "Preplanned Downtime")) %>%
      kable_styling(bootstrap_options = "hover", full_width = FALSE,
                    position = "center", row_label_position = "c",
                    font_size = 11) %>%
      row_spec(row = 0, font_size = 13)
}

```


### Quality Indicators
#### Never Events 
##### *Reported Never Events for Each Division/Facility (Submitted on `r wday_result_date`)*
```{r Lab KPI Form for Never Events, echo=FALSE, message=FALSE, warning=FALSE, eval = TRUE}

never_events_only %>%
    select(everything()) %>%
    kable(escape = F, align = "c",
          col.names = c(
            "Facility", "Specimen(s) Lost",
            "QNS - specimen that cannot be recollected",
            "Treatment based on mislabeled/misidentified specimen",
            "Treatment based on false positive/false negative results")) %>%
    kable_styling(bootstrap_options = "hover", full_width = FALSE,
                  position = "center", row_label_position = "c",
                  font_size = 11) %>%
    row_spec(row = 0, font_size = 13)

never_events_comments %>%
    select(everything()) %>%
    kable(escape = F, align = "c",
          col.names = c("Facility", "Comments if There is a Never Event")) %>%
    kable_styling(bootstrap_options = "hover", full_width = FALSE,
                  position = "center", row_label_position = "c",
                  font_size = 11) %>%
    row_spec(row = 0, font_size = 13)

```

#### Good Catches
##### *Reported Good Catches for Each Division/Facility (Submitted on `r wday_result_date`)*
```{r Lab KPI Form for Good Catches, echo=FALSE, message=FALSE, warning=FALSE, eval = TRUE}

good_catch %>%
    select(everything()) %>%
    kable(escape = F, align = "c",
          col.names = c("Facility", "Good Catch Comment")) %>%
    kable_styling(bootstrap_options = "hover", full_width = FALSE,
                  position = "center", row_label_position = "c",
                  font_size = 11) %>%
    row_spec(row = 0, font_size = 13)

```

<br />

## **Weekday 24-Hour Volume Lookback** {.tabset}

```{r Custom function for 24 hour volume lookbacks for Chemistry and Hematology, echo = FALSE, warning = FALSE, message = FALSE}
#
# Custom function for summarizing resulted lab volume from prior day(s) --------
summarize_cp_vol <- function(x, lab_division) {
  # Subset data to be included based on lab division and site location
  lab_div_vol_df <- x %>%
    filter(Division == lab_division &
             Site %in% city_sites) %>%
    group_by(Site,
             Test,
             DashboardPriority,
             MasterSetting) %>%
    summarize(ResultedLabs = sum(TotalResulted),
              .groups = "keep")
  #
  # Subset volume dataframe template for this division
  lab_div_vol_templ <- vol_dashboard_templ %>%
    filter(Division == lab_division) %>%
    mutate(Incl = NULL)
  #
  # Combine two dataframes to ensure all combinations are accounts for
  lab_div_vol_df <- left_join(lab_div_vol_templ, lab_div_vol_df,
                              by = c("Test" = "Test",
                                     "Site" = "Site",
                                     "DashboardPriority" = "DashboardPriority",
                                     "PtSetting" = "MasterSetting"))
  #
  lab_div_vol_df <- lab_div_vol_df %>%
    mutate(
    # Set test, site, priority, and setting as factors
    Test = droplevels(factor(Test, levels = test_names, ordered = TRUE)),
    Site = droplevels(factor(Site, levels = city_sites, ordered = TRUE)),
    DashboardPriority = droplevels(factor(DashboardPriority,
                                          levels = dashboard_priority_order,
                                          ordered = TRUE)),
    PtSetting = droplevels(factor(PtSetting,
                                         levels = pt_setting_order,
                                         ordered = TRUE)),
    #
    # Replace NA with 0
    ResultedLabs = ifelse(is.na(ResultedLabs), 0, ResultedLabs),
    #
    # Create column with test name and priority
    TestAndPriority = paste(Test, "-", DashboardPriority, "Labs"))
  #
  # Cast dataframe
  lab_div_vol_cast <- dcast(lab_div_vol_df,
                            Test +
                              DashboardPriority +
                              TestAndPriority +
                              PtSetting ~
                              Site,
                            value.var = "ResultedLabs")
  # Remove test and priority columns
  lab_div_vol_cast <- lab_div_vol_cast[, c(3:ncol(lab_div_vol_cast))]
  #
  return(lab_div_vol_cast)
}

#
# Custom function for creating a kable of lab volume from prior day(s)-------
kable_cp_vol <- function(x) {
  kable(x, format = "html", escape = FALSE, align = "c",
        col.names = c("Test & Priority", "Setting",
                      "MSH", "MSQ", "MSBI", "MSB", "MSW", "MSM")) %>%
  kable_styling(bootstrap_options = "hover",
                position = "center",
                font_size = 11) %>%
  column_spec(column = c(1, 8), border_right = "thin solid lightgray") %>%
  add_header_above(c(" " = 1,
                     "Resulted Lab Volume" = (ncol(x) - 1)),
                   background = c("white", "#00AEEF"),
                   color = "white",
                   line = FALSE,
                   font_size = 13) %>%
  column_spec(column = 2:8, background = "#E6F8FF", color = "black") %>%
  # column_spec(column = 2:8,
  #             background = "inherit",
  #             color = "inherit") %>%
  # column_spec(column = 1,
  #             width_min = "125px",
  #             include_thead = TRUE) %>%
  # column_spec(column = c(3, 11),
  #             width_min = "100px",
  #             include_thead = TRUE) %>%
  row_spec(row = 0, font_size = 13) %>%
  collapse_rows(columns = c(1, 2))
}

```

### Chemistry
#### *Chemistry Resulted Lab Volume (Labs Resulted on `r wday_result_date`)*
```{r Chemistry: 24 hour volume lookback, echo = FALSE, warning = FALSE, message = FALSE}
chem_vol_wday_table <- summarize_cp_vol(x = cp_wday_summary,
                                         lab_division = "Chemistry")

kable_cp_vol(chem_vol_wday_table)
```


### Hematology
#### *Hematology Resulted Lab Volume (Labs Resulted on `r wday_result_date`)*
```{r Hematology: 24 hour volume lookback, echo = FALSE, warning = FALSE, message = FALSE}
hem_vol_wday_table <- summarize_cp_vol(x = cp_wday_summary,
                                         lab_division = "Hematology")

kable_cp_vol(hem_vol_wday_table)
```

### Surgical Pathology   
#### *Surgical Pathology Signed Out Cases Volume (As of `r wday_result_date`)*
```{r Surgical Pathology Signed Out Cases on a weekday, echo=FALSE, warning=FALSE, message=FALSE}
table_formatting_volume(sp_strat_vol_weekday_new2,
                        sp_vol_column_names)
```

### Cytology   

#### *Cytology Accessioned Cases and Backlog Volume (As of `r wday_result_date`)*
```{r Cytology Backlog and Accessioned, echo=FALSE, warning=FALSE, message=FALSE}

backlog_acc_table_new2 %>%
  kable(escape = F, align = "c",
        col.names = c("Case Type", "Cases Accessioned", "Backlog Volume",
                      "25th Percentile", "50th Percentile", "Maximum")) %>%
  kable_styling(bootstrap_options = "hover", full_width = TRUE,
                position = "center", row_label_position = "c",
                font_size = 11) %>%
  column_spec(2, background = "#E6F8FF", color = "black") %>%
  column_spec(3:6, background = "#EBEBF9", color = "black") %>%
  row_spec(row = 0, font_size = 13) %>%
  add_header_above(c(
    " " = 2,
    "Elapsed Turn Around Time for Backlogged Cases From the Received Time" = 4),
    background = c("white", "#221F72"), color = "white", font_size = 13) %>%
  collapse_rows(columns = 1)

```



#### *Cytology Signed Out Cases Volume (As of `r wday_result_date`)*
```{r Cytology Signed Out Cases on a weekday, echo=FALSE, warning=FALSE, message=FALSE}
table_formatting_volume(cyto_strat_vol_weekday_new2, cyto_vol_column_names)
```

`r if (include_not_wday != TRUE) {"<!--"}`

```{r Conditional Block for Weekends, eval = include_not_wday, warning = FALSE, message = FALSE, echo = FALSE}

# Chemistry
chem_not_wday_sub_output <- summarize_cp_tat(cp_not_wday_summary,
                                          lab_division = "Chemistry")

chem_not_wday_subset <- chem_not_wday_sub_output[[1]]
chem_not_wday_summary <- chem_not_wday_sub_output[[2]]
chem_not_wday_dashboard_melt <- chem_not_wday_sub_output[[3]]
chem_not_wday_dashboard_cast <- chem_not_wday_sub_output[[4]]

# Hematology
hem_not_wday_sub_output <- summarize_cp_tat(cp_not_wday_summary,
                                        lab_division = "Hematology")

hem_not_wday_subset <- hem_not_wday_sub_output[[1]]
hem_not_wday_summary <- hem_not_wday_sub_output[[2]]
hem_not_wday_dashboard_melt <- hem_not_wday_sub_output[[3]]
hem_not_wday_dashboard_cast <- hem_not_wday_sub_output[[4]]

# Microbiology RRL
micro_not_wday_sub_output <- summarize_cp_tat(cp_not_wday_summary,
                                             lab_division = "Microbiology RRL")
micro_not_wday_subset <- micro_not_wday_sub_output[[1]]
micro_not_wday_summary <- micro_not_wday_sub_output[[2]]
micro_not_wday_dashboard_melt <- micro_not_wday_sub_output[[3]]
micro_not_wday_dashboard_cast <- micro_not_wday_sub_output[[4]]

# Microbiology RRL: Manually remove C. diff ambulatory TAT since only volume
# is monitored for this lab/setting combination
micro_not_wday_dashboard_cast <- micro_not_wday_dashboard_cast %>%
  filter(!(Test == "C. diff" & DashboardSetting == "Amb"))
row.names(micro_not_wday_dashboard_cast) <-
  seq_len(nrow(micro_not_wday_dashboard_cast))

```

`r #Begin weekend/holiday dashboard visualizations`

<br />

## **Weekend/Holiday Efficiency Indicators** {.tabset}
### Chemistry
#### *Chemistry KPI (Labs Resulted on `r wkend_holiday_result_date`)*
<h5>Status Definitions: <span style = "color:red">Red:</span> <80%, 
<span style = "color:orange">Yellow:</span> >=80% & <95%, 
<span style = "color:green">Green:</span> >=95%</h5>'
```{r Chemistry dashboard table for weekends and holidays, eval = include_not_wday, warning = FALSE, message = FALSE, echo = FALSE}

kable_cp_tat(chem_not_wday_dashboard_cast)


```
<h6>*TAT Analysis excludes add on orders, labs with missing timestamps, labs with negative TAT, and labs not from above settings.*</h6>'

### Hematology
#### *Hematology KPI (Labs Resulted on `r wkend_holiday_result_date`)*
<h5>Status Definitions: <span style = "color:red">Red:</span> <80%, 
<span style = "color:orange">Yellow:</span> >=80% & <95%, 
<span style = "color:green">Green:</span> >=95%</h5>
```{r Hematology dashboard table for weekends/holidays, eval = include_not_wday, warning = FALSE, message = FALSE, echo = FALSE}

kable_cp_tat(hem_not_wday_dashboard_cast)

```
<h6>*TAT Analysis excludes add on orders, labs with missing timestamps, labs with negative TAT, and labs not from above settings.*</h6>

```{r Microbiology RRL volume and TAT table creation for weekends/holidays, eval = include_not_wday, warning = FALSE, message = FALSE, echo = FALSE}
#
# Create volume table for Microbiology RRL that mimics TAT table layout
micro_not_wday_volume_melt <- melt(micro_not_wday_summary,
                                   id.var = c("Test",
                                              "Site",
                                              "DashboardPriority",
                                              "TestAndPriority",
                                              "DashboardSetting",
                                              "ReceiveResultTarget",
                                              "CollectResultTarget"),
                                   measure.vars = "ResultedVolume")

# Ensure all Microbiology RRL test, site, and priority combinations are included
micro_not_wday_vol_templ <- tat_dashboard_templ %>%
  filter(Division == "Microbiology RRL") %>%
  mutate(Incl = NULL,
         Division = NULL)

micro_not_wday_volume_melt <- left_join(micro_vol_templ,
                               micro_not_wday_volume_melt,
                               by = c("Test" = "Test",
                                      "Site" = "Site",
                                      "DashboardPriority" = "DashboardPriority",
                                      "DashboardSetting" = "DashboardSetting"))


# Replace NA with 0 and format site, tests, priority, and settings as factors
micro_not_wday_volume_melt <- micro_not_wday_volume_melt %>%
  mutate(
    #
    # Replace NA with 0
    value = ifelse(is.na(value), 0, value),
    #
    # Set test, site, priority, and setting as factors
    Test = droplevels(factor(Test, levels = test_names, ordered = TRUE)),
    Site = droplevels(factor(Site, levels = city_sites, ordered = TRUE)),
    DashboardPriority = droplevels(factor(DashboardPriority,
                                          levels = dashboard_priority_order,
                                          ordered = TRUE)),
    DashboardSetting = droplevels(factor(DashboardSetting,
                                         levels = dashboard_pt_setting,
                                         ordered = TRUE)))

micro_not_wday_volume_cast <- dcast(micro_not_wday_volume_melt,
                           Test + DashboardPriority + TestAndPriority +
                             DashboardSetting + ReceiveResultTarget +
                             CollectResultTarget ~
                             variable + Site,
                           value.var = "value")

original_length <- ncol(micro_not_wday_volume_cast)

micro_not_wday_volume_cast <- micro_not_wday_volume_cast %>%
  mutate(
    #
    # Replace TAT targets with "Resulted Volume"
    ReceiveResultTarget = "Resulted Volume",
    CollectResultTarget = "Resulted Volume",
    #
    # Duplicate dashboard setting column
    DashboardSetting2 = DashboardSetting,
    #
    # Duplicate resulted volume columns
    ResultedVolume_MSH2 = ResultedVolume_MSH,
    ResultedVolume_MSQ2 = ResultedVolume_MSQ,
    ResultedVolume_MSBI2 = ResultedVolume_MSBI,
    ResultedVolume_MSB2 = ResultedVolume_MSB,
    ResultedVolume_MSW2 = ResultedVolume_MSW,
    ResultedVolume_MSM2 = ResultedVolume_MSM) %>%
  select(Test,
         DashboardPriority,
         TestAndPriority,
         ReceiveResultTarget,
         DashboardSetting,
         ResultedVolume_MSH,
         ResultedVolume_MSQ,
         ResultedVolume_MSBI,
         ResultedVolume_MSB,
         ResultedVolume_MSW,
         ResultedVolume_MSM,
         CollectResultTarget,
         DashboardSetting2,
         ResultedVolume_MSH2,
         ResultedVolume_MSQ2,
         ResultedVolume_MSBI2,
         ResultedVolume_MSB2,
         ResultedVolume_MSW2,
         ResultedVolume_MSM2)

# Rename columns to match TAT table for binding
colnames(micro_not_wday_volume_cast) <- colnames(micro_not_wday_dashboard_cast)

micro_not_wday_volume_cast[
  , c(original_length:ncol(micro_not_wday_volume_cast))] <- ""

micro_not_wday_tat_vol_cast <- rbind(micro_not_wday_dashboard_cast,
                                     micro_not_wday_volume_cast)

micro_not_wday_tat_vol_cast <- micro_not_wday_tat_vol_cast %>%
  arrange(Test, ReceiveResultTarget)



```

### Microbiology RRL
#### *Microbiology RRL (Labs Resulted on `r wkend_holiday_result_date`)*
<h5>Status Definitions: <span style = "color:red">Red:</span> <90%, 
<span style = "color:orange">Yellow:</span> >=90% & <100%, 
<span style = "color:green">Green:</span> =100%</h5>
```{r Microbiology RRL dashboard table for weekends/holidays, eval = include_not_wday, warning = FALSE, message = FALSE, echo = FALSE}

kable_cp_tat(micro_not_wday_tat_vol_cast)

```
<h6>*TAT Analysis excludes add on orders, labs with missing timestamps, labs with negative TAT, and labs not from above settings.*</h6>

### Missing Collections & Add Ons
    
#### *Missing Collection Times and Add On Order Volume (Labs Resulted on `r wkend_holiday_result_date`)*

<h5> Missing Collection Status Definitions: <span style = "color:red">Red:</span> >15%, 
<span style = "color:orange">Yellow:</span> <=15% & >5%, 
<span style = "color:green">Green:</span> <=5%</h5>
```{r Missing Collection Times Tables for weekends/holidays, eval = include_not_wday, warning = FALSE, message = FALSE, echo = FALSE}

# Determine percentage of labs with missing collection times ----------------
missing_collect_not_wday <- cp_not_wday_summary %>%
  filter(Site %in% city_sites) %>%
  group_by(Site) %>%
  summarize(ResultedVolume = sum(TotalResultedTAT),
            MissingCollection = sum(TotalMissingCollections, na.rm = TRUE),
            Percent = percent(MissingCollection / ResultedVolume,
                              digits = 0)) %>%
  mutate(
    # Apply conditional formatting based on percentage of labs with missing
    # collections
    Percent = cell_spec(
      Percent, "html",
      color = ifelse(is.na(Percent), "grey",
                     ifelse(Percent <= 0.05, "green",
                            ifelse(Percent <= 0.15, "orange", "red")))),
    # Format site as factors
    Site = factor(Site, levels = city_sites, ordered = TRUE))
#
# Cast missing collections into table format
missing_collect_table_not_wday <- dcast(missing_collect_not_wday,
                               "Percentage of Specimens" ~ Site,
                               value.var = "Percent")
#
# Create a kable of missing collection percentages
missing_collect_table_not_wday %>%
  kable(format = "html", escape = FALSE, align = "c",
        col.names = c("Site", "MSH", "MSQ", "MSBI", "MSB", "MSW", "MSM")) %>%
  kable_styling(
    bootstrap = "hover",
    position = "float_left",
    font_size = 11,
    full_width = FALSE) %>%
  add_header_above(
    c(" " = 1,
      "Percentage of Labs Missing Collect Times" =
        ncol(missing_collect_table) - 1),
    background = c("white", "#00AEEF"),
    color = "white",
    line = FALSE,
    font_size = 13) %>%
  column_spec(column = c(1, ncol(missing_collect_table)),
              border_right = "thin solid lightgray") %>%
  column_spec(column = c(2:ncol(missing_collect_table)),
              background = "#E6F8FF",
              color = "black") %>%
 # column_spec(column = c(2:ncol(missing_collect_table)),
 #             background = "inherit",
 #             color = "inherit",
 #             width_max = 0.15) %>%
  row_spec(row = 0, font_size = 13)

add_on_volume_not_wday <- cp_not_wday_summary %>%
  filter(Site %in% city_sites) %>%
  group_by(Test, Site) %>%
  summarize(AddOnVolume = sum(TotalAddOnOrder, na.rm = TRUE))

add_on_volume_not_wday <- left_join(test_site_comb, add_on_volume_not_wday,
                            by = c("Site" = "Site",
                                  "Test" = "Test"))

add_on_volume_not_wday <- add_on_volume_not_wday %>%
  mutate(
    # Set test and site as factors
    Test = droplevels(factor(Test, levels = test_names, ordered = TRUE)),
    Site = factor(Site, levels = city_sites, ordered = TRUE),
    AddOnVolume = ifelse(is.na(AddOnVolume), 0, AddOnVolume))

add_on_table_not_wday <- dcast(add_on_volume_not_wday,
                               Test ~ Site, value.var = "AddOnVolume")

add_on_table_not_wday %>%
  kable(format = "html", escape = FALSE, align = "c",
        col.names = c("Test", "MSH", "MSQ", "MSBI", "MSB", "MSW", "MSM"),
        color = "gray") %>%
  kable_styling(
    bootstrap = "hover",
    position = "right",
    font_size = 11,
    full_width = FALSE) %>%
  add_header_above(
    c(" " = 1,
      "Volume of Add On Labs" = ncol(missing_collect_table) - 1),
    background = c("white", "#00AEEF"),
    color = "white",
    line = FALSE,
    font_size = 13) %>%
  column_spec(
    column = c(1, ncol(missing_collect_table)),
    border_right = "thin solid lightgray") %>%
  column_spec(
    column = c(2:ncol(missing_collect_table)),
    background = "#E6F8FF", color = "black") %>%
  # column_spec(column = c(2:ncol(missing_collect_table)),
  #             background = "inherit",
  #             color = "inherit") %>%
  row_spec(row = 0, font_size = 13)

```
<h6>*Missing collection time analysis only includes labs represented in dashboard included in TAT analysis*</h6>

`r #Start new tabset for weekend/holiday volume lookback`

<br />

## **Weekend/Holiday Volume Lookback** {.tabset}

### Chemistry
#### *Chemistry Resulted Lab Volume (Labs Resulted on `r wkend_holiday_result_date`)*
```{r Chemistry Weekend/Holiday: volume lookback, eval = include_not_wday, warning = FALSE, message = FALSE, echo = FALSE}

chem_vol_not_wday_table <- summarize_cp_vol(x = cp_not_wday_summary,
                                         lab_division = "Chemistry")

kable_cp_vol(chem_vol_not_wday_table)
```

### Hematology
#### *Hematology Resulted Lab Volume (Labs Resulted on `r wkend_holiday_result_date`)*
```{r Hematology Weekend/Holiday: volume lookback, eval = include_not_wday, warning = FALSE, message = FALSE, echo = FALSE}

hem_vol_wday_table <- summarize_cp_vol(x = cp_wday_summary,
                                         lab_division = "Hematology")

kable_cp_vol(hem_vol_wday_table)

```


`r if (include_not_wday != TRUE) {"-->"}`

## **Assumptions and Methodology** {.tabset}
### Definitions
<h4><b>Definition table</b></h4>
The table below summarizes the definitions for some of the terminology used in this dashboard for clarification purposes. 

```{r format table for definitions}

definition_table <-
  data.frame(read_excel(reference_file, sheet = "Definitions"),
             stringsAsFactors = FALSE)

definition_table  %>%
  kable(format = "html", escape = FALSE, align = "c",
        col.names = c("Terminology Used", "Terminology Definition")) %>%
  kable_styling(bootstrap_options = "hover", position = "center",
                font_size = 11, full_width = FALSE) %>%
  column_spec(column = c(1, 2), border_right = "thin solid lightgray") %>%
  row_spec(row = 0, font_size = 13, background = "#221f72", color = "white")

```

### Clinical Pathology

<h4><b>Data Sources</b></h4>
MSH and MSQ: Based on daily SCC report. Report name changes daily but follows structure of "DocMM-DD_xxxxxx.xlsx"</br>
MSBI, MSB, MSW, MSM: Based on daily Sunquest report titled "KPI_Daily_TAT_Report_Updated.xls"</br>
The table below summarizes the test codes and IDs used from these daily reports.

```{r Create and format a table for test codes}

test_codes_kable <- test_code %>%
  mutate(Test = factor(Test, levels = cp_micro_lab_order, ordered = TRUE)) %>%
  arrange(Test)

test_codes_kable <-
  test_codes_kable[, c("Division", "Test", "SCC_TestID", "SUN_TestCode")]

test_codes_kable %>%
  kable(format = "html", escape = FALSE, align = "c",
        col.names = c("Lab Division", "Test", "SCC Test ID",
                      "Sunquest Test Code")) %>%
  kable_styling(bootstrap_options = "hover", position = "center",
                font_size = 11, full_width = FALSE) %>%
  column_spec(column = c(1, 2, 3, 4), border_right = "thin solid lightgray") %>%
  row_spec(row = 0, font_size = 13, background = "#221f72", color = "white") %>%
  collapse_rows()

```

<h4><b>Target Turnaround Times</b></h4>
The table below summarizes target turnaround times as agreed upon by clinical and operational leadership. 
```{r Create and format tables for TAT targets }

tat_targets_kable <- tat_targets %>%
  mutate(Test = factor(Test, levels = cp_micro_lab_order, ordered = TRUE),
         Priority = factor(Priority, levels = dashboard_priority_order,
                           ordered = TRUE)) %>%
  arrange(Test, Priority)

tat_targets_kable <- tat_targets_kable %>%
  mutate(Concate = NULL)

tat_targets_kable %>%
  kable(format = "html", escape = FALSE, align = "c",
        col.names = c("Test", "Priority", "Patient Setting",
                      "Receive to Result TAT Target (min)",
                      "Collect to Result TAT Target (min)"),
        caption = "Target Turnaround Times") %>%
  kable_styling(bootstrap_options = "hover", position = "center",
                font_size = 11, full_width = FALSE) %>%
  column_spec(column = c(1, 2, 3, 5), border_right = "thin solid lightgray") %>%
  row_spec(row = 0, font_size = 13, background = "#221f72", color = "white")

```

<h4><b>Additional notes on target turnaround times:</b></h4>

* Troponin and Lactate WB:
    + All labs are treated as stat regardless of documented priority and patient setting.
    + Ambulatory labs excluded from turnaround time analysis
* Rapid Flu:
    + All labs are treated as stat regardless of documented priority and patient setting.
* C. diff:
    + All labs are treated as stat regardless of documented priority and patient setting.
    + Turnaround time for ambulatory C. diff tests are not tracked but rather volume of these labs is monitored.

<h4><b>Turnaround Time Exclusions</b></h4>

Turnaround time analysis excludes labs with out of order steps (ie, collect after receive), missing timestamps, add-on orders, and labs not originating in IP, ED, or ambulatory settings (ie, Outreach).

<br>
  
<h4><b>Add On Orders</b></h4>
Add on orders are defined as labs with an order time more than 5 minutes after receive time. These labs are excluded from turnaround time analysis but the volume of these labs is monitored.

<br>

<h4><b>Missing Collections</b></h4>
Labs are classified as missing collections based on the following criteria:

* SCC: Collection time equal to receive time
* Sunquest: Collection time equal to order time

### Anatomic Pathology
<h4><b>Target Turnaround Times</b></h4>
The table below summarizes target turnaround times for Anatomic Pathology as agreed upon by clinical and operational leadership. 

```{r Target Turnaround Times Table}

tat_targets_ap  %>%
  kable(format = "html", escape = FALSE, align = "c",
        col.names = c("Test", "Patient Setting",
                      "Receive to Result TAT Target (days)",
                      "Collect to Result TAT Target (days)")) %>%
  kable_styling(bootstrap_options = "hover", position = "center",
                font_size = 11, full_width = FALSE) %>%
  column_spec(column = c(1, 2, 3, 4), border_right = "thin solid lightgray") %>%
  row_spec(row = 0, font_size = 13, background = "#221f72", color = "white") %>%
  collapse_rows(columns = 1)

```


<h4><b>Inclusion and Exclusion Criteria for GI Specimens</b></h4>
The table below summarizes the GI codes that were included vs. excluded during the TAT and volume calculations as agreed upon by clinical and operational leadership.
<br>
Only the codes for GI biopsies are included in the analysis.

```{r GI Codes Table}
gi_codes_updated <-
  gi_codes[, c("GI.Codes.Must.Include.in.Analysis..All.GI.Biopsies.",
              "Spec_code")]

gi_codes_updated  %>%
  kable(format = "html", escape = FALSE, align = "c",
        col.names = c("Specimen Code", "Included vs. Excluded Codes")) %>%
  kable_styling(bootstrap_options = "hover", position = "center",
                font_size = 11, full_width = FALSE) %>%
  column_spec(column = c(1, 2), border_right = "thin solid lightgray") %>%
  row_spec(row = 0, font_size = 13, background = "#221f72",
           color = "white") %>%
  collapse_rows(columns = 1)
```

<h4><b>Additional notes on target turnaround times:</b></h4>

* Receive to Result TAT: for anatomic pathology this metric only includes MSHS business days and is a measure of internal laboratory performance.

* Collect to Result TAT: for anatomic pathology this metric includes all calendar days and is a patient-centric measure of performance.

* At this phase, target turnaround times for collect to result have not been established. This metric will be tracked in order to understand current performance and establish future targets.

* Primary Specimens: When a specimen has multiple slides, only the first slide is included. The primary slide is identified as those with spec_sort_order = A.

* All Breast Specimens:
    + Included all the primary breast specimens only. 
    + Only labs from ambulatory and inpatient services with valid time stamps included in TAT calculations.
    + TAT analysis excludes labs with missing timestamps
    + All settings included in the resulted volume
    
* GI Biopsies:
    + Included only the samples that are consisted of GI biopsies
    + Only primary specimen GI biopsies included
    + Only labs from ambulatory and inpatient services with valid time stamps included in TAT calculations.
    + TAT analysis excludes labs with missing timestamps
    + All settings included in the resulted volume

* Cyto Gyn:
    + TAT and volume analysis were only calculated for Cyto Gyn specimens that were finalized and closed out in EPIC
    + Included all primary Cyto Gyn specimens
    + Only labs from ambulatory and inpatient services with valid time stamps included in TAT calculations.
    + TAT analysis excludes labs with missing timestamps
    + All settings included in the resulted volume

* Cyto Non-Gyn:
    + TAT and volume analysis were only calculated for Cyto non-Gyn specimens that were finalized and closed out in EPIC
    + Included all primary Cyto non-Gyn specimens
    + Only labs from ambulatory and inpatient services with valid time stamps included in TAT calculations.
    + TAT analysis excludes labs with missing timestamps
    + All settings included in the resulted volume

* Backlog Cases:
    + Backlog cases are defined as all the cases that are open by cytology and microbiology.
    
<h6> *End of report.* </h6>
